<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Gateway Suite - Environments</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;600;700&display=swap');

    /* Smooth page transition - prevent flash */
    html {
      background: #f9fafb;
    }

    body {
      opacity: 1;
      transition: opacity 0.08s ease-out;
    }

    body.loading {
      opacity: 0;
    }

    :root {
      --primary: #0066ff;
      --primary-dark: #0052cc;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --gray-50: #f9fafb;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-600: #4b5563;
      --gray-700: #374151;
      --gray-900: #111827;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --radius: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--gray-50);
      color: var(--gray-900);
      line-height: 1.5;
      padding-top: 56px;
    }

    /* Navigation */
    .nav {
      background: var(--gray-900);
      padding: 0 24px;
      display: flex;
      align-items: center;
      height: 56px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .nav-brand {
      color: #fff;
      font-weight: 700;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .nav-brand svg {
      width: 28px;
      height: 28px;
    }

    .nav-links {
      display: flex;
      gap: 4px;
      margin-left: 40px;
    }

    .nav-link {
      color: var(--gray-300);
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.15s;
    }

    .nav-link:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .nav-link.active {
      color: #fff;
      background: var(--primary);
    }

    .nav-status {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--gray-300);
      font-size: 13px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    /* Main Content */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
    }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .page-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--gray-900);
    }

    .page-subtitle {
      color: var(--gray-600);
      font-size: 14px;
      margin-top: 4px;
    }

    .page-subtitle-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .page-subtitle-row .page-subtitle {
      margin-top: 0;
    }

    .page-subtitle-banner {
      display: flex;
      align-items: center;
    }

    .admin-session-banner {
      margin-top: 0;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.35;
    }

    .diagnostics-result {
      margin-top: 12px;
      padding: 12px;
      border: 1px solid var(--gray-200);
      border-radius: 12px;
      background: var(--gray-50);
      display: grid;
      gap: 8px;
      font-size: 12px;
    }

    .diagnostics-row {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .diagnostics-key {
      color: var(--gray-700);
      font-weight: 800;
      min-width: 140px;
    }

    .diagnostics-value {
      color: var(--gray-900);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
      flex: 1;
      word-break: break-all;
      overflow-wrap: break-word;
      min-width: 0;
      text-align: right;
    }

    .diagnostics-pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 11px;
      border: 1px solid transparent;
    }

    .diagnostics-pill.ok {
      background: #dcfce7;
      color: #166534;
      border-color: #bbf7d0;
    }

    .diagnostics-pill.warn {
      background: #fef9c3;
      color: #854d0e;
      border-color: #fde68a;
    }

    .diagnostics-pill.bad {
      background: #fee2e2;
      color: #7f1d1d;
      border-color: #fecaca;
    }

    .diagnostics-pill.na {
      background: #f3f4f6;
      color: #374151;
      border-color: #e5e7eb;
    }

    .diagnostics-advanced {
      margin-top: 8px;
      opacity: 0.9;
    }

    /* Content Grid */
    .content-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    .side-stack {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .bottom-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-top: 24px;
    }

    .bottom-grid > .card {
      align-self: start;
    }

    @media (max-width: 900px) {
      .content-grid {
        grid-template-columns: 1fr;
      }

      .bottom-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Card */
    .card {
      background: #fff;
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--gray-200);
    }

    .card-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-header h2 {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-900);
    }

    .card-header svg {
      width: 20px;
      height: 20px;
      color: var(--primary);
    }

    .card-body {
      padding: 0;
    }

    /* Table */
    table {
      border-collapse: collapse;
      width: 100%;
    }

    th {
      background: var(--gray-50);
      font-size: 12px;
      font-weight: 600;
      color: var(--gray-600);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--gray-200);
    }

    td {
      padding: 14px 16px;
      font-size: 14px;
      border-bottom: 1px solid var(--gray-100);
      vertical-align: middle;
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr:hover {
      background: var(--gray-50);
    }

    /* Status Indicator */
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 500;
    }

    .status-indicator::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-indicator.active::before {
      background: var(--success);
    }

    .status-indicator.inactive::before {
      background: var(--gray-300);
    }

    .status-indicator.error::before {
      background: var(--danger);
    }

    .status-indicator.testing::before {
      background: var(--warning);
    }

    /* Endpoint */
    .endpoint-text {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      color: var(--gray-600);
      background: var(--gray-100);
      padding: 4px 8px;
      border-radius: 4px;
      word-break: break-all;
    }

    /* Note */
    .note-text {
      font-size: 13px;
      color: var(--gray-600);
    }

    /* Form */
    .form-card {
      padding: 20px;
    }

    .form-card h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .form-card h3 svg {
      width: 18px;
      height: 18px;
      color: var(--primary);
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: 6px;
    }

    .form-input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--gray-300);
      border-radius: 6px;
      font-size: 14px;
      background: #fff;
      transition: all 0.15s;
    }

    .form-select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--gray-300);
      border-radius: 6px;
      font-size: 14px;
      background: #fff;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
    }

    .form-input::placeholder {
      color: var(--gray-300);
    }

    .form-hint {
      font-size: 12px;
      color: var(--gray-600);
      margin-top: 4px;
    }

    .form-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .form-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
      color: var(--gray-700);
    }

    .form-toggle input {
      margin: 0;
    }

    .hint-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
    }

    .hint-link:hover {
      text-decoration: underline;
    }

    .provider-hint-details {
      margin-top: 6px;
    }

    .provider-hint-details summary {
      cursor: pointer;
      display: inline-block;
      color: var(--danger);
      font-size: 12px;
      font-weight: 600;
      line-height: 1.2;
    }

    .provider-hint-details[open] summary {
      margin-bottom: 6px;
    }

    .provider-hint-body {
      padding: 8px 10px;
      border: 1px solid var(--gray-200);
      background: var(--gray-50);
      border-radius: 6px;
      color: var(--gray-700);
      font-size: 12px;
      line-height: 1.5;
    }

    .provider-hint-body ul {
      margin: 6px 0 0 18px;
    }

    .provider-hint-muted {
      color: var(--gray-600);
    }

    /* Inline hint next to inputs */
    .form-inline {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      flex-wrap: wrap;
    }

    .form-inline .form-input {
      flex: 1 1 auto;
      min-width: 0;
    }

    .inline-hint {
      font-size: 12px;
      color: var(--gray-600);
      margin-top: 4px;
      white-space: normal;
      flex: 1 1 100%;
    }

    @media (max-width: 520px) {
      .form-inline {
        flex-wrap: wrap;
      }

      .inline-hint {
        white-space: normal;
      }
    }

    /* Button */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      border: none;
    }

    .btn-primary {
      background: var(--primary);
      color: #fff;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-primary:disabled {
      background: var(--gray-300);
      cursor: not-allowed;
    }

    .btn svg {
      width: 16px;
      height: 16px;
    }

    /* Info Box */
    .info-box {
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      border-radius: var(--radius);
      padding: 12px 16px;
      margin-top: 16px;
      display: flex;
      gap: 12px;
    }

    .info-box svg {
      width: 20px;
      height: 20px;
      color: #3b82f6;
      flex-shrink: 0;
      margin-top: 2px;
    }

    .info-box-content {
      font-size: 13px;
      color: #1e40af;
    }

    .info-box-content strong {
      font-weight: 600;
    }

    .info-box-actions {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Danger Zone */
    .danger-zone {
      margin-top: 16px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: var(--radius);
      padding: 12px 14px;
      display: grid;
      gap: 10px;
    }

    .danger-zone-title {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #991b1b;
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }

    .danger-zone-title svg {
      width: 16px;
      height: 16px;
      color: #991b1b;
      flex-shrink: 0;
    }

    .danger-zone-note {
      font-size: 13px;
      color: #7f1d1d;
      line-height: 1.5;
    }

    .danger-zone-options {
      display: grid;
      gap: 10px;
    }

    .danger-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .danger-status {
      font-size: 12px;
      color: #7f1d1d;
    }

    .danger-zone .btn-danger {
      border-color: #b91c1c;
    }

    .intro-guide-body.collapsed {
      display: none;
    }

    /* Summary Panel */
    .summary-panel {
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius);
      padding: 12px 14px;
      margin-top: 16px;
      display: grid;
      gap: 10px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-size: 13px;
    }

    .summary-label {
      color: var(--gray-600);
      font-weight: 600;
    }

    .summary-value {
      color: var(--gray-900);
      font-weight: 600;
      text-align: right;
      word-break: break-all;
      overflow-wrap: break-word;
      min-width: 0;
    }

    .summary-mono {
      font-family: 'SF Mono', Monaco, monospace;
      font-weight: 500;
      font-size: 12px;
      color: var(--gray-700);
      word-break: break-all;
      overflow-wrap: break-word;
    }

    .summary-chips {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 6px;
    }

    .summary-chip {
      background: #e0f2fe;
      color: #075985;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Wizard */
    .wizard-steps {
      list-style: none;
      display: grid;
      gap: 10px;
      margin: 0 0 16px;
      padding: 0;
    }

    .wizard-step {
      display: grid;
      grid-template-columns: 22px 1fr;
      gap: 10px;
      align-items: flex-start;
    }

    .wizard-index {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--primary);
      color: #fff;
      font-size: 12px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wizard-text {
      font-size: 13px;
      color: var(--gray-600);
    }

    .form-row .form-input {
      flex: 1;
      min-width: 180px;
    }

    .form-textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      border: 1px dashed var(--gray-300);
      border-radius: 6px;
      padding: 10px 12px;
      background: var(--gray-100);
      color: var(--gray-700);
    }

    .btn-secondary {
      background: var(--gray-100);
      color: var(--gray-700);
      border: 1px solid var(--gray-300);
    }

    .btn-secondary:hover {
      background: var(--gray-200);
    }

    .btn-danger {
      background: var(--danger);
      color: #fff;
      border: 1px solid #b91c1c;
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    .btn-danger:disabled {
      background: var(--gray-300);
      border-color: var(--gray-300);
      cursor: not-allowed;
    }

    .btn-sm {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
    }

    .copy-status {
      font-size: 12px;
      color: var(--gray-600);
    }

    .table-box {
      border: 1px solid var(--gray-200);
      border-radius: 6px;
      overflow: hidden;
      overflow-x: auto;
      background: #fff;
    }

    .token-table {
      width: 100%;
      min-width: 600px;
    }

    .token-table th {
      background: var(--gray-100);
      font-size: 11px;
      white-space: nowrap;
    }

    .token-table td {
      font-size: 12px;
      white-space: nowrap;
    }

    .token-table code {
      font-size: 11px;
    }

    /* Language Toggle */
    .lang-toggle {
      display: inline-flex;
      gap: 4px;
      background: var(--gray-100);
      padding: 4px;
      border-radius: 6px;
    }

    .lang-btn {
      padding: 6px 12px;
      border: 1px solid transparent;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      background: transparent;
      color: var(--gray-600);
    }

    .lang-btn.active {
      background: #fff;
      color: var(--primary);
      border-color: var(--primary);
    }

    .lang-toggle-row {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      font-weight: 600;
      color: var(--gray-600);
    }

    /* Collapsible Sections */
    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: pointer;
      user-select: none;
      padding: 0;
      background: none;
      border: none;
      width: 100%;
    }

    .collapsible-header:hover {
      opacity: 0.8;
    }

    .collapsible-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      transition: transform 0.3s;
    }

    .collapsible-body {
      overflow: hidden;
      max-height: 9999px;
      transition: max-height 0.3s, opacity 0.3s;
      opacity: 1;
    }

    .collapsible-body.collapsed {
      max-height: 0;
      opacity: 0;
    }

    /* rotate caret when card is collapsed */
    .card.form-card.collapsed .collapsible-toggle {
      transform: rotate(-90deg);
    }

    /* ===== Onboarding Wizard Modal ===== */
    .wizard-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .wizard-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .wizard-modal {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow: hidden;
      transform: scale(0.9) translateY(20px);
      transition: transform 0.3s ease;
    }

    .wizard-overlay.active .wizard-modal {
      transform: scale(1) translateY(0);
    }

    .wizard-header {
      background: linear-gradient(135deg, #0066ff 0%, #0052cc 100%);
      color: white;
      padding: 24px 28px;
    }

    .wizard-header h2 {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .wizard-header p {
      opacity: 0.9;
      font-size: 14px;
    }

    .wizard-progress {
      display: flex;
      gap: 8px;
      margin-top: 20px;
    }

    .wizard-progress-step {
      flex: 1;
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      transition: background 0.3s;
    }

    .wizard-progress-step.completed {
      background: #10b981;
    }

    .wizard-progress-step.active {
      background: #fff;
    }

    .wizard-body {
      padding: 28px;
      min-height: 320px;
    }

    .wizard-step {
      display: none;
    }

    .wizard-step.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateX(10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .wizard-step-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--gray-900);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .wizard-step-title .step-number {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      color: white;
      border-radius: 50%;
      font-size: 14px;
      font-weight: 700;
    }

    .wizard-step-desc {
      color: var(--gray-600);
      font-size: 14px;
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .wizard-token-form {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .wizard-token-form-label {
      font-size: 13px;
      font-weight: 600;
      color: var(--gray-700);
    }
    .wizard-token-form-actions {
      display: flex;
      gap: 8px;
    }
    .wizard-token-form-actions input {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--gray-300);
      border-radius: 6px;
    }
    .wizard-token-help {
      font-size: 12px;
      color: var(--gray-600);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .wizard-token-help code {
      font-size: 12px;
    }
    .wizard-token-action {
      display: flex;
      justify-content: flex-end;
    }

    .wizard-token-guide {
      margin: 12px 0 16px;
      padding: 14px;
      border: 1px solid var(--gray-200);
      border-radius: 10px;
      background: var(--gray-50);
    }
    .wizard-token-guide-title {
      font-weight: 600;
      margin-bottom: 8px;
    }
    .wizard-token-guide-list {
      margin: 0 0 8px;
      padding-left: 18px;
      line-height: 1.5;
    }

    .wizard-input-group {
      margin-bottom: 16px;
    }

    .wizard-input-group label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: 6px;
    }

    .wizard-input-group input,
    .wizard-input-group select {
      width: 100%;
      padding: 12px 14px;
      border: 1px solid var(--gray-300);
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.15s;
    }

    .wizard-input-group input:focus,
    .wizard-input-group select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
    }

    .wizard-input-group .input-hint {
      font-size: 12px;
      color: var(--gray-600);
      margin-top: 6px;
    }

    .wizard-input-group .input-hint a {
      color: var(--primary);
      text-decoration: none;
    }

    .wizard-success-icon {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
    }

    .wizard-success-icon svg {
      width: 32px;
      height: 32px;
      color: white;
    }

    .wizard-test-result {
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: 8px;
      position: relative;
      padding: 12px 14px;
      padding-right: 38px;
      margin-top: 16px;
      font-size: 13px;
      font-weight: 600;
      line-height: 1.35;
    }

    .wizard-test-result .dismiss-btn {
      appearance: none;
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      padding: 0;
      border: 1px solid transparent;
      border-radius: 6px;
      background: transparent;
      color: var(--gray-700);
      font-size: 16px;
      line-height: 1;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
    }

    .wizard-test-result .dismiss-btn:hover {
      opacity: 1;
      background: rgba(17, 24, 39, 0.06);
      border-color: rgba(17, 24, 39, 0.12);
    }

    .wizard-test-result .dismiss-btn:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.2);
      opacity: 1;
    }

	    .wizard-test-result.success {
	      background: #ecfdf5;
	      border-color: #10b981;
	    }

	    .wizard-test-result.warn {
	      background: #fffbeb;
	      border-color: #f59e0b;
	    }

	    .wizard-test-result.error {
	      background: #fef2f2;
	      border-color: #ef4444;
	    }

	    .wizard-test-actions {
	      margin-top: 10px;
	      display: flex;
	      gap: 8px;
	      flex-wrap: wrap;
	    }

	    .wizard-test-actions .btn {
	      padding: 6px 10px;
	      font-size: 12px;
	      border-radius: 8px;
	    }

	    .wizard-footer {
	      padding: 16px 28px;
	      border-top: 1px solid var(--gray-200);
	      display: flex;
	      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .wizard-footer .btn {
      min-width: 120px;
    }

    .wizard-skip {
      color: var(--gray-600);
      font-size: 13px;
      cursor: pointer;
      text-decoration: underline;
    }

    .wizard-skip:hover {
      color: var(--gray-900);
    }
  </style>
</head>

<body>
  <nav class="nav">
    <div class="nav-brand">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />
      </svg>
      MCP Gateway Suite
    </div>
    <div class="nav-links">
      <a href="settings_environments.html" class="nav-link active">Environments</a>
      <a href="dashboard.html" class="nav-link">Dashboard</a>
      <a href="scans.html" class="nav-link">Scans</a>
      <a href="allowlist.html" class="nav-link">AllowList</a>
      <a href="web_sandbox.html" class="nav-link">Web Sandbox</a>
      <a href="audit_log.html" class="nav-link">Audit Log</a>
      <a href="evidence_pack.html" class="nav-link">Evidence Pack</a>
    </div>
    <div class="nav-status">
      <span class="status-dot"></span>
      Demo Mode
    </div>
  </nav>

  <div class="container" data-onboarding-root="true">
    <div class="page-header">
      <div>
        <h1 class="page-title" id="pageTitle">Environments</h1>
	        <div class="page-subtitle-row">
	          <p class="page-subtitle" id="pageSubtitle">Manage MCP Gateway environments and endpoints</p>
	          <div class="page-subtitle-banner" data-admin-session-banner-anchor="page-header">
			            <div id="adminSessionBanner" class="wizard-test-result error admin-session-banner" role="alert"
			              style="display:none;">
			              <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
			              <span id="adminSessionBannerMessage"></span>
			              <div class="wizard-test-actions">
			                <button type="button" class="btn btn-secondary" id="adminSessionBannerCta"
			                  style="display:none;"></button>
			              </div>
			            </div>
		          </div>
	        </div>
	      </div>
      <div class="lang-toggle-row">
        <span id="langLabel">Language:</span>
        <div class="lang-toggle">
          <button type="button" class="lang-btn" id="langJa" data-lang="ja">JA</button>
          <button type="button" class="lang-btn" id="langEn" data-lang="en">EN</button>
        </div>
      </div>
    </div>

    <div class="info-box" id="introGuide" style="margin-bottom:16px">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10" />
        <line x1="12" y1="8" x2="12" y2="16" />
        <line x1="8" y1="12" x2="16" y2="12" />
      </svg>
      <div class="info-box-content">
        <strong id="guideTitle" data-i18n="intro.title">Initial Setup Guide</strong>
        <div id="introGuideBody" class="intro-guide-body">
          <ol style="padding-left:18px; margin-top:4px; display:grid; gap:4px;">
            <li id="guideStep1" data-i18n="intro.step1">Enter Admin Token, save upstream (LLM), and run connectivity test</li>
            <li id="guideStep2" data-i18n="intro.step2">Review Proxy Model IDs and add if needed</li>
            <li id="guideStep3" data-i18n="intro.step3">Select Policy Profile and configure additional Restricted Sinks</li>
            <li id="guideStep4" data-i18n="intro.step4">Register connections in the Environments table</li>
          </ol>
        </div>
      </div>
      <div class="info-box-actions">
        <button type="button" class="btn btn-secondary" id="introGuideToggleBtn">Hide Setup Guide</button>
        <button type="button" class="btn btn-primary" id="introGuideResetBtn">Initial Setup</button>
      </div>
    </div>

    <div class="content-grid">
      <div class="card">
        <div class="card-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
            <line x1="8" y1="21" x2="16" y2="21" />
            <line x1="12" y1="17" x2="12" y2="21" />
          </svg>
          <h2 id="envTableTitle">Registered Environments</h2>
        </div>
        <div class="card-body">
          <table data-testid="env-table">
            <thead>
              <tr>
                <th id="envColName">Name</th>
                <th id="envColEndpoint">Endpoint</th>
                <th id="envColStatus">Status</th>
                <th id="envColNote">Note</th>
              </tr>
            </thead>
            <tbody id="envRows"></tbody>
          </table>
        </div>

        <!-- Environment Quick Status -->
        <div style="margin-top: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;" id="envQuickStatus">
          <div style="background: #fff; border: 1px solid var(--gray-200); border-radius: var(--radius); padding: 14px;">
            <div style="font-size: 11px; font-weight: 600; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.5px;" id="qsConnectionLabel">Connection</div>
            <div style="font-size: 20px; font-weight: 700; margin-top: 4px;" id="qsConnectionValue">
              <span class="status-indicator" id="qsConnectionStatus">-</span>
            </div>
            <div style="font-size: 12px; color: var(--gray-600); margin-top: 2px;" id="qsConnectionSub">Upstream status</div>
          </div>
          <div style="background: #fff; border: 1px solid var(--gray-200); border-radius: var(--radius); padding: 14px;">
            <div style="font-size: 11px; font-weight: 600; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.5px;" id="qsUpstreamLabel">Upstream</div>
            <div style="font-size: 14px; font-weight: 600; margin-top: 6px; font-family: 'SF Mono', Monaco, monospace; word-break: break-all; color: var(--gray-700);" id="qsUpstreamValue">Not set</div>
          </div>
          <div style="background: #fff; border: 1px solid var(--gray-200); border-radius: var(--radius); padding: 14px;">
            <div style="font-size: 11px; font-weight: 600; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.5px;" id="qsPolicyLabel">Policy Profile</div>
            <div style="font-size: 16px; font-weight: 700; margin-top: 4px;" id="qsPolicyValue">-</div>
            <div style="font-size: 12px; color: var(--gray-600); margin-top: 2px;" id="qsPolicySub">Current profile</div>
          </div>
          <div style="background: #fff; border: 1px solid var(--gray-200); border-radius: var(--radius); padding: 14px;">
            <div style="font-size: 11px; font-weight: 600; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.5px;" id="qsTokensLabel">Active Tokens</div>
            <div style="font-size: 20px; font-weight: 700; margin-top: 4px; color: var(--primary);" id="qsTokensValue">0</div>
            <div style="font-size: 12px; color: var(--gray-600); margin-top: 2px;" id="qsTokensSub">Issued tokens</div>
          </div>
        </div>
      </div>

      <div class="side-stack">
        <div class="card form-card">
          <div class="collapsible-header" data-section="diagnostics">
            <h3 id="diagnosticsTitle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3v18h18" />
                <path d="M7 14l3-3 3 3 5-7" />
              </svg>
              System Diagnostics
            </h3>
            <div class="collapsible-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9" />
              </svg>
            </div>
          </div>
          <div class="collapsible-body">
            <p class="form-hint" id="diagnosticsHint">
              One-click check: upstream validity, tokens, and policy bundle status.
            </p>
            <div class="form-inline" style="flex-wrap: wrap; gap: 10px;">
              <button type="button" class="btn btn-primary" id="diagnosticsRunBtn"
                data-testid="diagnostics-run">Run Diagnostics</button>
              <button type="button" class="btn btn-secondary" id="diagnosticsCopyBtn" style="display:none;"
                data-testid="diagnostics-copy">Copy JSON</button>
              <button type="button" class="btn btn-secondary" id="diagnosticsDownloadBtn" style="display:none;"
                data-testid="diagnostics-download">Download JSON</button>
            </div>
            <div class="diagnostics-result" id="diagnosticsResult" style="display:none;" data-testid="diagnostics-result"></div>
            <div class="form-inline" style="flex-wrap: wrap; gap: 10px;">
              <button type="button" class="btn btn-secondary" id="diagnosticsCta" style="display:none;"></button>
            </div>
            <p class="form-hint diagnostics-advanced" id="diagnosticsAdvancedHint">
              Operator/QA: Export JSON only when needed (incident/support).
            </p>
          </div>
        </div>

        <div class="card form-card">
          <div class="collapsible-header" data-section="env">
            <h3 id="addEnvTitle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10" />
                <line x1="12" y1="8" x2="12" y2="16" />
                <line x1="8" y1="12" x2="16" y2="12" />
              </svg>
              Add Environment
            </h3>
            <div class="collapsible-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9" />
              </svg>
            </div>
          </div>
          <div class="collapsible-body">
            <form id="envForm">
              <div class="form-group">
                <label class="form-label" for="envName" id="envNameLabel">Environment Name</label>
                <input type="text" id="envName" class="form-input" placeholder="e.g., gateway-staging" required
                  data-testid="env-name" />
                <p class="form-hint" id="envNameHint">A unique identifier for this environment</p>
              </div>
              <div class="form-group">
                <label class="form-label" for="envEndpoint" id="envEndpointLabel">Endpoint URL</label>
                <input type="url" id="envEndpoint" class="form-input" placeholder="https://gateway.example.com/api"
                  required data-testid="env-endpoint" />
                <p class="form-hint" id="envEndpointHint">The base URL for the MCP Gateway API</p>
              </div>
              <div class="form-group">
                <label class="form-label" for="envNote" id="envNoteLabel">Note (Optional)</label>
                <input type="text" id="envNote" class="form-input" placeholder="Purpose or description"
                  data-testid="env-note" />
              </div>
	              <button type="submit" class="btn btn-primary" id="envSaveBtn" data-testid="env-save">
	                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                  <line x1="12" y1="5" x2="12" y2="19" />
	                  <line x1="5" y1="12" x2="19" y2="12" />
	                </svg>
	                Add Environment
	              </button>
		              <div id="envIssueResult" class="wizard-test-result" role="alert" style="display:none; margin-top:12px;">
		                <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
		                <span id="envIssueMessage"></span>
		              </div>
	            </form>

            <div class="info-box">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10" />
                <line x1="12" y1="16" x2="12" y2="12" />
                <line x1="12" y1="8" x2="12.01" y2="8" />
              </svg>
              <div class="info-box-content" id="settingsApiHint">
                <strong id="settingsApiLabel">Settings API:</strong> <span id="settingsApiText">Environments are saved
                  to the gateway registry. Secrets are never returned.</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="bottom-grid">
      <div class="card form-card">
          <div class="collapsible-header" data-section="upstream">
            <h3 id="upstreamTitle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2v20M2 12h20" />
              </svg>
              Upstream LLM
            </h3>
            <div class="collapsible-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9" />
              </svg>
            </div>
          </div>
          <div class="collapsible-body">
            <form id="upstreamForm">
              <div class="form-group" id="adminSessionGroup">
                <label class="form-label" for="adminToken" id="adminTokenLabel">Admin Session</label>
                <div class="form-inline">
                  <input type="password" id="adminToken" class="form-input"
                    placeholder="Paste control plane admin token" autocomplete="off" data-testid="admin-token" />
                  <button type="button" class="btn btn-secondary" id="adminSessionStartBtn"
                    data-testid="admin-session-start">Start Session</button>
                  <span class="inline-hint" id="adminTokenHint"></span>
                </div>
                <p class="form-hint" id="adminSessionStatus"></p>
                <div class="danger-zone" id="dangerZone">
                  <div class="danger-zone-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path
                        d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" />
                      <line x1="12" y1="9" x2="12" y2="13" />
                      <line x1="12" y1="17" x2="12.01" y2="17" />
                    </svg>
                    <span id="dangerZoneTitleText">Danger Zone</span>
                  </div>
                  <div class="danger-zone-note" id="dangerZoneNote">
                    Storing Admin Token in the browser may allow Control Plane takeover if the device is compromised.
                    Recommended: do not store (use short-lived sessions).
                  </div>
                  <label class="form-toggle danger-row">
                    <input type="checkbox" id="dangerEnableToggle" />
                    <span id="dangerEnableToggleLabel">Store Admin Token in browser (dangerous)</span>
                  </label>
                  <div class="danger-zone-options" id="dangerZoneOptions" style="display:none;">
                    <div class="danger-row">
                      <label class="form-label" for="dangerDuration" id="dangerDurationLabel">Duration</label>
                      <select id="dangerDuration" class="form-select" style="max-width: 240px;">
                        <option value="900">15 min</option>
                        <option value="3600">1 hour</option>
                        <option value="28800">8 hours</option>
                        <option value="session">Until browser closes</option>
                      </select>
                    </div>
                    <div class="danger-row">
                      <label class="form-toggle">
                        <input type="checkbox" id="dangerPersistentToggle" />
                        <span id="dangerPersistentLabel">Persist after browser restart (localStorage)</span>
                      </label>
                      <label class="form-toggle" id="dangerConsentWrap" style="display:none;">
                        <input type="checkbox" id="dangerConsentToggle" />
                        <span id="dangerConsentLabel">I understand the risks</span>
                      </label>
                    </div>
                    <div class="danger-row">
                      <button type="button" class="btn btn-danger" id="dangerApplyBtn">Enable</button>
                      <button type="button" class="btn btn-secondary" id="dangerDisableBtn">Disable</button>
                      <span class="danger-status" id="dangerStatus"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="form-group">
                <label class="form-label" for="upstreamBaseUrl" id="upstreamBaseUrlLabel">OpenAI-compatible Base
                  URL</label>
                <input type="url" id="upstreamBaseUrl" class="form-input" placeholder="https://upstream.example.com"
                  autocomplete="off" data-testid="upstream-base-url" />
                <p class="form-hint" id="upstreamBaseUrlHint">Set <code>MCP_GATEWAY_UPSTREAM_BASE_URL</code> for the
                  gateway.</p>
              </div>
	              <div class="form-group">
	                <label class="form-label" for="upstreamApiKey" id="upstreamApiKeyLabel">API Key</label>
	                <input type="password" id="upstreamApiKey" class="form-input" placeholder="Paste upstream API key"
	                  autocomplete="off" data-testid="upstream-api-key" />
	                <p class="form-hint" id="upstreamApiKeyHint">Paste once (not re-displayed).</p>
	              </div>
	              <div class="form-group">
	                <label class="form-label" for="upstreamModels" id="upstreamModelsLabel">Proxy Model IDs
	                  (allowlist)</label>
	                <input type="text" id="upstreamModels" class="form-input"
	                  placeholder="e.g., gpt-4o-mini,models/gemini-flash-latest,qwen2:0.5b" data-testid="upstream-models" />
	                <p class="form-hint" id="upstreamModelsHint">Primary first, fallback second. Requests must match this
	                  list.</p>
	              </div>
		              <div class="form-group">
		                <label class="form-label" for="upstreamProvider" id="upstreamProviderLabel">Provider</label>
		                <select id="upstreamProvider" class="form-select" data-testid="upstream-provider">
		                  <option value="openai_compatible" selected>OpenAI-compatible (Custom)</option>
		                  <option value="openai">OpenAI (api.openai.com)</option>
		                  <option value="gemini_openai">Gemini (AI Studio via OpenAI-compatible)</option>
		                  <option value="vertex">Vertex AI (OpenAI-compatible)</option>
		                  <option value="anthropic_openai">Anthropic (via OpenAI-compatible proxy)</option>
		                  <option value="ollama">Ollama (local)</option>
		                  <option value="custom">Custom‚Ä¶</option>
		                </select>
		                <details class="provider-hint-details" id="upstreamProviderHintDetails">
		                  <summary class="hint-link" id="upstreamProviderHintSummary">üí° Hint</summary>
		                  <div class="provider-hint-body" id="upstreamProviderHintBody"></div>
		                </details>
		              </div>
		              <div class="form-group" id="upstreamProviderCustomWrap" style="display:none;">
		                <label class="form-label" for="upstreamProviderCustom" id="upstreamProviderCustomLabel">Custom provider</label>
		                <input type="text" id="upstreamProviderCustom" class="form-input" placeholder="e.g., my-proxy"
		                  autocomplete="off" data-testid="upstream-provider-custom" />
	                <p class="form-hint" id="upstreamProviderCustomHint">Used for display/Evidence. Ensure Base URL is OpenAI-compatible.</p>
	              </div>
	              <div class="form-row">
	                <button type="submit" class="btn btn-primary" id="upstreamSaveBtn" data-testid="upstream-save">Save
	                  &amp; Test</button>
	                <span id="upstreamStatus" class="status-indicator inactive" data-testid="upstream-status">Not
	                  tested</span>
	              </div>
	              <div id="upstreamIssueResult" class="wizard-test-result" role="alert"
	                style="display:none; margin-top:12px;">
	                <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
	                <span id="upstreamIssueMessage"></span>
	                <div id="upstreamEvidenceInfo" class="evidence-info" style="display:none; margin-top:8px; font-size:0.85em; color:#666;">
	                  <span class="evidence-label">Evidence ID:</span>
	                  <code id="upstreamEvidenceId" class="evidence-id" data-testid="upstream-evidence-id" style="cursor:pointer; user-select:all;"></code>
	                  <button type="button" class="btn-link" id="upstreamEvidenceCopy" title="Copy to clipboard" style="margin-left:4px; padding:2px 6px; font-size:0.85em;">üìã</button>
	                  <a id="upstreamEvidenceAuditLink" href="#" class="btn-link" title="View in Audit Log" style="margin-left:4px; font-size:0.85em;">üîç Audit Log</a>
	                </div>
	                <div id="upstreamTokenIssueCta" class="token-issue-cta" style="display:none; margin-top:12px; padding:10px 14px; background:#ecfdf5; border:1px solid #86efac; border-radius:8px;" data-testid="upstream-token-issue-cta">
	                  <span style="font-weight:600; color:#166534;" id="tokenIssueCtaLabel">Next: Issue a Gateway Token</span>
	                  <a href="#gateway-wizard" class="btn btn-primary btn-sm" style="margin-left:12px;" id="tokenIssueCtaBtn" data-testid="go-to-token-issue">Issue Token</a>
	                </div>
	                <div class="wizard-test-actions">
	                  <button type="button" class="btn btn-secondary" id="upstreamIssueCta"
	                    style="display:none;"></button>
	                </div>
	              </div>
	            </form>

            <div class="summary-panel" data-testid="upstream-summary">
              <div class="summary-row">
                <span class="summary-label" id="upstreamSummaryStatusLabel">Status</span>
                <span id="upstreamSummaryStatus" class="status-indicator inactive"
                  data-testid="upstream-summary-status">Inactive</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="upstreamSummaryBaseUrlLabel">Base URL</span>
                <span id="upstreamSummaryBaseUrl" class="summary-value summary-mono"
                  data-testid="upstream-summary-base-url">Not set</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="upstreamSummaryProviderLabel">Provider</span>
                <span id="upstreamSummaryProvider" class="summary-value" data-testid="upstream-summary-provider">Not
                  set</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="upstreamSummaryModelsLabel">Models</span>
                <div id="upstreamSummaryModels" class="summary-chips" data-testid="upstream-summary-models"></div>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="upstreamSummaryTestedLabel">Last Tested</span>
                <span id="upstreamSummaryTested" class="summary-value summary-mono"
                  data-testid="upstream-summary-tested">Not tested</span>
              </div>
            </div>

            <div class="info-box">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10" />
                <line x1="12" y1="16" x2="12" y2="12" />
                <line x1="12" y1="8" x2="12.01" y2="8" />
              </svg>
              <div class="info-box-content">
                <strong id="upstreamInfoLabel">Control Plane:</strong> <span id="upstreamInfoText">API keys are stored
                  server-side and never re-displayed. Paste a new key to rotate.</span>
              </div>
            </div>
          </div>

          <div class="card form-card">
            <div class="collapsible-header" data-section="profiles">
              <h3 id="policyProfilesTitle">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 7h16M4 12h16M4 17h16" />
                </svg>
                Policy Profiles
              </h3>
              <div class="collapsible-toggle">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9" />
                </svg>
              </div>
            </div>
            <div class="collapsible-body">
              <form id="policyProfileForm">
                <div class="form-group">
                  <label class="form-label" for="policyProfileSelect" id="policyProfileLabel">Policy Profile</label>
                  <select id="policyProfileSelect" class="form-select" data-testid="policy-profile-select">
                    <option value="standard" id="policyOptionStandard">Standard</option>
                    <option value="strict" id="policyOptionStrict">Strict (extra sink blocks)</option>
                    <option value="development" id="policyOptionDevelopment">Development (allow with approvals)</option>
                  </select>
                  <p class="form-hint" id="policyProfileHint">Core rules are always enforced. Strict adds sampling to
                    restricted sinks.</p>
                </div>
                <div class="form-group">
                  <label class="form-label" for="policyRestrictedSinks" id="policyRestrictedSinksLabel">Additional
                    Restricted Sinks</label>
                  <input type="text" id="policyRestrictedSinks" class="form-input" placeholder="sampling, clipboard"
                    data-testid="policy-restricted-sinks" />
                  <p class="form-hint" id="policyRestrictedSinksHint">Defaults: network_write, file_write, restricted
                    (cannot be removed).</p>
                </div>
                <div class="form-group">
                  <label class="form-toggle" for="policyAllowUntrusted" id="policyAllowUntrustedLabel">
                    <input type="checkbox" id="policyAllowUntrusted" data-testid="policy-allow-untrusted" />
                    Allow untrusted tools with approvals
                  </label>
                  <p class="form-hint" id="policyAllowUntrustedHint">Requires approvals_row_id for untrusted to
                    restricted sinks.</p>
                </div>
                <div class="form-group">
                  <label class="form-label" for="policyChangeReason" id="policyChangeReasonLabel">Change Reason</label>
                  <input type="text" id="policyChangeReason" class="form-input" placeholder="e.g., rollout hardening"
                    data-testid="policy-change-reason" />
                </div>
	                <div class="form-row">
	                  <button type="submit" class="btn btn-primary" data-testid="policy-save" id="policySaveBtn">Save
	                    Profile</button>
	                  <span id="policyStatus" class="status-indicator inactive" data-testid="policy-status">Not
	                    loaded</span>
	                </div>
			                <div id="policyIssueResult" class="wizard-test-result" role="alert" style="display:none; margin-top:12px;">
			                  <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
			                  <span id="policyIssueMessage"></span>
			                  <div class="wizard-test-actions">
			                    <button type="button" class="btn btn-secondary" id="policyIssueCta"
			                      style="display:none;"></button>
			                  </div>
			                </div>
		              </form>

              <div class="summary-panel" data-testid="policy-summary">
                <div class="summary-row">
                  <span class="summary-label" id="policySummarySinksLabel">Effective Restricted Sinks</span>
                  <div id="policySummarySinks" class="summary-chips" data-testid="policy-summary-sinks"></div>
                </div>
                <div class="summary-row">
                  <span class="summary-label" id="policySummaryApprovalsLabel">Untrusted with Approval</span>
                  <span id="policySummaryApprovals" class="summary-value"
                    data-testid="policy-summary-approvals">-</span>
                </div>
                <div class="summary-row">
                  <span class="summary-label" id="policySummaryUpdatedLabel">Last Updated</span>
                  <span id="policySummaryUpdated" class="summary-value summary-mono"
                    data-testid="policy-summary-updated">-</span>
                </div>
              </div>

              <div class="info-box">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10" />
                  <line x1="12" y1="16" x2="12" y2="12" />
                  <line x1="12" y1="8" x2="12.01" y2="8" />
                </svg>
                <div class="info-box-content">
                  <strong id="policyInfoLabel">Admin token required:</strong> <span id="policyInfoText">Uses the Control
                    Plane token from the upstream section.</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card form-card">
          <div class="collapsible-header" data-section="wizard">
            <h3 id="wizardSectionTitle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2l9 4-9 4-9-4 9-4z" />
                <path d="M3 10l9 4 9-4" />
                <path d="M3 16l9 4 9-4" />
              </svg>
              Gateway Connection Wizard
            </h3>
            <div class="collapsible-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9" />
              </svg>
            </div>
          </div>
          <div class="collapsible-body">
            <ol class="wizard-steps">
              <li class="wizard-step"><span class="wizard-index">1</span><span class="wizard-text" id="wizardStep1">Pick
                  the target environment to set the Gateway base URL.</span></li>
              <li class="wizard-step"><span class="wizard-index">2</span><span class="wizard-text"
                  id="wizardStep2">Issue a short-lived access token for client connections.</span></li>
              <li class="wizard-step"><span class="wizard-index">3</span><span class="wizard-text" id="wizardStep3">Copy
                  the client configuration snippet.</span></li>
            </ol>

            <div class="form-group">
              <label class="form-label" for="gatewayEnvironment" id="gatewayEnvironmentLabel">Target Environment</label>
              <select id="gatewayEnvironment" class="form-select" data-testid="gateway-environment"></select>
              <p class="form-hint" id="gatewayEnvironmentHint">Uses the environment endpoint as the OpenAI-compatible
                base URL.</p>
            </div>

            <div class="form-group">
              <label class="form-label" for="gatewayToken" id="gatewayTokenLabel">Gateway Access Token</label>
              <div class="form-row">
                <input type="text" id="gatewayToken" class="form-input" placeholder="Generate to view" readonly
                  data-testid="gateway-token" />
                <button type="button" id="gatewayGenerate" class="btn btn-primary"
                  data-testid="gateway-generate">Generate Token</button>
	              </div>
	              <p class="form-hint" id="gatewayTokenHint">Token is displayed once. Store it securely.</p>
			              <div id="gatewayIssueResult" class="wizard-test-result" role="alert" style="display:none"
			                data-testid="gateway-issue-result">
			                <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
			                <span id="gatewayIssueMessage" data-testid="gateway-issue-message"></span>
			                <div class="wizard-test-actions">
			                  <button type="button" class="btn btn-secondary" id="gatewayIssueCta"
			                    style="display:none;"></button>
			                </div>
			              </div>
		            </div>

            <div class="form-group">
              <label class="form-label" for="gatewayExpiry" id="gatewayExpiryLabel">Token Expiry (UTC)</label>
              <input type="text" id="gatewayExpiry" class="form-input" data-testid="gateway-expiry"
                placeholder="YYYY-MM-DD HH:MM" pattern="\d{4}-\d{2}-\d{2} \d{2}:\d{2}" autocomplete="off" />
              <p class="form-hint" id="gatewayExpiryHint">Recommended: short-lived tokens for clients.</p>
            </div>

            <div class="form-group">
              <label class="form-label" for="gatewayNote" id="gatewayNoteLabel">Usage Note</label>
              <input type="text" id="gatewayNote" class="form-input" placeholder="e.g., IDE pilot team"
                data-testid="gateway-note" />
            </div>

            <div class="form-group">
              <label class="form-label" for="gatewayPreset" id="gatewayPresetLabel">Client Preset</label>
              <select id="gatewayPreset" class="form-select" data-testid="gateway-preset">
                <option value="openai-env" selected id="gatewayPresetOpenai">OpenAI-compatible (env)</option>
                <option value="curl" id="gatewayPresetCurl">cURL smoke</option>
                <option value="json" id="gatewayPresetJson">App config (JSON)</option>
                <option value="python" id="gatewayPresetPython">SDK example (Python)</option>
                <option value="javascript" id="gatewayPresetJs">SDK example (JS)</option>
              </select>
              <p class="form-hint" id="gatewayPresetHint">Choose the configuration snippet for your client.</p>
            </div>

            <div class="form-group">
              <label class="form-label" for="gatewayConfig" id="gatewayConfigLabel">Client Configuration</label>
              <textarea id="gatewayConfig" class="form-textarea" readonly data-testid="gateway-config"></textarea>
            </div>

            <div class="form-row">
              <button type="button" id="gatewayCopy" class="btn btn-secondary" data-testid="gateway-copy">Copy
                Config</button>
              <span id="gatewayCopyStatus" class="copy-status" data-testid="gateway-copy-status">Not copied</span>
            </div>

            <div class="summary-panel" data-testid="gateway-summary">
              <div class="summary-row">
                <span class="summary-label" id="gatewayTargetUrlLabel">Target URL</span>
                <span id="gatewayTargetUrl" class="summary-value summary-mono" data-testid="gateway-target-url">Not
                  set</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="gatewaySummaryExpiryLabel">Expiry</span>
                <span id="gatewaySummaryExpiry" class="summary-value summary-mono"
                  data-testid="gateway-summary-expiry">Not set</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="gatewaySummaryNoteLabel">Usage Note</span>
                <span id="gatewaySummaryNote" class="summary-value" data-testid="gateway-summary-note">Not set</span>
              </div>
              <div class="summary-row">
                <span class="summary-label" id="gatewayIssuedAtLabel">Issued At</span>
                <span id="gatewayIssuedAt" class="summary-value summary-mono" data-testid="gateway-issued-at">Not
                  issued</span>
              </div>
            </div>

            <div class="form-group">
              <label class="form-label" id="issuedTokensTitle">Issued Tokens (selected environment)</label>
              <div class="table-box">
                <table class="token-table" data-testid="gateway-history">
                  <thead>
                    <tr>
                      <th id="issuedColToken">Token</th>
                      <th id="issuedColIssued">Issued</th>
                      <th id="issuedColExpiry">Expiry</th>
                      <th id="issuedColNote">Note</th>
                      <th id="issuedColStatus">Status</th>
                      <th id="issuedColActions">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="gatewayHistoryRows"></tbody>
                </table>
              </div>
              <p class="form-hint" id="issuedTokensHint">Tokens are masked in history; rotate regularly.</p>
            </div>

            <div class="info-box">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10" />
                <line x1="12" y1="16" x2="12" y2="12" />
                <line x1="12" y1="8" x2="12.01" y2="8" />
              </svg>
              <div class="info-box-content">
                <strong id="gatewayInfoLabel">Control Plane:</strong> <span id="gatewayInfoText">Tokens are issued by
                  the gateway and shown once. Store them securely.</span>
              </div>
            </div>
          </div>
        </div>
    </div>
  </div>

  <!-- OAuth2 PAR/DPoP Roadmap Card -->
  <div style="max-width:1280px;margin:24px auto 0;padding:0 24px 24px;">
    <div style="border:2px dashed var(--gray-300);border-radius:8px;padding:24px;background:var(--gray-50);">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:22px;height:22px;color:var(--primary);flex-shrink:0;">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
        </svg>
        <span style="font-size:16px;font-weight:700;" data-i18n="settingsEnv.oauth2Title">OAuth2 PAR + DPoP &mdash; Next-Gen Token Security</span>
        <span style="font-size:10px;padding:2px 8px;border-radius:10px;font-weight:600;background:#dbeafe;color:#1e40af;" data-i18n="settingsEnv.oauth2Planned">Planned</span>
        <span style="font-size:11px;color:var(--gray-600);">Q2-Q4 2026</span>
      </div>

      <!-- Role description -->
      <div style="font-size:13px;color:var(--gray-700);line-height:1.7;margin-bottom:16px;">
        <p style="margin:0 0 10px;" data-i18n="settingsEnv.oauth2Desc">This section will replace the current static Bearer token flow (shown in the Gateway Connection Wizard above) with enterprise-grade OAuth2 security. Instead of long-lived tokens that can be stolen and reused, every client request will carry a cryptographic proof that binds the token to the requesting device.</p>
        <p style="margin:0;font-size:12px;color:var(--gray-600);" data-i18n="settingsEnv.oauth2DescSub">Currently, MCP Gateway issues static tokens via the Connection Wizard. PAR + DPoP upgrades this to a two-layer defense: server-side authorization storage (PAR) and client-bound proof-of-possession (DPoP).</p>
      </div>

      <!-- PAR / DPoP detail cards -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
        <div style="padding:16px;background:#fff;border:1px solid var(--gray-200);border-radius:8px;">
          <div style="font-weight:700;font-size:13px;margin-bottom:8px;color:var(--gray-900);" data-i18n="settingsEnv.oauth2ParTitle" data-i18n-html="true">PAR &mdash; Pushed Authorization Requests (RFC 9126)</div>
          <div style="font-size:12px;color:var(--gray-600);line-height:1.6;" data-i18n="settingsEnv.oauth2Par" data-i18n-html="true">
            Clients send authorization parameters directly to the Gateway's token endpoint via a back-channel POST &mdash; not through URL query strings. The Gateway stores the request server-side and returns a short-lived <code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">request_uri</code>. This eliminates token leakage through browser history, referrer headers, and proxy logs.
          </div>
          <div style="margin-top:10px;padding:10px;background:var(--gray-50);border-radius:6px;font-size:11px;color:var(--gray-600);line-height:1.7;font-family:'SF Mono',Monaco,monospace;">
            Client &rarr; POST /oauth/par {params} &rarr; Gateway<br>
            Gateway &rarr; 201 {request_uri, expires_in} &rarr; Client<br>
            Client &rarr; GET /oauth/authorize?request_uri=... &rarr; Gateway
          </div>
        </div>
        <div style="padding:16px;background:#fff;border:1px solid var(--gray-200);border-radius:8px;">
          <div style="font-weight:700;font-size:13px;margin-bottom:8px;color:var(--gray-900);" data-i18n="settingsEnv.oauth2DpopTitle" data-i18n-html="true">DPoP &mdash; Demonstration of Proof-of-Possession (RFC 9449)</div>
          <div style="font-size:12px;color:var(--gray-600);line-height:1.6;" data-i18n="settingsEnv.oauth2Dpop" data-i18n-html="true">
            Each API request includes a signed JWT proof (<code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">DPoP</code> header) generated with the client's private key. The Gateway verifies the signature, binding the token to the originating device. Even if a token is intercepted, it cannot be replayed from a different machine.
          </div>
          <div style="margin-top:10px;padding:10px;background:var(--gray-50);border-radius:6px;font-size:11px;color:var(--gray-600);line-height:1.7;font-family:'SF Mono',Monaco,monospace;">
            Client &rarr; DPoP: {signed JWT} + Authorization: DPoP &lt;token&gt;<br>
            Gateway &rarr; Verify JWK thumbprint matches token binding<br>
            Gateway &rarr; Reject if proof is missing, expired, or mismatched
          </div>
        </div>
      </div>

      <!-- Combined flow -->
      <div style="margin-top:16px;padding:14px;background:#eff6ff;border:1px solid #bfdbfe;border-radius:8px;">
        <div style="font-weight:600;font-size:12px;color:#1e40af;margin-bottom:6px;" data-i18n="settingsEnv.oauth2CombinedTitle">Combined Flow: PAR + DPoP</div>
        <div style="font-size:11px;color:#1e3a5f;line-height:1.7;" data-i18n="settingsEnv.oauth2CombinedDesc" data-i18n-html="true">
          <strong>1.</strong> Client generates an ephemeral key pair (per device) &rarr;
          <strong>2.</strong> Client pushes auth request via PAR back-channel &rarr;
          <strong>3.</strong> Gateway issues a DPoP-bound access token &rarr;
          <strong>4.</strong> Every API call carries both the token and a fresh DPoP proof &rarr;
          <strong>5.</strong> Gateway validates proof + token binding on each request &rarr; stolen tokens are useless without the private key.
        </div>
      </div>
    </div>
  </div>

  <script src="mock_data.js"></script>
  <script src="settings_mock.js"></script>
  <script src="api_client.js"></script>
  <script>
    // Auto-set active nav link based on current page
    (function () {
      if (!window.location || !window.location.pathname) return; // Skip in test/linkedom env
      const currentFile = window.location.pathname.split('/').pop() || 'settings_environments.html';
      document.querySelectorAll('.nav-link').forEach(link => {
        const href = link.getAttribute('href');
        if (href === currentFile) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });
    })();

    // Language Toggle (page-local; keep api_client.js global setLanguage intact)
    const LANG_KEY = 'suite_language';
    function setPageLanguage(lang) {
      const next = lang === 'en' ? 'en' : 'ja';
      const storage = getStorage();
      if (storage) storage.setItem(LANG_KEY, next);
      window.suite_language = next;
      document.documentElement.lang = next;
      // Update button states
      const langJa = document.getElementById('langJa');
      const langEn = document.getElementById('langEn');
      if (langJa && langEn) {
        langJa.classList.toggle('active', next === 'ja');
        langEn.classList.toggle('active', next === 'en');
      }
      // Sync common i18n (admin session banner, danger banner, etc.)
      if (typeof window.setLanguage === 'function') {
        try { window.setLanguage(next); } catch (e) { }
      }
    }
    function getPageLanguage() {
      const storage = getStorage();
      return (
        window.suite_language ||
        (storage ? storage.getItem(LANG_KEY) : null) ||
        'en'
      );
    }
    function getStorage() {
      try { return window.localStorage; } catch (e) { return null; }
    }

    // i18n dictionary and applier (covers visible labels and statuses)
    const I18N = {
      en: {
        pageTitle: 'Environments',
        pageSubtitle: 'Manage MCP Gateway environments and endpoints',
        diagnosticsTitle: 'System Diagnostics',
        diagnosticsHint: 'One-click check: upstream validity, tokens, and policy bundle status.',
        diagnosticsRunBtn: 'Run Diagnostics',
        diagnosticsRunning: 'Running...',
        diagnosticsCopyBtn: 'Copy JSON',
        diagnosticsDownloadBtn: 'Download JSON',
        diagnosticsAdvancedHint: 'Operator/QA: Export JSON only when needed (incident/support).',
	        diagnosticsErrorAuth: 'Admin session required. Paste Admin Token and start session first.',
	        diagnosticsErrorGateway: 'Gateway unreachable. Start the gateway or open the wizard to configure it, then reload.',
	        diagnosticsErrorUnavailable: 'Diagnostics API is unavailable on this gateway build. Update the gateway or open the wizard to continue setup.',
        diagnosticsSummaryOk: 'All checks passed',
        diagnosticsSummaryWarn: 'Some checks need attention',
        diagnosticsSummaryBad: 'Action required',
        diagnosticsResultLabel: 'Result',
        diagnosticsUpdatedLabel: 'Updated',
        diagnosticsUpstream: 'Upstream',
        diagnosticsTokens: 'Tokens',
        diagnosticsPolicyBundle: 'Policy bundle',
        diagnosticsShadowAudit: 'Shadow Audit chain',
        diagnosticsCopyDone: 'Copied',
        diagnosticsDownloadDone: 'Downloaded',
        diagnosticsPresent: 'Present',
        diagnosticsMissing: 'Missing',
        diagnosticsVerified: 'Verified',
	        diagnosticsNotVerified: 'Not verified',
	        diagnosticsInvalid: 'Invalid',
	        diagnosticsNA: 'N/A',
	        ctaOpenWizard: 'Open Setup Wizard',
	        ctaGoToAdminSession: 'Go to Admin Session',
	        ctaGoToEnvironments: 'Go to Environments',
	        ctaRunDiagnostics: 'Run Diagnostics',
	        ctaOpenAutostart: 'Open Autostart Setup',
	        langLabel: 'Language:',
	        guideTitle: 'Initial setup guide',
        guideStep1: 'Paste the Admin Token once to start an admin session, then save upstream (LLM) and run Save & Test.',
        guideStep2: 'Check Proxy Model IDs and add if needed',
        guideStep3: 'Pick a Policy Profile and add Restricted Sinks if required',
        guideStep4: 'Register targets in the Environments table',
        intro: {
          title: 'Initial setup guide',
          step1: 'Paste the Admin Token once to start an admin session, then save upstream (LLM) and run Save & Test.',
          step2: 'Check Proxy Model IDs and add if needed',
          step3: 'Pick a Policy Profile and add Restricted Sinks if required',
          step4: 'Register targets in the Environments table'
        },
        onboarding: {
          title: 'Getting Started Guide',
          subtitle: 'MCP Gateway is an LLM hub. Clients use only the Gateway URL and token; upstream API keys stay in the Gateway. Routing and policy are centralized here.',
          badge: 'Initial Setup',
          step1: 'Paste the Admin Token once to start an admin session.',
          step2: 'Save the upstream LLM Base URL and API Key, then run Save & Test.',
          step3: 'Issue a Gateway access token in the Connection Wizard and paste the config into your client.',
          linkEnv: 'Go to Environments',
          linkDashboard: 'View Dashboard',
          linkAudit: 'View Audit Log',
          note: 'Tip: Switching upstream does not require changing the client URL or token.',
          toggleShow: 'Show guide',
          toggleHide: 'Hide guide'
        },
        addEnvTitle: 'New Environment',
        envTableTitle: 'Registered Environments',
        envColName: 'Name',
        envColEndpoint: 'Endpoint',
        envColStatus: 'Status',
        envColNote: 'Note',
        envNameLabel: 'Environment Name',
        envNameHint: 'A unique identifier for this environment',
        envNamePlaceholder: 'e.g., gateway-staging',
        envEndpointLabel: 'Endpoint URL',
        envEndpointHint: 'The base URL for the MCP Gateway API',
        envEndpointPlaceholder: 'https://gateway.example.com/api',
	        envNoteLabel: 'Note (Optional)',
	        envNotePlaceholder: 'Purpose or description',
	        envSaveBtn: 'Add Environment',
	        envIssueNameRequired: 'Environment name is required.',
	        envIssueEndpointRequired: 'Endpoint URL is required.',
	        envIssueSaving: 'Saving environment...',
	        envIssueSaved: 'Environment saved.',
	        envIssueSaveFailed: 'Failed to save environment.',
	        settingsApiLabel: 'Settings API:',
	        settingsApiText: 'Environments are saved to the gateway registry. Secrets are never returned.',
        upstreamTitle: 'Upstream LLM',
        adminTokenLabel: 'Admin Session',
        adminTokenPlaceholder: 'Paste Admin Token to start session',
        adminSessionStartBtn: 'Start Session',
        adminSessionTokenRequired: 'Paste Admin Token to start session',
        adminSessionUnavailable: 'Session API is unavailable',
        adminSessionStarting: 'Starting session...',
	        adminSessionInvalidToken: 'Invalid Admin Token',
	        adminSessionFailed: 'Failed to start admin session',
	        adminSessionEstablished: 'Admin session established',
	        adminSessionRequired: 'Admin session required',
	        adminSessionBannerDetail: 'Admin session required. Paste Admin Token and click Start Session.',
	        adminSessionHint: 'Paste once and click Start Session (not stored).',
	        dangerZoneTitleText: 'Danger Zone',
	        dangerZoneNote: 'Storing the Admin Token in the browser may allow an attacker to take over control plane operations if the workstation is compromised. Recommended: do not store it.',
	        dangerEnableToggleLabel: 'Store Admin Token in the browser (dangerous)',
        dangerDurationLabel: 'Allowed duration',
        dangerDuration15m: '15 minutes',
        dangerDuration1h: '1 hour',
        dangerDuration8h: '8 hours',
        dangerDurationSession: 'Until browser closes',
        dangerPersistentLabel: 'Persist across restarts (localStorage)',
        dangerConsentLabel: 'I understand the risks',
        dangerApplyBtn: 'Enable',
        dangerDisableBtn: 'Disable',
        dangerConsentRequired: 'Please confirm the risk to persist in localStorage',
        dangerEnabling: 'Enabling...',
        dangerEnabled: 'Danger Mode enabled',
        dangerEnableFailed: 'Failed to enable Danger Mode',
        dangerDisabled: 'Danger Mode disabled',
        upstreamBaseUrlLabel: 'OpenAI-compatible Base URL',
        upstreamBaseUrlHint: 'Set MCP_GATEWAY_UPSTREAM_BASE_URL for the gateway.',
        upstreamBaseUrlPlaceholder: 'https://upstream.example.com',
        upstreamApiKeyLabel: 'API Key',
        upstreamApiKeyHint: 'Paste once (not re-displayed).',
        upstreamApiKeyHintSaved: 'API key saved. Paste a new key to rotate.',
        upstreamApiKeyPlaceholder: 'Paste upstream API key',
        upstreamApiKeyPlaceholderSaved: 'Saved (******)',
        upstreamModelsLabel: 'Proxy Model IDs (allowlist)',
        upstreamModelsHint: 'Primary first, fallback second. Requests must match this list.',
        upstreamModelsPlaceholder: 'e.g., gpt-4o-mini,models/gemini-flash-latest,qwen2:0.5b',
        upstreamProviderLabel: 'Provider',
        upstreamProviderOpenAICompatible: 'OpenAI-compatible (Custom)',
        upstreamProviderOpenAI: 'OpenAI (api.openai.com)',
        upstreamProviderGemini: 'Gemini (AI Studio via OpenAI-compatible)',
        upstreamProviderVertex: 'Vertex AI (OpenAI-compatible)',
        upstreamProviderAnthropic: 'Anthropic (via OpenAI-compatible proxy)',
        upstreamProviderOllama: 'Ollama (local)',
        upstreamProviderCustom: 'Custom‚Ä¶',
	        upstreamProviderCustomLabel: 'Custom provider',
	        upstreamProviderCustomHint: 'Used for display/Evidence. Ensure Base URL is OpenAI-compatible.',
	        upstreamProviderCustomPlaceholder: 'e.g., my-proxy',
	        upstreamProviderHintSummary: 'üí° Hint',
	        upstreamProviderHintIntro: 'The Gateway calls the upstream via an OpenAI-compatible API.',
	        upstreamProviderHintDefaults: 'Defaults (editable):',
	        upstreamProviderHintApiKeyRequired: 'API key is usually required (stored on the gateway).',
	        upstreamProviderHintApiKeyOptional: 'API key not required (local).',
	        upstreamProviderHintBodyOpenAICompatible: 'Use your own OpenAI-compatible proxy (e.g., LiteLLM).',
	        upstreamProviderHintBodyOpenAI: 'OpenAI official endpoint.',
	        upstreamProviderHintBodyGemini: 'Gemini AI Studio OpenAI-compatible endpoint (model IDs often start with models/).',
	        upstreamProviderHintBodyVertex: 'Vertex AI via OpenAI-compatible endpoint (org/project-specific).',
		        upstreamProviderHintBodyAnthropic: 'Claude via an OpenAI-compatible proxy (e.g., LiteLLM).',
		        upstreamProviderHintBodyOllama: 'Local Ollama (run ollama serve; model names come from ollama list).',
		        upstreamProviderHintBodyCustom: 'Custom provider name is only for display/Evidence (Base URL is what the Gateway calls).',
		        upstreamTestSuccess: 'Upstream connection successful.',
		        upstreamTestFailed: 'Upstream test failed.',
		        upstreamTestHintOffline: 'Verify Base URL and that the upstream is running.',
		        upstreamTestHintAuth: 'Verify API key and provider.',
		        upstreamTestHintNotFound: 'Verify Base URL (OpenAI-compatible endpoint).',
		        upstreamTestHintNotFoundOllama: 'For Ollama: use http://127.0.0.1:11434 (or /v1), and check `ollama serve` / `ollama list`.',
		        upstreamTestHintRateLimit: 'Rate limited. Try again later or reduce request rate.',
		        upstreamTestHintServer: 'Upstream returned an error. Check upstream logs and retry.',
		        upstreamTestHintGeneric: 'Check Base URL and model settings.',
		        upstreamSaveBtn: 'Save & Test',
		        upstreamSummaryStatusLabel: 'Status',
	        upstreamSummaryBaseUrlLabel: 'Base URL',
	        upstreamSummaryProviderLabel: 'Provider',
        upstreamSummaryModelsLabel: 'Models',
        upstreamSummaryTestedLabel: 'Last Tested',
        upstreamInfoLabel: 'Control Plane:',
        upstreamInfoText: 'API keys are stored server-side and never re-displayed. Paste a new key to rotate.',
        policyProfilesTitle: 'Policy Profiles',
        policyProfileLabel: 'Policy Profile',
        policyProfileHint: 'Core rules are always enforced. Strict adds sampling to restricted sinks.',
        policyOptionStandard: 'Standard',
        policyOptionStrict: 'Strict (extra sink blocks)',
        policyOptionDevelopment: 'Development (allow with approvals)',
        policyRestrictedSinksLabel: 'Additional Restricted Sinks',
        policyRestrictedSinksHint: 'Defaults: network_write, file_write, restricted (cannot be removed).',
        policyRestrictedSinksPlaceholder: 'sampling, clipboard',
        policyAllowUntrustedLabel: 'Allow untrusted tools with approvals',
	        policyAllowUntrustedHint: 'Requires approvals_row_id for untrusted to restricted sinks.',
	        policyChangeReasonLabel: 'Change Reason',
	        policyChangeReasonPlaceholder: 'e.g., rollout hardening',
	        policySaveBtn: 'Save Profile',
	        policyIssueProfilePreset: 'Profile preset applied. Review and click Save Profile to apply.',
	        policyIssueAdminDetail: 'Admin session required. Paste Admin Token and click Start Session.',
	        policyIssueSaving: 'Saving policy profile...',
	        policyIssueSaved: 'Policy profile saved.',
	        policyIssueSaveFailed: 'Failed to save policy profile.',
	        policyIssueGatewayOffline: 'Gateway is unreachable. Start the gateway and reload this page.',
	        policyIssueApiMissing: 'Policy profile API is unavailable. Update the gateway and try again.',
	        policyIssueInvalidInput: 'Invalid input. Review Restricted Sinks and try again.',
	        policyIssueServerError: 'Gateway returned an error while saving the policy profile. Verify gateway configuration (Admin Token / policy bundle), then check the gateway console logs (PowerShell/WSL) and the Audit Log page, then retry.',
	        policySummarySinksLabel: 'Effective Restricted Sinks',
	        policySummaryApprovalsLabel: 'Untrusted with Approval',
        policySummaryUpdatedLabel: 'Last Updated',
        policySummaryApprovalsEnabled: 'Enabled',
        policySummaryApprovalsDisabled: 'Disabled',
        policyInfoLabel: 'Admin session required:',
        policyInfoText: 'Uses the Control Plane admin session from the upstream section.',
        wizardTitle: 'MCP Gateway Setup Wizard',
        wizardSectionTitle: 'Gateway Connection Wizard',
        wizardStep1: 'Pick the target environment to set the Gateway base URL.',
        wizardStep2: 'Issue a short-lived access token for client connections.',
        wizardStep3: 'Copy the client configuration snippet.',
        wizardSubtitle: 'Complete setup in 5 steps.',
        wizardStep1Title: 'Check Gateway prerequisites',
        wizardStep1Desc: 'Confirm admin session and policy bundle before configuring upstream.',
        wizardStep2Title: 'Enter Gemini API Key',
        wizardStep2Desc: 'Paste your Gemini API key to enable AI-powered security features: AI Council, Semantic Scanner, RedTeam, and Causal Web Sandbox.',
        wizardStep3Title: 'Select Gemini Model',
        wizardStep3Desc: 'Choose which Gemini model to use for AI-powered analysis.',
        wizardStep4Title: 'Connection test',
        wizardStep4Desc: 'Run a test to verify the upstream connection.',
        wizardStep5Title: 'Register Gateway URL & issue token',
        wizardStep5Desc: 'Register the Gateway URL and issue a client access token.',
        wizardPrecheckBtn: 'Run diagnostics',
        wizardPrecheckRunning: 'Checking...',
        wizardPrecheckOk: 'Gateway prerequisites are ready.',
        wizardPrecheckFailed: 'Gateway prerequisites required',
        wizardPrecheckPolicyMissing: 'Policy bundle is missing. Configure it before continuing.',
        wizardPrecheckPolicyUnknown: 'Policy bundle status is unknown. Run Diagnostics to confirm.',
        wizardAutostartTitle: 'Autostart setup',
        wizardAutostartDesc: 'For production, install autostart once from the installation directory.',
        wizardAutostartWindowsLabel: 'Windows (Task Scheduler)',
        wizardAutostartMacLabel: 'macOS (LaunchAgent)',
        wizardAutostartLinuxLabel: 'Linux (systemd --user)',
        wizardAutostartNote: 'After installation, the Gateway starts automatically and UI is ready.',
        wizardAutostartDocHint: 'Docs: see the Admin Guide in your installation package.',
        wizardAutostartDockerHint: 'Starts Gateway + UI via Docker Compose (same origin).',
        wizardTokenSetupTitle: 'Set Admin Token before starting the Gateway',
        wizardTokenSetupStep1: 'Export `MCP_GATEWAY_ADMIN_TOKEN="<token>"` in the shell you use to run the Gateway.',
        wizardTokenSetupStep2: 'Run `./scripts/step8_start_suite.sh` (or your installer‚Äôs autostart script) with that token.',
        wizardTokenSetupStep3: 'Click ‚ÄúStart Session‚Äù to establish the admin session before proceeding.',
        wizardTokenSetupHint: 'If autostart is configured, restart the gateway. See the admin guide inside your installer for details.',
        wizardTokenFormLabel: 'Admin Token',
        wizardTokenCopyBtn: 'Copy command',
        wizardTokenHelp: 'Copy the command below and run in the same shell that starts the gateway.',
        wizardTokenStartBtn: 'Start Session',
        wizardTokenSetupTitle: 'Set Admin Token before starting the Gateway',
        wizardTokenSetupStep1: 'Export `MCP_GATEWAY_ADMIN_TOKEN="<token>"` in the shell you use to run the Gateway.',
        wizardTokenSetupStep2: 'Run `./scripts/step8_start_suite.sh` (or your installer‚Äôs autostart script) with that token.',
        wizardTokenSetupStep3: 'Click ‚ÄúStart Session‚Äù to establish the admin session before proceeding.',
        wizardTokenSetupHint: 'If autostart is configured, restart the gateway. See the admin guide inside your installer for details.',
        wizardTokenSetupTitle: 'Set Admin Token before starting the Gateway',
        wizardTokenSetupStep1: 'Export `MCP_GATEWAY_ADMIN_TOKEN="<token>"` in the shell you use to run the Gateway.',
        wizardTokenSetupStep2: 'Run `./scripts/step8_start_suite.sh` (or your installer‚Äôs autostart script) with that token.',
        wizardTokenSetupStep3: 'Click ‚ÄúStart Session‚Äù to establish the admin session before proceeding.',
        wizardTokenSetupHint: 'If autostart is configured, restart the gateway. See the admin guide inside your installer for details.',
        wizardGatewayModeLabel: 'Mode',
        wizardGatewayModeAuto: 'Auto',
        wizardGatewayModeManual: 'Manual',
        wizardGatewayAutoHint: 'Auto uses the current URL as the Gateway. Switch to manual to edit.',
        wizardGatewayEnvNameLabel: 'Environment Name',
        wizardGatewayEnvNameHint: 'Used as the identifier for token issuance.',
        wizardGatewayEnvNamePlaceholder: 'gateway-local',
        wizardGatewayBaseUrlLabel: 'Gateway Base URL',
        wizardGatewayBaseUrlHint: 'Enter the OpenAI-compatible base URL.',
        wizardGatewayBaseUrlPlaceholder: 'https://gateway.example.com',
	        wizardGatewayIssueBtn: 'Create environment & issue token',
	        wizardGatewayIssueInProgress: 'Issuing...',
	        wizardGatewayEnvRequired: 'Environment name is required.',
	        wizardGatewayBaseRequired: 'Gateway URL is required.',
	        wizardGatewayIssueFailed: 'Failed to issue token.',
	        wizardGatewayIssueSuccess: 'Token issued. Copy the config below.',
	        wizardGatewayEnvSaveFailed: 'Failed to save environment.',
	        wizardGatewayApiUnavailable: 'API client is unavailable.',
	        wizardConnectionFailed: 'Connection failed',
	        wizardModelRequired: 'Model is required.',
	        wizardUpstreamSaveFailed: 'Failed to save upstream settings.',
	        wizardUpstreamSaveInvalidInput: 'Invalid input. Check Provider / Base URL / Model ID.',
	        wizardUpstreamSaveApiMissing: 'Upstream settings API is unavailable. Update the gateway and try again.',
	        wizardUpstreamSaveServerError: 'Gateway returned an error while saving upstream settings. Verify gateway configuration (Admin Token / policy bundle), then check the gateway console logs (PowerShell/WSL) and the Audit Log page, then retry.',
	        wizardGatewayAdminRequired: 'Admin session required. Paste Admin Token and start session first.',
	        wizardGatewayAdminTokenNotConfigured: 'Gateway started without an admin token. Restart the Gateway with MCP_GATEWAY_ADMIN_TOKEN (recommended: use the Step8 start script), establish an admin session, then retry.',
	        wizardAdminTokenHint: 'Paste the same Admin Token (not stored). If you really need it stored, enable it in the Danger Zone with explicit consent.',
	        gatewayEnvironmentLabel: 'Target Environment',
	        gatewayEnvironmentHint: 'Uses the environment endpoint as the OpenAI-compatible base URL.',
	        gatewayTokenLabel: 'Gateway Access Token',
        gatewayTokenHint: 'Token is displayed once. Store it securely.',
        gatewayTokenPlaceholder: 'Generate to view',
        gatewayGenerateBtn: 'Generate Token',
        gatewayExpiryLabel: 'Token Expiry (UTC)',
        gatewayExpiryHint: 'Recommended: short-lived tokens for clients.',
        gatewayNoteLabel: 'Usage Note',
        gatewayNotePlaceholder: 'e.g., IDE pilot team',
        gatewayPresetLabel: 'Client Preset',
        gatewayPresetHint: 'Choose the configuration snippet for your client.',
        gatewayPresetOpenai: 'OpenAI-compatible (env)',
        gatewayPresetCurl: 'cURL smoke',
        gatewayPresetJson: 'App config (JSON)',
        gatewayPresetPython: 'SDK example (Python)',
        gatewayPresetJs: 'SDK example (JS)',
        gatewayConfigLabel: 'Client Configuration',
        gatewayCopyBtn: 'Copy Config',
        gatewayCopyStatusNotCopied: 'Not copied',
        gatewayTargetUrlLabel: 'Target URL',
        gatewaySummaryExpiryLabel: 'Expiry',
        gatewaySummaryNoteLabel: 'Usage Note',
        gatewayIssuedAtLabel: 'Issued At',
        issuedColToken: 'Token',
        issuedColIssued: 'Issued',
        issuedColExpiry: 'Expiry',
        issuedColNote: 'Note',
        issuedColStatus: 'Status',
        issuedColActions: 'Actions',
        tokenRevokeBtn: 'Revoke',
        tokenRevokeConfirm: 'Are you sure you want to revoke this token? This action cannot be undone.',
        tokenRevoking: 'Revoking...',
        tokenRevokeFailed: 'Failed to revoke token. Please try again.',
        tokenIssueCtaLabel: 'Next: Issue a Gateway Token',
        tokenIssueCtaBtn: 'Issue Token',
        gatewayInfoLabel: 'Control Plane:',
        gatewayInfoText: 'Tokens are issued by the gateway and shown once. Store them securely.',
        issuedTokensTitle: 'Issued Tokens (selected environment)',
        issuedTokensHint: 'Tokens are masked in history; rotate regularly.',
        introGuideToggleHide: 'Hide guide',
        introGuideToggleShow: 'Show guide',
        introGuideReset: 'Initial setup',
        statusActive: 'Active',
        statusError: 'Error',
        statusTesting: 'Testing',
        statusExpired: 'Expired',
        statusRevoked: 'Revoked',
        statusInactive: 'Inactive',
        statusNotTested: 'Not tested',
        notSet: 'Not set',
        notIssued: 'Not issued',
        hiddenToken: 'hidden',
        adminTokenRequired: 'Admin token required',
        loadFailed: 'Load failed',
	        baseUrlRequired: 'Base URL required',
	        apiKeyRequired: 'API key required',
	        providerRequired: 'Provider required',
        saving: 'Saving...',
        saveFailed: 'Save failed',
        testing: 'Testing...',
        saved: 'Saved',
        loaded: 'Loaded',
        noEnvironments: 'No environments',
	        gatewayHistoryNone: 'No tokens issued',
	        gatewayHistoryAdminRequired: 'Admin session required',
	        copyStatusSelectEnv: 'Select environment',
	        gatewayIssueEnvMissing: "No environments yet. Add one above, then issue a token.",
	        gatewayIssueAdminDetail: 'Admin session required. Paste Admin Token and click Start Session.',
	        gatewayIssueGatewayOffline: 'Gateway is unreachable. Start the gateway and reload this page.',
	        gatewayIssueApiMissing: 'Token issuance API is unavailable. Update the gateway and try again.',
	        gatewayIssueInvalidInput: 'Invalid input. Check expiry and try again.',
	        gatewayIssueServerError: 'Gateway returned an error while issuing the token. Verify gateway configuration (Admin Token / policy bundle), then check the gateway console logs (PowerShell/WSL) and the Audit Log page, then retry.',
	        copyStatusAdminRequired: 'Admin session required',
	        copyStatusIssuing: 'Issuing...',
	        copyStatusIssueFailed: 'Issue failed',
	        copyStatusIssued: 'Token issued',
        copyStatusCopied: 'Copied',
        copyStatusCopyFailed: 'Copy failed',
        providerOpenAICompatible: 'OpenAI-compatible',
        providerOpenAI: 'OpenAI',
        providerGemini: 'Gemini',
        providerVertex: 'Vertex AI',
        providerAnthropic: 'Anthropic',
        providerOllama: 'Ollama',
        policyStatusNotLoaded: 'Not loaded',
        settingsEnv: {
          oauth2Title: 'OAuth2 PAR + DPoP \u2014 Next-Gen Token Security',
          oauth2Planned: 'Planned',
          oauth2Desc: 'This section will replace the current static Bearer token flow (shown in the Gateway Connection Wizard above) with enterprise-grade OAuth2 security. Instead of long-lived tokens that can be stolen and reused, every client request will carry a cryptographic proof that binds the token to the requesting device.',
          oauth2DescSub: 'Currently, MCP Gateway issues static tokens via the Connection Wizard. PAR + DPoP upgrades this to a two-layer defense: server-side authorization storage (PAR) and client-bound proof-of-possession (DPoP).',
          oauth2ParTitle: 'PAR \u2014 Pushed Authorization Requests (RFC 9126)',
          oauth2Par: 'Clients send authorization parameters directly to the Gateway\u2019s token endpoint via a back-channel POST \u2014 not through URL query strings. The Gateway stores the request server-side and returns a short-lived <code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">request_uri</code>. This eliminates token leakage through browser history, referrer headers, and proxy logs.',
          oauth2DpopTitle: 'DPoP \u2014 Demonstration of Proof-of-Possession (RFC 9449)',
          oauth2Dpop: 'Each API request includes a signed JWT proof (<code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">DPoP</code> header) generated with the client\u2019s private key. The Gateway verifies the signature, binding the token to the originating device. Even if a token is intercepted, it cannot be replayed from a different machine.',
          oauth2CombinedTitle: 'Combined Flow: PAR + DPoP',
          oauth2CombinedDesc: '<strong>1.</strong> Client generates an ephemeral key pair (per device) \u2192 <strong>2.</strong> Client pushes auth request via PAR back-channel \u2192 <strong>3.</strong> Gateway issues a DPoP-bound access token \u2192 <strong>4.</strong> Every API call carries both the token and a fresh DPoP proof \u2192 <strong>5.</strong> Gateway validates proof + token binding on each request \u2192 stolen tokens are useless without the private key.'
        }
      },
      ja: {
        pageTitle: 'Áí∞Â¢ÉË®≠ÂÆö',
        pageSubtitle: 'MCP Gateway „ÅÆÁí∞Â¢É„Å®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÇíÁÆ°ÁêÜ„Åó„Åæ„Åô',
        diagnosticsTitle: '„Ç∑„Çπ„ÉÜ„É†Ë®∫Êñ≠',
        diagnosticsHint: '1„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ¢∫Ë™ç: ‰∏äÊµÅÁñéÈÄö„Éª„Éà„Éº„ÇØ„É≥„Éª„Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´/Áõ£Êüª„ÉÅ„Çß„Éº„É≥„ÄÇ',
        diagnosticsRunBtn: 'Ë®∫Êñ≠„ÇíÂÆüË°å',
        diagnosticsRunning: 'Ë®∫Êñ≠‰∏≠...',
        diagnosticsCopyBtn: 'JSON„Çí„Ç≥„Éî„Éº',
        diagnosticsDownloadBtn: 'JSON„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
        diagnosticsAdvancedHint: 'ÈÅãÁî®/QAÂêë„Åë: ÂøÖË¶Å„Å™„Å®„Åç„Å†„ÅëJSON„Çí„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºàÈöúÂÆ≥/„Çµ„Éù„Éº„ÉàÔºâ„ÄÇ',
	        diagnosticsErrorAuth: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇAdmin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        diagnosticsErrorGateway: 'Gateway „Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇËµ∑Âãï„Åô„Çã„Åã„Ç¶„Ç£„Ç∂„Éº„Éâ„ÅßË®≠ÂÆö„Åó„ÄÅÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        diagnosticsErrorUnavailable: '„Åì„ÅÆ Gateway „Åß„ÅØË®∫Êñ≠API„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇGateway „ÇíÊõ¥Êñ∞„Åô„Çã„Åã„ÄÅ„Ç¶„Ç£„Ç∂„Éº„Éâ„ÅßË®≠ÂÆö„ÇíÈÄ≤„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        diagnosticsSummaryOk: '„Åô„Åπ„Å¶OK',
        diagnosticsSummaryWarn: '‰∏ÄÈÉ®Ë¶ÅÁ¢∫Ë™ç',
        diagnosticsSummaryBad: 'Ë¶ÅÂØæÂøú',
        diagnosticsResultLabel: 'ÁµêÊûú',
        diagnosticsUpdatedLabel: 'Êõ¥Êñ∞',
        diagnosticsUpstream: '‰∏äÊµÅ',
        diagnosticsTokens: '„Éà„Éº„ÇØ„É≥',
        diagnosticsPolicyBundle: '„Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´',
        diagnosticsShadowAudit: 'Áõ£Êüª„ÉÅ„Çß„Éº„É≥ÔºàShadow AuditÔºâ',
        diagnosticsCopyDone: '„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü',
        diagnosticsDownloadDone: '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü',
        diagnosticsPresent: 'Â≠òÂú®',
        diagnosticsMissing: 'Êú™ÈÖçÁΩÆ',
        diagnosticsVerified: 'Ê§úË®ºÊ∏à„Åø',
	        diagnosticsNotVerified: 'Êú™Ê§úË®º',
	        diagnosticsInvalid: 'ÁÑ°Âäπ',
	        diagnosticsNA: 'N/A',
	        ctaOpenWizard: '„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó„ÇíÈñã„Åè',
	        ctaGoToAdminSession: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„Å∏',
	        ctaGoToEnvironments: 'Áí∞Â¢ÉË®≠ÂÆö„Å∏',
	        ctaRunDiagnostics: 'Ë®∫Êñ≠„Å∏',
	        ctaOpenAutostart: 'Ëá™ÂãïËµ∑Âãï„ÅÆË®≠ÂÆö„Å∏',
	        langLabel: 'Ë®ÄË™û:',
	        guideTitle: 'ÂàùÂõû„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÊâãÈ†Ü',
        guideStep1: 'Admin Token „Çí‰∏ÄÂ∫¶Ë≤º„Çä‰ªò„Åë„Å¶ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã„Åó„ÄÅ‰∏äÊµÅ (LLM) „Çí‰øùÂ≠ò„Åó„Å¶ÁñéÈÄö„ÉÜ„Çπ„Éà„Åó„Åæ„Åô„ÄÇ',
        guideStep2: 'Proxy Model IDs „ÇíÁ¢∫Ë™ç„Åó„ÄÅÂøÖË¶Å„Å™„ÇâËøΩË®ò',
        guideStep3: 'Policy Profile „ÇíÈÅ∏Êäû„Åó„ÄÅËøΩÂä†„ÅÆ Restricted Sinks „Åå„ÅÇ„Çå„Å∞Ë®≠ÂÆö',
        guideStep4: 'Environments „ÉÜ„Éº„Éñ„É´„Å´Êé•Á∂öÂÖà„ÇíÁôªÈå≤',
        intro: {
          title: 'ÂàùÂõû„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÊâãÈ†Ü',
          step1: 'Admin Token „Çí‰∏ÄÂ∫¶Ë≤º„Çä‰ªò„Åë„Å¶ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã„Åó„ÄÅ‰∏äÊµÅ (LLM) „Çí‰øùÂ≠ò„Åó„Å¶ÁñéÈÄö„ÉÜ„Çπ„Éà„Åó„Åæ„Åô„ÄÇ',
          step2: 'Proxy Model IDs „ÇíÁ¢∫Ë™ç„Åó„ÄÅÂøÖË¶Å„Å™„ÇâËøΩË®ò',
          step3: 'Policy Profile „ÇíÈÅ∏Êäû„Åó„ÄÅËøΩÂä†„ÅÆ Restricted Sinks „Åå„ÅÇ„Çå„Å∞Ë®≠ÂÆö',
          step4: 'Environments „ÉÜ„Éº„Éñ„É´„Å´Êé•Á∂öÂÖà„ÇíÁôªÈå≤'
        },
        onboarding: {
          title: '„ÅØ„Åò„ÇÅ„Å¶„ÅÆÂ∞éÂÖ•„Ç¨„Ç§„Éâ',
          subtitle: 'MCP Gateway „ÅØ LLM „ÅÆ„Éè„Éñ„Åß„Åô„ÄÇ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅØ Gateway „ÅÆ URL „Å®„Éà„Éº„ÇØ„É≥„Å†„Åë„Çí‰Ωø„ÅÑ„ÄÅ‰∏äÊµÅ LLM „ÅÆ API„Ç≠„Éº„ÅØ Gateway „Å´‰øùÊåÅ„Åï„Çå„Åæ„Åô„ÄÇ„É´„Éº„ÉÜ„Ç£„É≥„Ç∞/„Éù„É™„Ç∑„Éº„ÅØ„Åì„Åì„ÅßÈõÜ‰∏≠ÁÆ°ÁêÜ„Åó„Åæ„Åô„ÄÇ',
          badge: 'ÂàùÂõû„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó',
          step1: 'Admin Token „Çí‰∏ÄÂ∫¶Ë≤º„Çä‰ªò„Åë„Å¶ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ',
          step2: '‰∏äÊµÅ LLM „ÅÆ Base URL „Å® API Key „Çí‰øùÂ≠ò„Åó„ÄÅSave & Test „ÅßÁñéÈÄöÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ',
          step3: 'Gateway Connection Wizard „Åß„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å„Åó„ÄÅË®≠ÂÆö„Çí„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å´Ë≤º„Çä‰ªò„Åë„Åæ„Åô„ÄÇ',
          linkEnv: 'Environments „Å∏',
          linkDashboard: 'Dashboard „ÇíÁ¢∫Ë™ç',
          linkAudit: 'Audit Log „ÇíÁ¢∫Ë™ç',
          note: '„Éí„É≥„Éà: ‰∏äÊµÅ„ÇíÂàá„ÇäÊõø„Åà„Å¶„ÇÇ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÅ¥„ÅØ URL „Å®„Éà„Éº„ÇØ„É≥„ÇíÂ§â„Åà„Åö„Å´‰Ωø„ÅÑÁ∂ö„Åë„Çâ„Çå„Åæ„Åô„ÄÇ',
          toggleShow: 'Â∞éÂÖ•„Ç¨„Ç§„Éâ„ÇíË°®Á§∫',
          toggleHide: 'Â∞éÂÖ•„Ç¨„Ç§„Éâ„ÇíÈö†„Åô'
        },
        addEnvTitle: 'Êñ∞„Åó„ÅÑÁí∞Â¢É',
        envTableTitle: 'ÁôªÈå≤Ê∏à„ÅøÁí∞Â¢É',
        envColName: 'ÂêçÂâç',
        envColEndpoint: '„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà',
        envColStatus: '„Çπ„ÉÜ„Éº„Çø„Çπ',
        envColNote: '„É°„É¢',
        envNameLabel: 'Áí∞Â¢ÉÂêç',
        envNameHint: '„Åì„ÅÆÁí∞Â¢É„ÅÆ‰∏ÄÊÑè„Å™Ë≠òÂà•Â≠ê',
        envNamePlaceholder: '‰æã: gateway-staging',
        envEndpointLabel: '„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà URL',
	        envEndpointHint: 'MCP Gateway API „ÅÆ„Éô„Éº„ÇπURL',
	        envEndpointPlaceholder: 'https://gateway.example.com/api',
	        envNoteLabel: '„É°„É¢Ôºà‰ªªÊÑèÔºâ',
	        envNotePlaceholder: 'Áî®ÈÄî„ÇÑË™¨Êòé',
	        envSaveBtn: 'Áí∞Â¢É„ÇíËøΩÂä†',
	        envIssueNameRequired: 'Áí∞Â¢ÉÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        envIssueEndpointRequired: '„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàURL„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        envIssueSaving: 'Áí∞Â¢É„Çí‰øùÂ≠ò‰∏≠...',
	        envIssueSaved: 'Áí∞Â¢É„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ',
	        envIssueSaveFailed: 'Áí∞Â¢É„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
	        settingsApiLabel: 'Ë®≠ÂÆöAPI:',
	        settingsApiText: 'Áí∞Â¢É„ÅØ„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„ÅÆ„É¨„Ç∏„Çπ„Éà„É™„Å´‰øùÂ≠ò„Åï„Çå„Åæ„Åô„ÄÇÁßòÂØÜÊÉÖÂ†±„ÅØËøî„Åó„Åæ„Åõ„Çì„ÄÇ',
        upstreamTitle: '‰∏äÊµÅ LLM',
        adminTokenLabel: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥',
        adminTokenPlaceholder: 'Admin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã',
        adminSessionStartBtn: '„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã',
        adminSessionTokenRequired: 'Admin Token „ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
        adminSessionUnavailable: '„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßãAPI„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
        adminSessionStarting: '„Çª„ÉÉ„Ç∑„Éß„É≥Á¢∫Á´ã‰∏≠...',
	        adminSessionInvalidToken: 'Admin Token „ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì',
	        adminSessionFailed: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÁ¢∫Á´ã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
	        adminSessionEstablished: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁ¢∫Á´ã„Åó„Åæ„Åó„Åü',
	        adminSessionRequired: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô',
	        adminSessionBannerDetail: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇAdmin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        adminSessionHint: 'Ë≤º„Çä‰ªò„ÅëÂæå„Å´„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà‰øùÂ≠ò„Åï„Çå„Åæ„Åõ„ÇìÔºâ„ÄÇ',
	        dangerZoneTitleText: 'Danger Zone',
	        dangerZoneNote: 'Admin Token „Çí„Éñ„É©„Ç¶„Ç∂„Å´‰øùÂ≠ò„Åô„Çã„Å®„ÄÅÁ´ØÊú´„Åå‰æµÂÆ≥„Åï„Çå„ÅüÂ†¥Âêà„Å´ Control Plane Êìç‰Ωú„Çí‰πó„Å£Âèñ„Çâ„Çå„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÊé®Â•®„ÅØ„Äå‰øùÂ≠ò„Åó„Å™„ÅÑÔºàÁü≠ÂëΩ„Çª„ÉÉ„Ç∑„Éß„É≥Ôºâ„Äç„Åß„Åô„ÄÇ',
	        dangerEnableToggleLabel: '„Éñ„É©„Ç¶„Ç∂„Å´ Admin Token „Çí‰øùÂ≠ò„Åô„ÇãÔºàÂç±Èô∫Ôºâ',
        dangerDurationLabel: 'Ë®±ÂèØÊôÇÈñì',
        dangerDuration15m: '15ÂàÜ',
        dangerDuration1h: '1ÊôÇÈñì',
        dangerDuration8h: '8ÊôÇÈñì',
        dangerDurationSession: '„Éñ„É©„Ç¶„Ç∂„ÇíÈñâ„Åò„Çã„Åæ„Åß',
        dangerPersistentLabel: '„Éñ„É©„Ç¶„Ç∂ÂÜçËµ∑ÂãïÂæå„ÇÇ‰øùÊåÅÔºàlocalStorageÔºâ',
        dangerConsentLabel: '„É™„Çπ„ÇØ„ÇíÁêÜËß£„Åó„Åæ„Åó„Åü',
        dangerApplyBtn: 'ÊúâÂäπÂåñ',
        dangerDisableBtn: 'ÁÑ°ÂäπÂåñ',
        dangerConsentRequired: 'Ê∞∏Á∂ö‰øùÂ≠òÔºàlocalStorageÔºâ„ÇíÊúâÂäπ„Å´„Åô„Çã„Å´„ÅØÂêåÊÑè„ÅåÂøÖË¶Å„Åß„Åô',
        dangerEnabling: 'ÊúâÂäπÂåñ‰∏≠...',
        dangerEnabled: 'Danger Mode „ÇíÊúâÂäπ„Å´„Åó„Åæ„Åó„Åü',
        dangerEnableFailed: 'Danger Mode „ÅÆÊúâÂäπÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        dangerDisabled: 'Danger Mode „ÇíÁÑ°ÂäπÂåñ„Åó„Åæ„Åó„Åü',
        upstreamBaseUrlLabel: 'OpenAI‰∫íÊèõ Base URL',
        upstreamBaseUrlHint: '„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„ÅÆ MCP_GATEWAY_UPSTREAM_BASE_URL „ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ',
        upstreamBaseUrlPlaceholder: 'https://upstream.example.com',
        upstreamApiKeyLabel: 'API„Ç≠„Éº',
        upstreamApiKeyHint: '‰∏ÄÂ∫¶„Å†„ÅëË≤º„Çä‰ªò„ÅëÔºàÂÜçË°®Á§∫„Åï„Çå„Åæ„Åõ„ÇìÔºâ„ÄÇ',
        upstreamApiKeyHintSaved: 'API„Ç≠„Éº„ÅØ‰øùÂ≠òÊ∏à„Åø„Åß„Åô„ÄÇÊõ¥Êñ∞„Åô„ÇãÂ†¥Âêà„ÅØÊñ∞„Åó„ÅÑ„Ç≠„Éº„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        upstreamApiKeyPlaceholder: '‰∏äÊµÅ API „Ç≠„Éº„ÇíË≤º„Çä‰ªò„Åë',
        upstreamApiKeyPlaceholderSaved: '‰øùÂ≠òÊ∏à„Åø (******)',
        upstreamModelsLabel: '„Éó„É≠„Ç≠„Ç∑Ë®±ÂèØ„É¢„Éá„É´IDÔºàAllowlistÔºâ',
        upstreamModelsHint: '‰∏ªË¶Å„ÇíÂÖàÈ†≠„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Çí2Áï™ÁõÆ„ÄÇË¶ÅÊ±Ç„ÅØ„Åì„ÅÆ‰∏ÄË¶ß„Å®‰∏ÄËá¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ',
        upstreamModelsPlaceholder: '‰æã: gpt-4o-mini,models/gemini-flash-latest,qwen2:0.5b',
        upstreamProviderLabel: '„Éó„É≠„Éê„Ç§„ÉÄ',
        upstreamProviderOpenAICompatible: 'OpenAI‰∫íÊèõÔºà„Ç´„Çπ„Çø„É†Ôºâ',
        upstreamProviderOpenAI: 'OpenAIÔºàapi.openai.comÔºâ',
        upstreamProviderGemini: 'GeminiÔºàAI Studio / OpenAI‰∫íÊèõÔºâ',
        upstreamProviderVertex: 'Vertex AIÔºàOpenAI‰∫íÊèõÔºâ',
        upstreamProviderAnthropic: 'AnthropicÔºàOpenAI‰∫íÊèõ„Éó„É≠„Ç≠„Ç∑ÁµåÁî±Ôºâ',
        upstreamProviderOllama: 'OllamaÔºà„É≠„Éº„Ç´„É´Ôºâ',
        upstreamProviderCustom: '„Ç´„Çπ„Çø„É†‚Ä¶',
	        upstreamProviderCustomLabel: '„Ç´„Çπ„Çø„É†„Éó„É≠„Éê„Ç§„ÉÄ',
	        upstreamProviderCustomHint: 'Ë°®Á§∫/EvidenceÁî®„ÅÆË≠òÂà•Â≠ê„Åß„Åô„ÄÇBase URL „ÅØ OpenAI‰∫íÊèõ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        upstreamProviderCustomPlaceholder: '‰æã: my-proxy',
	        upstreamProviderHintSummary: 'üí° Hint',
	        upstreamProviderHintIntro: 'Base URL „ÅØ Gateway „ÅåÂëº„Å≥Âá∫„Åô„ÄåOpenAI‰∫íÊèõAPI„Äç„ÅÆÊé•Á∂öÂÖà„Åß„Åô„ÄÇ',
	        upstreamProviderHintDefaults: '„Éá„Éï„Ç©„É´„ÉàÔºà„ÅÇ„Å®„Åã„ÇâÂ§âÊõ¥„Åß„Åç„Åæ„ÅôÔºâ:',
	        upstreamProviderHintApiKeyRequired: 'API„Ç≠„Éº„ÅåÂøÖË¶Å„Å™„Åì„Å®„ÅåÂ§ö„ÅÑ„Åß„ÅôÔºàGateway„Å´‰øùÂ≠ò„Åï„Çå„ÄÅ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å∏„ÅØÈÖç„Çä„Åæ„Åõ„ÇìÔºâ„ÄÇ',
	        upstreamProviderHintApiKeyOptional: 'API„Ç≠„Éº‰∏çË¶ÅÔºà„É≠„Éº„Ç´„É´Ôºâ„ÄÇ',
	        upstreamProviderHintBodyOpenAICompatible: 'OpenAI‰∫íÊèõ„Éó„É≠„Ç≠„Ç∑Ôºà‰æã: LiteLLMÔºâ„Çí‰Ωø„ÅÜÂ†¥Âêà„Å´ÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ',
	        upstreamProviderHintBodyOpenAI: 'OpenAIÂÖ¨Âºè„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Åß„Åô„ÄÇ',
	        upstreamProviderHintBodyGemini: 'GeminiÔºàAI StudioÔºâ„ÅÆOpenAI‰∫íÊèõ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Åß„ÅôÔºàModel ID„ÅØ models/ „Åã„ÇâÂßã„Åæ„Çã„Åì„Å®„ÅåÂ§ö„ÅÑ„Åß„ÅôÔºâ„ÄÇ',
	        upstreamProviderHintBodyVertex: 'Vertex AI „ÅÆOpenAI‰∫íÊèõ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Åß„ÅôÔºàÁµÑÁπî/„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åî„Å®„Å´Áï∞„Å™„Çä„Åæ„ÅôÔºâ„ÄÇ',
		        upstreamProviderHintBodyAnthropic: 'Claude „Çí OpenAI‰∫íÊèõ„Éó„É≠„Ç≠„Ç∑Ôºà‰æã: LiteLLMÔºâÁµåÁî±„ÅßÂëº„Å∂Â†¥Âêà„Å´ÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ',
		        upstreamProviderHintBodyOllama: '„É≠„Éº„Ç´„É´Ollama„Åß„ÅôÔºàollama serve „ÇíËµ∑Âãï„Åó„ÄÅ„É¢„Éá„É´Âêç„ÅØ ollama list „ÅßÁ¢∫Ë™ç„Åß„Åç„Åæ„ÅôÔºâ„ÄÇ',
		        upstreamProviderHintBodyCustom: '„Ç´„Çπ„Çø„É†Âêç„ÅØË°®Á§∫/EvidenceÁî®„Åß„ÅôÔºàÂÆüÈöõ„Å´Êé•Á∂ö„Åô„ÇãÂÖà„ÅØ Base URL „Åß„ÅôÔºâ„ÄÇ',
		        upstreamTestSuccess: '‰∏äÊµÅ„Å∏„ÅÆÊé•Á∂ö„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü„ÄÇ',
		        upstreamTestFailed: '‰∏äÊµÅ„ÅÆÁñéÈÄö„ÉÜ„Çπ„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
		        upstreamTestHintOffline: 'Base URL „Å®‰∏äÊµÅ„ÅÆËµ∑ÂãïÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintAuth: 'API„Ç≠„Éº„Å®„Éó„É≠„Éê„Ç§„ÉÄË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintNotFound: 'Base URLÔºàOpenAI‰∫íÊèõ„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºâ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintNotFoundOllama: 'Ollama„ÅÆÂ†¥Âêà: http://127.0.0.1:11434Ôºà„Åæ„Åü„ÅØ /v1Ôºâ„ÇíÊåáÂÆö„Åó„ÄÅ`ollama serve` / `ollama list` „ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintRateLimit: '„É¨„Éº„ÉàÂà∂Èôê„Åß„Åô„ÄÇÊôÇÈñì„Çí„Åä„Åè„Åã„É™„ÇØ„Ç®„Çπ„ÉàÈ†ªÂ∫¶„Çí‰∏ã„Åí„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintServer: '‰∏äÊµÅ„Åå„Ç®„É©„Éº„ÇíËøî„Åó„Åæ„Åó„Åü„ÄÇ‰∏äÊµÅ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamTestHintGeneric: 'Base URL „Å®„É¢„Éá„É´Ë®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
		        upstreamSaveBtn: '‰øùÂ≠ò„Åó„Å¶„ÉÜ„Çπ„Éà',
		        upstreamSummaryStatusLabel: '„Çπ„ÉÜ„Éº„Çø„Çπ',
		        upstreamSummaryBaseUrlLabel: 'Base URL',
		        upstreamSummaryProviderLabel: '„Éó„É≠„Éê„Ç§„ÉÄ',
        upstreamSummaryModelsLabel: '„É¢„Éá„É´',
        upstreamSummaryTestedLabel: 'ÊúÄÁµÇ„ÉÜ„Çπ„Éà',
        upstreamInfoLabel: '„Ç≥„É≥„Éà„É≠„Éº„É´„Éó„É¨„Éº„É≥:',
        upstreamInfoText: 'API„Ç≠„Éº„ÅØ„Çµ„Éº„ÉêÂÅ¥„Åß‰øùÂ≠ò„Åï„ÇåÂÜçË°®Á§∫„Åï„Çå„Åæ„Åõ„Çì„ÄÇ„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥ÊôÇ„ÅØÊñ∞„Åó„ÅÑ„Ç≠„Éº„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        policyProfilesTitle: '„Éù„É™„Ç∑„Éº„Éó„É≠„Éï„Ç°„Ç§„É´',
        policyProfileLabel: '„Éù„É™„Ç∑„Éº„Éó„É≠„Éï„Ç°„Ç§„É´',
        policyProfileHint: '„Ç≥„Ç¢„É´„Éº„É´„ÅØÂ∏∏„Å´ÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇStrict „ÅØ Restricted Sinks „Å∏„ÅÆ„Çµ„É≥„Éó„É™„É≥„Ç∞„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ',
        policyOptionStandard: 'Standard',
        policyOptionStrict: 'StrictÔºàËøΩÂä†„Éñ„É≠„ÉÉ„ÇØÔºâ',
        policyOptionDevelopment: 'DevelopmentÔºàÊâøË™ç‰ªò„Åç„ÅßË®±ÂèØÔºâ',
        policyRestrictedSinksLabel: 'ËøΩÂä†„ÅÆ Restricted Sinks',
        policyRestrictedSinksHint: 'Êó¢ÂÆö: network_write, file_write, restrictedÔºàÂâäÈô§‰∏çÂèØÔºâ„ÄÇ',
        policyRestrictedSinksPlaceholder: 'sampling, clipboard',
	        policyAllowUntrustedLabel: 'Êú™‰ø°È†º„ÉÑ„Éº„É´„ÇíÊâøË™ç‰ªò„Åç„ÅßË®±ÂèØ',
	        policyAllowUntrustedHint: 'untrusted -> restricted „Å´„ÅØ approvals_row_id „ÅåÂøÖË¶Å„Åß„Åô„ÄÇ',
	        policyChangeReasonLabel: 'Â§âÊõ¥ÁêÜÁî±',
	        policyChangeReasonPlaceholder: '‰æã: rollout hardening',
	        policySaveBtn: '„Éó„É≠„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò',
	        policyIssueProfilePreset: '„Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„ÇíÂèçÊò†„Åó„Åæ„Åó„Åü„ÄÇÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„ÄÅ„Äå„Éó„É≠„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò„Äç„ÅßÈÅ©Áî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        policyIssueAdminDetail: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇAdmin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        policyIssueSaving: '„Éó„É≠„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò‰∏≠...',
	        policyIssueSaved: '„Éó„É≠„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ',
	        policyIssueSaveFailed: '„Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
	        policyIssueGatewayOffline: 'Gateway „Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇËµ∑Âãï„Åó„Å¶„Åã„ÇâÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        policyIssueApiMissing: 'Policy Profile API „ÇíÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇGateway „ÇíÊõ¥Êñ∞„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        policyIssueInvalidInput: 'ÂÖ•ÂäõÂÄ§„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàRestricted Sinks „Å™„Å©Ôºâ„ÄÇ',
	        policyIssueServerError: 'Gateway „Åå„Ç®„É©„Éº„ÇíËøî„Åó„Åæ„Åó„Åü„ÄÇGateway „ÅÆË®≠ÂÆöÔºàAdmin Token / „Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´Ôºâ„ÇíÁ¢∫Ë™ç„Åó„ÄÅGateway „ÇíËµ∑Âãï„Åó„Åü„Çø„Éº„Éü„Éä„É´ÔºàPowerShell/WSLÔºâ„ÅÆ„É≠„Ç∞„Å® Audit Log „ÇíÁ¢∫Ë™ç„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        policySummarySinksLabel: 'ÊúâÂäπ„Å™ Restricted Sinks',
	        policySummaryApprovalsLabel: 'ÊâøË™ç‰ªò„Åç untrusted',
        policySummaryUpdatedLabel: 'ÊúÄÁµÇÊõ¥Êñ∞',
        policySummaryApprovalsEnabled: 'ÊúâÂäπ',
        policySummaryApprovalsDisabled: 'ÁÑ°Âäπ',
        policyInfoLabel: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å:',
        policyInfoText: '‰∏äÊµÅ„Çª„ÇØ„Ç∑„Éß„É≥„ÅßÁ¢∫Á´ã„Åó„Åü Control Plane „ÅÆÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂà©Áî®„Åó„Åæ„Åô„ÄÇ',
        wizardTitle: 'MCP Gateway „Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó„Ç¶„Ç£„Ç∂„Éº„Éâ',
        wizardSectionTitle: '„Ç≤„Éº„Éà„Ç¶„Çß„Ç§Êé•Á∂ö„Ç¶„Ç£„Ç∂„Éº„Éâ',
        wizardStep1: '„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„ÅÆ Base URL „Å®„Åô„ÇãÁí∞Â¢É„ÇíÈÅ∏Êäû',
        wizardStep2: '„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÊé•Á∂öÁî®„ÅÆÁü≠Êúü„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å',
        wizardStep3: '„ÇØ„É©„Ç§„Ç¢„É≥„ÉàË®≠ÂÆö„Çπ„Éã„Éö„ÉÉ„Éà„Çí„Ç≥„Éî„Éº',
        wizardSubtitle: '5„Çπ„ÉÜ„ÉÉ„Éó„ÅßÁ∞°Âçò„Å´Ë®≠ÂÆö„ÇíÂÆå‰∫Ü„Åß„Åç„Åæ„Åô„ÄÇ',
        wizardStep1Title: 'Gateway„ÅÆÊ∫ñÂÇô„ÇíÁ¢∫Ë™ç',
        wizardStep1Desc: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„Å®„Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åã„ÇâÊ¨°„Å∏ÈÄ≤„Åø„Åæ„Åô„ÄÇ',
        wizardStep2Title: 'Gemini API Key „ÇíÂÖ•Âäõ',
        wizardStep2Desc: 'Gemini API Key „ÇíË≤º„Çä‰ªò„Åë„Å¶„ÄÅAI „Çª„Ç≠„É•„É™„ÉÜ„Ç£Ê©üËÉΩÔºàAI Council, Semantic Scanner, RedTeam, Causal Web SandboxÔºâ„ÇíÊúâÂäπÂåñ„Åó„Åæ„Åô„ÄÇ',
        wizardStep3Title: 'Gemini „É¢„Éá„É´„ÇíÈÅ∏Êäû',
        wizardStep3Desc: 'AI ÂàÜÊûê„Å´‰ΩøÁî®„Åô„Çã Gemini „É¢„Éá„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardStep4Title: 'Êé•Á∂ö„ÉÜ„Çπ„Éà',
        wizardStep4Desc: 'Ë®≠ÂÆö„ÅåÊ≠£„Åó„ÅÑ„ÅãÁ¢∫Ë™ç„Åô„Çã„Åü„ÇÅ„ÄÅÊé•Á∂ö„ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ',
        wizardStep5Title: 'Gateway URL „Å®„Éà„Éº„ÇØ„É≥Áô∫Ë°å',
        wizardStep5Desc: 'Gateway URL „ÇíÁôªÈå≤„Åó„ÄÅ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÁî®„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å„Åó„Åæ„Åô„ÄÇ',
        wizardPrecheckBtn: 'Ë®∫Êñ≠„ÇíÂÆüË°å',
        wizardPrecheckRunning: 'Á¢∫Ë™ç‰∏≠...',
        wizardPrecheckOk: 'Gateway„ÅÆÂâçÊèê„ÉÅ„Çß„ÉÉ„ÇØ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ',
        wizardPrecheckFailed: 'Gateway„ÅÆÊ∫ñÂÇô„ÅåÂøÖË¶Å„Åß„Åô',
        wizardPrecheckPolicyMissing: '„Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´„ÅåÊú™ÈÖçÁΩÆ„Åß„Åô„ÄÇË®≠ÂÆö„Åó„Å¶„Åã„ÇâRetry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardPrecheckPolicyUnknown: '„Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„Åõ„Çì„ÄÇË®∫Êñ≠„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenSetupTitle: 'Gateway „ÇíËµ∑Âãï„Åô„ÇãÂâç„Å´ Admin Token „ÇíË®≠ÂÆö',
        wizardTokenSetupStep1: 'Gateway „ÇíËµ∑Âãï„Åô„Çã„Ç∑„Çß„É´„Åß `MCP_GATEWAY_ADMIN_TOKEN="<token>"` „ÇíÁí∞Â¢ÉÂ§âÊï∞„Å´Ë®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenSetupStep2: '„Åù„ÅÆ„Éà„Éº„ÇØ„É≥„Çí‰Ωø„Å£„Å¶ `./scripts/step8_start_suite.sh` „Åã„Ç§„É≥„Çπ„Éà„Éº„É©„ÅÆËá™ÂãïËµ∑Âãï„Çπ„ÇØ„É™„Éó„Éà„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenSetupStep3: 'Gateway „ÅåËµ∑Âãï„Åó„Åü„Çâ„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÊäº„Åó„Å¶ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁ¢∫Á´ã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenSetupHint: 'Ëá™ÂãïËµ∑Âãï„ÅåË®≠ÂÆöÊ∏à„Åø„Å™„ÇâÂÜçËµ∑Âãï„Å†„Åë„ÅßÊßã„ÅÑ„Åæ„Åõ„Çì„ÄÇË©≥Á¥∞„ÅØ„Ç§„É≥„Çπ„Éà„Éº„É©„Å´ÂêåÊ¢±„Åï„Çå„ÅüÁÆ°ÁêÜËÄÖ„Ç¨„Ç§„Éâ„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenFormLabel: 'Admin Token',
        wizardTokenCopyBtn: '„Ç≥„Éû„É≥„Éâ„Çí„Ç≥„Éî„Éº',
        wizardTokenHelp: '‰∏ã„ÅÆ„Ç≥„Éû„É≥„Éâ„Çí„Ç≥„Éî„Éº„Åó„ÄÅGateway „ÇíËµ∑Âãï„Åô„ÇãÂêå„Åò„Ç∑„Çß„É´„ÅßÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardTokenStartBtn: '„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã',
        wizardAutostartTitle: 'Ëá™ÂãïËµ∑Âãï„ÅÆË®≠ÂÆö',
        wizardAutostartDesc: 'Êú¨Áï™ÈÅãÁî®„ÅØÂ∏∏Èßê„Çµ„Éº„Éì„ÇπÂåñ„ÅåÊúÄ„ÇÇÂÆâÂÖ®„Åß„Åô„ÄÇ„Ç§„É≥„Çπ„Éà„Éº„É´ÂÖà„Åß‰∏ÄÂ∫¶„Å†„ÅëÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardAutostartWindowsLabel: 'WindowsÔºà„Çø„Çπ„ÇØ„Çπ„Ç±„Ç∏„É•„Éº„É©Ôºâ',
        wizardAutostartMacLabel: 'macOSÔºàLaunchAgentÔºâ',
        wizardAutostartLinuxLabel: 'LinuxÔºàsystemd --userÔºâ',
        wizardAutostartNote: 'Ë®≠ÂÆöÂæå„ÅØ„Éñ„É©„Ç¶„Ç∂„ÅßÈñã„Åè„Å†„Åë„ÅßÂà©Áî®„Åß„Åç„Åæ„Åô„ÄÇ',
        wizardAutostartDocHint: 'Ë©≥Á¥∞: ÈÖçÂ∏É„Éë„ÉÉ„Ç±„Éº„Ç∏ÂÜÖ„ÅÆÁÆ°ÁêÜËÄÖ„Ç¨„Ç§„Éâ„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardAutostartDockerHint: 'Docker Compose „Åß Gateway + UI „ÇíÂêå‰∏Ä„Ç™„É™„Ç∏„É≥Ëµ∑Âãï„Åó„Åæ„Åô„ÄÇ',
        wizardGatewayModeLabel: '„É¢„Éº„Éâ',
        wizardGatewayModeAuto: '„Ç™„Éº„Éà',
        wizardGatewayModeManual: 'ÊâãÂãï',
        wizardGatewayAutoHint: '„Ç™„Éº„Éà„ÅØÁèæÂú®„ÅÆ URL „Çí Gateway „Å®„Åó„Å¶‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ',
        wizardGatewayEnvNameLabel: 'Áí∞Â¢ÉÂêç',
        wizardGatewayEnvNameHint: '„Éà„Éº„ÇØ„É≥Áô∫Ë°åÊôÇ„ÅÆË≠òÂà•Âêç„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ',
        wizardGatewayEnvNamePlaceholder: 'gateway-local',
        wizardGatewayBaseUrlLabel: 'Gateway Base URL',
        wizardGatewayBaseUrlHint: 'OpenAI‰∫íÊèõ„ÅÆ Base URL „ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        wizardGatewayBaseUrlPlaceholder: 'https://gateway.example.com',
	        wizardGatewayIssueBtn: 'Áí∞Â¢É„Çí‰ΩúÊàê„Åó„Å¶„Éà„Éº„ÇØ„É≥Áô∫Ë°å',
	        wizardGatewayIssueInProgress: 'Áô∫Ë°å‰∏≠...',
	        wizardGatewayEnvRequired: 'Áí∞Â¢ÉÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardGatewayBaseRequired: 'Gateway URL „ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardGatewayIssueFailed: '„Éà„Éº„ÇØ„É≥Áô∫Ë°å„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
	        wizardGatewayIssueSuccess: '„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å„Åó„Åæ„Åó„Åü„ÄÇË®≠ÂÆö„Çí„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardGatewayEnvSaveFailed: 'Áí∞Â¢É„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
	        wizardGatewayApiUnavailable: 'API„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ',
	        wizardConnectionFailed: 'Êé•Á∂öÂ§±Êïó',
	        wizardModelRequired: '„É¢„Éá„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardUpstreamSaveFailed: '‰∏äÊµÅË®≠ÂÆö„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
	        wizardUpstreamSaveInvalidInput: 'ÂÖ•ÂäõÂÄ§„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà„Éó„É≠„Éê„Ç§„ÉÄ / Base URL / Model IDÔºâ„ÄÇ',
	        wizardUpstreamSaveApiMissing: '‰∏äÊµÅË®≠ÂÆö API „ÇíÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇGateway „ÇíÊõ¥Êñ∞„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardUpstreamSaveServerError: 'Gateway „Åå‰∏äÊµÅË®≠ÂÆö„ÅÆ‰øùÂ≠ò„Åß„Ç®„É©„Éº„ÇíËøî„Åó„Åæ„Åó„Åü„ÄÇGateway „ÅÆË®≠ÂÆöÔºàAdmin Token / „Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´Ôºâ„ÇíÁ¢∫Ë™ç„Åó„ÄÅGateway „ÇíËµ∑Âãï„Åó„Åü„Çø„Éº„Éü„Éä„É´ÔºàPowerShell/WSLÔºâ„ÅÆ„É≠„Ç∞„Å® Audit Log „ÇíÁ¢∫Ë™ç„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardGatewayAdminRequired: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇAdmin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardGatewayAdminTokenNotConfigured: 'Gateway „ÅåÁÆ°ÁêÜËÄÖ„Éà„Éº„ÇØ„É≥Êú™Ë®≠ÂÆö„ÅßËµ∑Âãï„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ`MCP_GATEWAY_ADMIN_TOKEN` „ÇíË®≠ÂÆö„Åó„Å¶ Gateway „ÇíÂÜçËµ∑Âãï„ÅóÔºàÊé®Â•®: Step8 „ÅÆËµ∑Âãï„Çπ„ÇØ„É™„Éó„ÉàÔºâ„ÄÅÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁ¢∫Á´ã„Åó„Å¶„Åã„ÇâRetry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        wizardAdminTokenHint: 'ÁîªÈù¢‰∏äÈÉ®„Å®Âêå„ÅòÁÆ°ÁêÜËÄÖ„Éà„Éº„ÇØ„É≥„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑÔºà‰øùÂ≠ò„Åï„Çå„Åæ„Åõ„ÇìÔºâ„ÄÇÂøÖË¶Å„Å™Â†¥Âêà„ÅÆ„Åø Danger Zone „Åß‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        gatewayEnvironmentLabel: 'ÂØæË±°Áí∞Â¢É',
	        gatewayEnvironmentHint: 'Áí∞Â¢É„ÅÆ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Çí OpenAI ‰∫íÊèõ Base URL „Å®„Åó„Å¶Âà©Áî®„Åó„Åæ„Åô„ÄÇ',
	        gatewayTokenLabel: '„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„Éà„Éº„ÇØ„É≥',
        gatewayTokenHint: '„Éà„Éº„ÇØ„É≥„ÅØ‰∏ÄÂ∫¶„Å†„ÅëË°®Á§∫„ÄÇÂÆâÂÖ®„Å´‰øùÁÆ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        gatewayTokenPlaceholder: 'ÁîüÊàê„Åó„Å¶Ë°®Á§∫',
        gatewayGenerateBtn: '„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å',
        gatewayExpiryLabel: '„Éà„Éº„ÇØ„É≥ÊúâÂäπÊúüÈôê (UTC)',
        gatewayExpiryHint: 'Êé®Â•®: „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂêë„Åë„ÅØÁü≠Êúü„Éà„Éº„ÇØ„É≥',
        gatewayNoteLabel: 'Âà©Áî®„É°„É¢',
        gatewayNotePlaceholder: '‰æã: IDE „Éë„Ç§„É≠„ÉÉ„Éà„ÉÅ„Éº„É†',
        gatewayPresetLabel: '„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Éó„É™„Çª„ÉÉ„Éà',
        gatewayPresetHint: '„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂêë„Åë„ÅÆË®≠ÂÆö„Çπ„Éã„Éö„ÉÉ„Éà„ÇíÈÅ∏Êäû',
        gatewayPresetOpenai: 'OpenAI‰∫íÊèõ (env)',
        gatewayPresetCurl: 'cURL „Çπ„É¢„Éº„ÇØ',
        gatewayPresetJson: '„Ç¢„Éó„É™Ë®≠ÂÆö (JSON)',
        gatewayPresetPython: 'SDK „Çµ„É≥„Éó„É´ (Python)',
        gatewayPresetJs: 'SDK „Çµ„É≥„Éó„É´ (JS)',
        gatewayConfigLabel: '„ÇØ„É©„Ç§„Ç¢„É≥„ÉàË®≠ÂÆö',
        gatewayCopyBtn: 'Ë®≠ÂÆö„Çí„Ç≥„Éî„Éº',
        gatewayCopyStatusNotCopied: 'Êú™„Ç≥„Éî„Éº',
        gatewayTargetUrlLabel: 'ÂØæË±° URL',
        gatewaySummaryExpiryLabel: 'ÊúâÂäπÊúüÈôê',
        gatewaySummaryNoteLabel: 'Âà©Áî®„É°„É¢',
        gatewayIssuedAtLabel: 'Áô∫Ë°åÊó•ÊôÇ',
        issuedColToken: '„Éà„Éº„ÇØ„É≥',
        issuedColIssued: 'Áô∫Ë°å',
        issuedColExpiry: 'ÊúüÈôê',
        issuedColNote: '„É°„É¢',
        issuedColStatus: '„Çπ„ÉÜ„Éº„Çø„Çπ',
        issuedColActions: 'Êìç‰Ωú',
        tokenRevokeBtn: 'Â§±Âäπ',
        tokenRevokeConfirm: '„Åì„ÅÆ„Éà„Éº„ÇØ„É≥„ÇíÂ§±Âäπ„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ',
        tokenRevoking: 'Â§±Âäπ‰∏≠...',
        tokenRevokeFailed: '„Éà„Éº„ÇØ„É≥„ÅÆÂ§±Âäπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
        tokenIssueCtaLabel: 'Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó: Gateway „Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å',
        tokenIssueCtaBtn: '„Éà„Éº„ÇØ„É≥Áô∫Ë°å',
        gatewayInfoLabel: '„Ç≥„É≥„Éà„É≠„Éº„É´„Éó„É¨„Éº„É≥:',
        gatewayInfoText: '„Éà„Éº„ÇØ„É≥„ÅØ„Ç≤„Éº„Éà„Ç¶„Çß„Ç§„ÅßÁô∫Ë°å„Åï„Çå‰∏ÄÂ∫¶„Å†„ÅëË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇÂÆâÂÖ®„Å´‰øùÁÆ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        issuedTokensTitle: 'Áô∫Ë°åÊ∏à„Åø„Éà„Éº„ÇØ„É≥ÔºàÈÅ∏Êäû‰∏≠„ÅÆÁí∞Â¢ÉÔºâ',
        issuedTokensHint: 'Â±•Ê≠¥„Åß„ÅØ„Éà„Éº„ÇØ„É≥„ÅØ„Éû„Çπ„ÇØ„Åï„Çå„Åæ„Åô„ÄÇÂÆöÊúüÁöÑ„Å´„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        introGuideToggleHide: 'Â∞éÂÖ•„Ç¨„Ç§„Éâ„ÇíÈö†„Åô',
        introGuideToggleShow: 'Â∞éÂÖ•„Ç¨„Ç§„Éâ„ÇíË°®Á§∫',
        introGuideReset: 'ÂàùÂõû„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó',
        statusActive: 'ÊúâÂäπ',
        statusError: '„Ç®„É©„Éº',
        statusTesting: '„ÉÜ„Çπ„Éà‰∏≠',
        statusExpired: 'ÊúüÈôêÂàá„Çå',
        statusRevoked: 'Â§±Âäπ',
        statusInactive: 'Êú™Ë®≠ÂÆö',
        statusNotTested: 'Êú™„ÉÜ„Çπ„Éà',
        notSet: 'Êú™Ë®≠ÂÆö',
        notIssued: 'Êú™Áô∫Ë°å',
        hiddenToken: 'ÈùûË°®Á§∫',
        adminTokenRequired: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô',
        loadFailed: 'Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
	        baseUrlRequired: 'Base URL „ÅåÂøÖË¶Å„Åß„Åô',
	        apiKeyRequired: 'API„Ç≠„Éº„ÅåÂøÖË¶Å„Åß„Åô',
	        providerRequired: '„Éó„É≠„Éê„Ç§„ÉÄ„ÅåÂøÖË¶Å„Åß„Åô',
        saving: '‰øùÂ≠ò‰∏≠...',
        saveFailed: '‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        testing: '„ÉÜ„Çπ„Éà‰∏≠...',
        saved: '‰øùÂ≠ò„Åó„Åæ„Åó„Åü',
        loaded: 'Ë™≠„ÅøËæº„ÅøÊ∏à„Åø',
        noEnvironments: 'Áí∞Â¢É„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
	        gatewayHistoryNone: 'Áô∫Ë°åÊ∏à„Åø„Éà„Éº„ÇØ„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
	        gatewayHistoryAdminRequired: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô',
	        copyStatusSelectEnv: 'Áí∞Â¢É„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
	        gatewayIssueEnvMissing: 'Áí∞Â¢É„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂÖà„Å´„ÄåÁí∞Â¢É„ÇíËøΩÂä†„Äç„ÅßÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        gatewayIssueAdminDetail: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇAdmin Token „ÇíË≤º„Çä‰ªò„Åë„Å¶„Äå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Äç„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        gatewayIssueGatewayOffline: 'Gateway „Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇËµ∑Âãï„Åó„Å¶„Åã„ÇâÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        gatewayIssueApiMissing: '„Éà„Éº„ÇØ„É≥Áô∫Ë°å API „ÇíÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇGateway „ÇíÊõ¥Êñ∞„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        gatewayIssueInvalidInput: 'ÂÖ•ÂäõÂÄ§„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàÊúâÂäπÊúüÈôê„Å™„Å©Ôºâ„ÄÇ',
	        gatewayIssueServerError: 'Gateway „Åå„Ç®„É©„Éº„ÇíËøî„Åó„Åæ„Åó„Åü„ÄÇGateway „ÅÆË®≠ÂÆöÔºàAdmin Token / „Éù„É™„Ç∑„Éº„Éê„É≥„Éâ„É´Ôºâ„ÇíÁ¢∫Ë™ç„Åó„ÄÅGateway „ÇíËµ∑Âãï„Åó„Åü„Çø„Éº„Éü„Éä„É´ÔºàPowerShell/WSLÔºâ„ÅÆ„É≠„Ç∞„Å® Audit Log „ÇíÁ¢∫Ë™ç„Åó„Å¶Retry„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
	        copyStatusAdminRequired: 'ÁÆ°ÁêÜËÄÖ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Åß„Åô',
	        copyStatusIssuing: 'Áô∫Ë°å‰∏≠...',
	        copyStatusIssueFailed: 'Áô∫Ë°å„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
	        copyStatusIssued: '„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å„Åó„Åæ„Åó„Åü',
        copyStatusCopied: '„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü',
        copyStatusCopyFailed: '„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        providerOpenAICompatible: 'OpenAI‰∫íÊèõ',
        providerOpenAI: 'OpenAI',
        providerGemini: 'Gemini',
        providerVertex: 'Vertex AI',
        providerAnthropic: 'Anthropic',
        providerOllama: 'Ollama',
        policyStatusNotLoaded: 'Êú™„É≠„Éº„Éâ',
        settingsEnv: {
          oauth2Title: 'OAuth2 PAR + DPoP \u2014 Ê¨°‰∏ñ‰ª£„Éà„Éº„ÇØ„É≥„Çª„Ç≠„É•„É™„ÉÜ„Ç£',
          oauth2Planned: 'Ë®àÁîª‰∏≠',
          oauth2Desc: '„Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÅØ„ÄÅ‰∏äË®ò„ÅÆ Gateway Connection Wizard „ÅßÁô∫Ë°å„Åó„Å¶„ÅÑ„ÇãÈùôÁöÑ Bearer „Éà„Éº„ÇØ„É≥„Éï„É≠„Éº„Çí„ÄÅ„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫„Ç∞„É¨„Éº„Éâ„ÅÆ OAuth2 „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å´ÁΩÆ„ÅçÊèõ„Åà„Åæ„Åô„ÄÇÈï∑ÊúüÈñìÊúâÂäπ„ÅßÁõóÁî®„ÉªÂÜçÂà©Áî®ÂèØËÉΩ„Å™„Éà„Éº„ÇØ„É≥„Å´‰ª£„Çè„Çä„ÄÅ„Åô„Åπ„Å¶„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„É™„ÇØ„Ç®„Çπ„Éà„Å´„Éá„Éê„Ç§„Çπ„Å®„Éà„Éº„ÇØ„É≥„ÇíÁ¥ê‰ªò„Åë„ÇãÊöóÂè∑Â≠¶ÁöÑË®ºÊòé„Çí‰ªò‰∏é„Åó„Åæ„Åô„ÄÇ',
          oauth2DescSub: 'ÁèæÂú®„ÄÅMCP Gateway „ÅØ Connection Wizard „ÅßÈùôÁöÑ„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇPAR + DPoP „ÅØ„Åì„Çå„Çí‰∫åÈáçÈò≤Âæ°„Å´„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„Åó„Åæ„Åô: „Çµ„Éº„Éê„ÉºÂÅ¥Ë™çÂèØ„É™„ÇØ„Ç®„Çπ„Éà‰øùÁÆ° (PAR) „Å®„ÄÅ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Éê„Ç¶„É≥„Éâ„ÅÆÊâÄÊúâË®ºÊòé (DPoP) „Åß„Åô„ÄÇ',
          oauth2ParTitle: 'PAR \u2014 Pushed Authorization Requests (RFC 9126)',
          oauth2Par: '„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅØË™çÂèØ„Éë„É©„É°„Éº„Çø„Çí URL „ÇØ„Ç®„É™ÊñáÂ≠óÂàó„Åß„ÅØ„Å™„Åè„ÄÅ„Éê„ÉÉ„ÇØ„ÉÅ„É£„Éç„É´ POST „Åß Gateway „ÅÆ„Éà„Éº„ÇØ„É≥„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Å´Áõ¥Êé•ÈÄÅ‰ø°„Åó„Åæ„Åô„ÄÇGateway „ÅØ„É™„ÇØ„Ç®„Çπ„Éà„Çí„Çµ„Éº„Éê„ÉºÂÅ¥„Å´‰øùÂ≠ò„Åó„ÄÅÁü≠ÂëΩ„ÅÆ <code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">request_uri</code> „ÇíËøî„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„ÄÅ„Éñ„É©„Ç¶„Ç∂Â±•Ê≠¥„ÉªReferrer „Éò„ÉÉ„ÉÄ„Éº„Éª„Éó„É≠„Ç≠„Ç∑„É≠„Ç∞„ÇíÁµåÁî±„Åó„Åü„Éà„Éº„ÇØ„É≥ÊºèÊ¥©„ÇíÈò≤Ê≠¢„Åó„Åæ„Åô„ÄÇ',
          oauth2DpopTitle: 'DPoP \u2014 Demonstration of Proof-of-Possession (RFC 9449)',
          oauth2Dpop: 'ÂêÑ API „É™„ÇØ„Ç®„Çπ„Éà„Å´„ÅØ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆÁßòÂØÜÈçµ„ÅßÁîüÊàê„Åï„Çå„ÅüÁΩ≤Âêç‰ªò„Åç JWT Ë®ºÊòé (<code style="font-size:11px;background:#f3f4f6;padding:1px 4px;border-radius:3px;">DPoP</code> „Éò„ÉÉ„ÉÄ„Éº) „ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇGateway „ÅØÁΩ≤Âêç„ÇíÊ§úË®º„Åó„ÄÅ„Éà„Éº„ÇØ„É≥„ÇíÁô∫‰ø°„Éá„Éê„Ç§„Çπ„Å´Á¥ê‰ªò„Åë„Åæ„Åô„ÄÇ„Éà„Éº„ÇØ„É≥„ÅåÂÇçÂèó„Åï„Çå„Å¶„ÇÇ„ÄÅÁßòÂØÜÈçµ„Åå„Å™„Åë„Çå„Å∞Âà•„ÅÆ„Éû„Ç∑„É≥„Åã„ÇâÂÜçÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ',
          oauth2CombinedTitle: 'Áµ±Âêà„Éï„É≠„Éº: PAR + DPoP',
          oauth2CombinedDesc: '<strong>1.</strong> „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Åå„Éá„Éê„Ç§„Çπ„Åî„Å®„Å´‰∏ÄÊôÇÈçµ„Éö„Ç¢„ÇíÁîüÊàê \u2192 <strong>2.</strong> PAR „Éê„ÉÉ„ÇØ„ÉÅ„É£„Éç„É´„ÅßË™çÂèØ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÈÄÅ‰ø° \u2192 <strong>3.</strong> Gateway „Åå DPoP „Éê„Ç¶„É≥„Éâ„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥„ÇíÁô∫Ë°å \u2192 <strong>4.</strong> ÂêÑ API Âëº„Å≥Âá∫„Åó„Å´„Éà„Éº„ÇØ„É≥„Å®Êñ∞„Åó„ÅÑ DPoP Ë®ºÊòé„Çí‰ªò‰∏é \u2192 <strong>5.</strong> Gateway „Åå„É™„ÇØ„Ç®„Çπ„Éà„Åî„Å®„Å´Ë®ºÊòé + „Éà„Éº„ÇØ„É≥Á¥ê‰ªò„Åë„ÇíÊ§úË®º \u2192 Áõó„Åæ„Çå„Åü„Éà„Éº„ÇØ„É≥„ÅØÁßòÂØÜÈçµ„Å™„Åó„Åß„ÅØÁÑ°Âäπ„ÄÇ'
        }
      }
    };

    window.I18N = I18N;

    function t(key) {
      const lang = getPageLanguage();
      const dict = I18N[lang] || I18N.en;
      return dict[key] || key;
    }

    function applyI18n(lang) {
      const dict = I18N[lang] || I18N.en;
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const asAttr = el.getAttribute('data-i18n-attr');
        const asHtml = el.getAttribute('data-i18n-html') === 'true';
        const keys = key.split('.');
        let val = dict;
        for (const k of keys) { val = val && val[k]; }
        if (val === undefined || val === null) val = '';
        if (asAttr) {
          el.setAttribute(asAttr, val);
        } else if (asHtml) {
          el.innerHTML = val;
        } else {
          el.textContent = val;
        }
      });
    }

    window.applyI18n = applyI18n;

    function setText(id, value) {
      const el = document.getElementById(id);
      if (!el) return;
      const firstTag = el.firstElementChild ? el.firstElementChild.tagName.toLowerCase() : '';
      if (firstTag === 'svg' || firstTag === 'strong') {
        const TEXT_NODE = 3; // avoid Node.TEXT_NODE in non-DOM test env
        const textNode = Array.from(el.childNodes).find((node) => node.nodeType === TEXT_NODE);
        if (textNode) {
          textNode.textContent = ' ' + value;
        } else {
          el.appendChild(document.createTextNode(value));
        }
        return;
      }
      el.textContent = value;
    }

    function setPlaceholder(id, value) {
      const el = document.getElementById(id);
      if (el && typeof value === 'string') {
        el.placeholder = value;
      }
    }

    function setOptionText(selectId, optionValue, text) {
      const select = document.getElementById(selectId);
      if (!select) return;
      const opt = Array.from(select.options).find((o) => o.value === optionValue);
      if (opt && typeof text === 'string') {
        opt.textContent = text;
      }
    }

    function setFallbackText(el, value, fallbackKey) {
      if (!el || !fallbackKey) return;
      if (value) {
        el.textContent = value;
        delete el.dataset.fallbackKey;
      } else {
        el.textContent = t(fallbackKey);
        el.dataset.fallbackKey = fallbackKey;
      }
    }

    function applyTranslations(lang) {
      setPageLanguage(lang);
      applyI18n(lang);
      const tt = I18N[lang] || I18N.ja;
      setText('pageTitle', tt.pageTitle);
      setText('pageSubtitle', tt.pageSubtitle);
      setText('diagnosticsTitle', tt.diagnosticsTitle);
      setText('diagnosticsHint', tt.diagnosticsHint);
      setText('diagnosticsRunBtn', tt.diagnosticsRunBtn);
      setText('diagnosticsCopyBtn', tt.diagnosticsCopyBtn);
      setText('diagnosticsDownloadBtn', tt.diagnosticsDownloadBtn);
      setText('diagnosticsAdvancedHint', tt.diagnosticsAdvancedHint);
      setText('langLabel', tt.langLabel);
      setText('guideTitle', tt.guideTitle);
      setText('guideStep1', tt.guideStep1);
      setText('guideStep2', tt.guideStep2);
      setText('guideStep3', tt.guideStep3);
      setText('guideStep4', tt.guideStep4);
      setText('addEnvTitle', tt.addEnvTitle);
      setText('envTableTitle', tt.envTableTitle);
      setText('envColName', tt.envColName);
      setText('envColEndpoint', tt.envColEndpoint);
      setText('envColStatus', tt.envColStatus);
      setText('envColNote', tt.envColNote);
      setText('envNameLabel', tt.envNameLabel);
      setText('envNameHint', tt.envNameHint);
      setPlaceholder('envName', tt.envNamePlaceholder);
      setText('envEndpointLabel', tt.envEndpointLabel);
      setText('envEndpointHint', tt.envEndpointHint);
      setPlaceholder('envEndpoint', tt.envEndpointPlaceholder);
      setText('envNoteLabel', tt.envNoteLabel);
      setPlaceholder('envNote', tt.envNotePlaceholder);
      setText('envSaveBtn', tt.envSaveBtn);
      setText('settingsApiLabel', tt.settingsApiLabel);
      setText('settingsApiText', tt.settingsApiText);
      setText('upstreamTitle', tt.upstreamTitle);
      setText('adminTokenLabel', tt.adminTokenLabel);
      setPlaceholder('adminToken', tt.adminTokenPlaceholder);
      setText('adminSessionStartBtn', tt.adminSessionStartBtn);
      setText('adminTokenHint', tt.adminSessionHint);
      setText('dangerZoneTitleText', tt.dangerZoneTitleText);
      setText('dangerZoneNote', tt.dangerZoneNote);
      setText('dangerEnableToggleLabel', tt.dangerEnableToggleLabel);
      setText('dangerDurationLabel', tt.dangerDurationLabel);
      setOptionText('dangerDuration', '900', tt.dangerDuration15m);
      setOptionText('dangerDuration', '3600', tt.dangerDuration1h);
      setOptionText('dangerDuration', '28800', tt.dangerDuration8h);
      setOptionText('dangerDuration', 'session', tt.dangerDurationSession);
      setText('dangerPersistentLabel', tt.dangerPersistentLabel);
      setText('dangerConsentLabel', tt.dangerConsentLabel);
      setText('dangerApplyBtn', tt.dangerApplyBtn);
      setText('dangerDisableBtn', tt.dangerDisableBtn);
      setText('wizardAdminTokenHint', tt.wizardAdminTokenHint);
      setText('upstreamBaseUrlLabel', tt.upstreamBaseUrlLabel);
      setText('upstreamBaseUrlHint', tt.upstreamBaseUrlHint);
      setPlaceholder('upstreamBaseUrl', tt.upstreamBaseUrlPlaceholder);
      setText('upstreamApiKeyLabel', tt.upstreamApiKeyLabel);
      setText('upstreamApiKeyHint', tt.upstreamApiKeyHint);
      setPlaceholder('upstreamApiKey', tt.upstreamApiKeyPlaceholder);
      if (typeof updateUpstreamApiKeyDisplay === 'function') {
        updateUpstreamApiKeyDisplay(typeof upstreamHasKey !== 'undefined' && upstreamHasKey);
      }
      setText('upstreamModelsLabel', tt.upstreamModelsLabel);
      setText('upstreamModelsHint', tt.upstreamModelsHint);
      setPlaceholder('upstreamModels', tt.upstreamModelsPlaceholder);
      setText('upstreamProviderLabel', tt.upstreamProviderLabel);
      setOptionText('upstreamProvider', 'openai_compatible', tt.upstreamProviderOpenAICompatible);
      setOptionText('upstreamProvider', 'openai', tt.upstreamProviderOpenAI);
      setOptionText('upstreamProvider', 'gemini_openai', tt.upstreamProviderGemini);
      setOptionText('upstreamProvider', 'vertex', tt.upstreamProviderVertex);
      setOptionText('upstreamProvider', 'anthropic_openai', tt.upstreamProviderAnthropic);
      setOptionText('upstreamProvider', 'ollama', tt.upstreamProviderOllama);
      setOptionText('upstreamProvider', 'custom', tt.upstreamProviderCustom);
      setText('upstreamProviderCustomLabel', tt.upstreamProviderCustomLabel);
      setText('upstreamProviderCustomHint', tt.upstreamProviderCustomHint);
      setPlaceholder('upstreamProviderCustom', tt.upstreamProviderCustomPlaceholder);
      setText('upstreamSaveBtn', tt.upstreamSaveBtn);
      setText('upstreamSummaryStatusLabel', tt.upstreamSummaryStatusLabel);
      setText('upstreamSummaryBaseUrlLabel', tt.upstreamSummaryBaseUrlLabel);
      setText('upstreamSummaryProviderLabel', tt.upstreamSummaryProviderLabel);
      setText('upstreamSummaryModelsLabel', tt.upstreamSummaryModelsLabel);
      setText('upstreamSummaryTestedLabel', tt.upstreamSummaryTestedLabel);
      setText('upstreamInfoLabel', tt.upstreamInfoLabel);
      setText('upstreamInfoText', tt.upstreamInfoText);
      setText('policyProfilesTitle', tt.policyProfilesTitle);
      setText('policyProfileLabel', tt.policyProfileLabel);
      setText('policyProfileHint', tt.policyProfileHint);
      setOptionText('policyProfileSelect', 'standard', tt.policyOptionStandard);
      setOptionText('policyProfileSelect', 'strict', tt.policyOptionStrict);
      setOptionText('policyProfileSelect', 'development', tt.policyOptionDevelopment);
      setText('policyRestrictedSinksLabel', tt.policyRestrictedSinksLabel);
      setText('policyRestrictedSinksHint', tt.policyRestrictedSinksHint);
      setPlaceholder('policyRestrictedSinks', tt.policyRestrictedSinksPlaceholder);
      setText('policyAllowUntrustedLabel', tt.policyAllowUntrustedLabel);
      setText('policyAllowUntrustedHint', tt.policyAllowUntrustedHint);
      setText('policyChangeReasonLabel', tt.policyChangeReasonLabel);
      setPlaceholder('policyChangeReason', tt.policyChangeReasonPlaceholder);
      setText('policySaveBtn', tt.policySaveBtn);
      setText('policySummarySinksLabel', tt.policySummarySinksLabel);
      setText('policySummaryApprovalsLabel', tt.policySummaryApprovalsLabel);
      setText('policySummaryUpdatedLabel', tt.policySummaryUpdatedLabel);
      setText('policyInfoLabel', tt.policyInfoLabel);
      setText('policyInfoText', tt.policyInfoText);
      setText('wizardTitle', tt.wizardTitle);
      setText('wizardSectionTitle', tt.wizardSectionTitle);
      setText('wizardSubtitle', tt.wizardSubtitle);
      setText('wizardStep1', tt.wizardStep1);
      setText('wizardStep2', tt.wizardStep2);
      setText('wizardStep3', tt.wizardStep3);
      if (typeof updateAdminSessionBanner === 'function') {
        updateAdminSessionBanner();
      }
      setText('wizardStep1Title', tt.wizardStep1Title);
      setText('wizardStep1Desc', tt.wizardStep1Desc);
      setText('wizardTokenSetupTitle', tt.wizardTokenSetupTitle);
      setText('wizardTokenSetupStep1', tt.wizardTokenSetupStep1);
      setText('wizardTokenSetupStep2', tt.wizardTokenSetupStep2);
      setText('wizardTokenSetupStep3', tt.wizardTokenSetupStep3);
      setText('wizardTokenSetupHint', tt.wizardTokenSetupHint);
      setText('wizardTokenSetupTitle', tt.wizardTokenSetupTitle);
      setText('wizardTokenSetupStep1', tt.wizardTokenSetupStep1);
      setText('wizardTokenSetupStep2', tt.wizardTokenSetupStep2);
      setText('wizardTokenSetupStep3', tt.wizardTokenSetupStep3);
      setText('wizardTokenSetupHint', tt.wizardTokenSetupHint);
      setText('wizardStep2Title', tt.wizardStep2Title);
      setText('wizardStep2Desc', tt.wizardStep2Desc);
      setText('wizardStep3Title', tt.wizardStep3Title);
      setText('wizardStep3Desc', tt.wizardStep3Desc);
      setText('wizardStep4Title', tt.wizardStep4Title);
      setText('wizardStep4Desc', tt.wizardStep4Desc);
      setText('wizardStep5Title', tt.wizardStep5Title);
      setText('wizardStep5Desc', tt.wizardStep5Desc);
      setText('wizardPrecheckBtn', tt.wizardPrecheckBtn);
      setText('wizardAutostartTitle', tt.wizardAutostartTitle);
      setText('wizardAutostartDesc', tt.wizardAutostartDesc);
      setText('wizardAutostartWindowsLabel', tt.wizardAutostartWindowsLabel);
      setText('wizardAutostartMacLabel', tt.wizardAutostartMacLabel);
      setText('wizardAutostartLinuxLabel', tt.wizardAutostartLinuxLabel);
      setText('wizardAutostartNote', tt.wizardAutostartNote);
      setText('wizardAutostartDocHint', tt.wizardAutostartDocHint);
      setText('wizardAutostartDockerHint', tt.wizardAutostartDockerHint);
      setText('wizardGatewayModeLabel', tt.wizardGatewayModeLabel);
      setText('wizardGatewayModeAutoLabel', tt.wizardGatewayModeAuto);
      setText('wizardGatewayModeManualLabel', tt.wizardGatewayModeManual);
      setText('wizardGatewayAutoHint', tt.wizardGatewayAutoHint);
      setText('wizardGatewayEnvNameLabel', tt.wizardGatewayEnvNameLabel);
      setText('wizardGatewayEnvNameHint', tt.wizardGatewayEnvNameHint);
      setPlaceholder('wizardGatewayEnvName', tt.wizardGatewayEnvNamePlaceholder);
      setText('wizardGatewayBaseUrlLabel', tt.wizardGatewayBaseUrlLabel);
      setText('wizardGatewayBaseUrlHint', tt.wizardGatewayBaseUrlHint);
      setPlaceholder('wizardGatewayBaseUrl', tt.wizardGatewayBaseUrlPlaceholder);
      setText('wizardIssueTokenLabel', tt.wizardGatewayIssueBtn);
      setText('gatewayEnvironmentLabel', tt.gatewayEnvironmentLabel);
      setText('gatewayEnvironmentHint', tt.gatewayEnvironmentHint);
      setText('gatewayTokenLabel', tt.gatewayTokenLabel);
      setText('gatewayTokenHint', tt.gatewayTokenHint);
      setPlaceholder('gatewayToken', tt.gatewayTokenPlaceholder);
      setText('gatewayGenerate', tt.gatewayGenerateBtn);
      setText('gatewayExpiryLabel', tt.gatewayExpiryLabel);
      setText('gatewayExpiryHint', tt.gatewayExpiryHint);
      setText('gatewayNoteLabel', tt.gatewayNoteLabel);
      setPlaceholder('gatewayNote', tt.gatewayNotePlaceholder);
      setText('gatewayPresetLabel', tt.gatewayPresetLabel);
      setText('gatewayPresetHint', tt.gatewayPresetHint);
      setOptionText('gatewayPreset', 'openai-env', tt.gatewayPresetOpenai);
      setOptionText('gatewayPreset', 'curl', tt.gatewayPresetCurl);
      setOptionText('gatewayPreset', 'json', tt.gatewayPresetJson);
      setOptionText('gatewayPreset', 'python', tt.gatewayPresetPython);
      setOptionText('gatewayPreset', 'javascript', tt.gatewayPresetJs);
      setText('gatewayConfigLabel', tt.gatewayConfigLabel);
      setText('gatewayCopy', tt.gatewayCopyBtn);
      if (typeof setGatewayCopyStatus === 'function') {
        setGatewayCopyStatus(tt.gatewayCopyStatusNotCopied, 'gatewayCopyStatusNotCopied');
      } else {
        setText('gatewayCopyStatus', tt.gatewayCopyStatusNotCopied);
      }
      setText('gatewayTargetUrlLabel', tt.gatewayTargetUrlLabel);
      setText('gatewaySummaryExpiryLabel', tt.gatewaySummaryExpiryLabel);
      setText('gatewaySummaryNoteLabel', tt.gatewaySummaryNoteLabel);
      setText('gatewayIssuedAtLabel', tt.gatewayIssuedAtLabel);
      setText('issuedTokensTitle', tt.issuedTokensTitle);
      setText('issuedColToken', tt.issuedColToken);
      setText('issuedColIssued', tt.issuedColIssued);
      setText('issuedColExpiry', tt.issuedColExpiry);
      setText('issuedColNote', tt.issuedColNote);
      setText('issuedColStatus', tt.issuedColStatus);
      setText('issuedColActions', tt.issuedColActions);
      setText('issuedTokensHint', tt.issuedTokensHint);
      setText('gatewayInfoLabel', tt.gatewayInfoLabel);
      setText('gatewayInfoText', tt.gatewayInfoText);

      // refresh intro guide action labels after language change
      const toggleBtnLangUpdate = document.getElementById('introGuideToggleBtn');
      const introBodyLangUpdate = document.getElementById('introGuideBody');
      if (toggleBtnLangUpdate && introBodyLangUpdate) {
        const collapsed = introBodyLangUpdate.classList.contains('collapsed');
        toggleBtnLangUpdate.textContent = collapsed ? tt.introGuideToggleShow : tt.introGuideToggleHide;
      }
      const resetBtnLangUpdate = document.getElementById('introGuideResetBtn');
      if (resetBtnLangUpdate) resetBtnLangUpdate.textContent = tt.introGuideReset;

      // These status functions may not be defined yet - guard with typeof
      if (typeof setUpstreamStatus === 'function' && typeof upstreamStatus !== 'undefined' && upstreamStatus && !upstreamStatus.dataset.state) {
        setUpstreamStatus('inactive', tt.statusNotTested, 'statusNotTested');
      }
      if (typeof setPolicyStatus === 'function' && typeof policyStatus !== 'undefined' && policyStatus && !policyStatus.dataset.state) {
        setPolicyStatus('inactive', tt.policyStatusNotLoaded, 'policyStatusNotLoaded');
      }
      if (typeof gatewayCopyStatus !== 'undefined' && gatewayCopyStatus && !gatewayCopyStatus.dataset.labelKey) {
        if (typeof setGatewayCopyStatus === 'function') setGatewayCopyStatus(tt.gatewayCopyStatusNotCopied, 'gatewayCopyStatusNotCopied');
      }

      setFallbackText(document.getElementById('upstreamSummaryBaseUrl'), '', 'notSet');
      setFallbackText(document.getElementById('upstreamSummaryProvider'), '', 'notSet');
      setFallbackText(document.getElementById('upstreamSummaryModels'), '', 'notSet');
      setFallbackText(document.getElementById('upstreamSummaryTested'), '', 'statusNotTested');
      setFallbackText(document.getElementById('policySummaryUpdated'), '', 'notSet');
      setFallbackText(document.getElementById('policySummarySinks'), '', 'notSet');
      setFallbackText(document.getElementById('gatewayTargetUrl'), '', 'notSet');
      setFallbackText(document.getElementById('gatewaySummaryExpiry'), '', 'notSet');
      setFallbackText(document.getElementById('gatewaySummaryNote'), '', 'notSet');
	      setFallbackText(document.getElementById('gatewayIssuedAt'), '', 'notIssued');

	      if (typeof renderUpstreamProviderHint === 'function') renderUpstreamProviderHint();
	      if (typeof window.renderWizardUpstreamProviderHint === 'function') window.renderWizardUpstreamProviderHint();
	      translateDynamicValues();
	      if (typeof renderUpstreamSummary === 'function') renderUpstreamSummary();
	      if (typeof renderPolicySummary === 'function') renderPolicySummary();
	      if (typeof renderGatewayConfig === 'function') renderGatewayConfig();
      if (typeof renderGatewayHistory === 'function') renderGatewayHistory();
      if (typeof renderDiagnostics === 'function') renderDiagnostics();
      if (typeof render === 'function') render();
    }

    function translateFallbacks() {
      const targets = [
        document.getElementById('upstreamSummaryBaseUrl'),
        document.getElementById('upstreamSummaryProvider'),
        document.getElementById('upstreamSummaryModels'),
        document.getElementById('upstreamSummaryTested'),
        document.getElementById('policySummaryUpdated'),
        document.getElementById('policySummarySinks'),
        document.getElementById('gatewayTargetUrl'),
        document.getElementById('gatewaySummaryExpiry'),
        document.getElementById('gatewaySummaryNote'),
        document.getElementById('gatewayIssuedAt')
      ];
      targets.forEach((el) => {
        if (el && el.dataset.fallbackKey) {
          el.textContent = t(el.dataset.fallbackKey);
        }
      });
    }

    function translateDynamicValues() {
      const elUp = typeof upstreamStatus !== 'undefined' && upstreamStatus ? upstreamStatus : document.getElementById('upstreamStatus');
      if (elUp && elUp.dataset) {
        const upstreamState = elUp.dataset.state;
        const upstreamKey = elUp.dataset.labelKey || (upstreamState ? statusLabelKey(upstreamState) : "");
        if (upstreamState && upstreamKey) setUpstreamStatus(upstreamState, t(upstreamKey), upstreamKey);
      }

      const elPol = typeof policyStatus !== 'undefined' && policyStatus ? policyStatus : document.getElementById('policyStatus');
      if (elPol && elPol.dataset && elPol.dataset.state && elPol.dataset.labelKey) {
        setPolicyStatus(elPol.dataset.state, t(elPol.dataset.labelKey), elPol.dataset.labelKey);
      }

	      const elCopy = typeof gatewayCopyStatus !== 'undefined' && gatewayCopyStatus ? gatewayCopyStatus : document.getElementById('gatewayCopyStatus');
	      if (elCopy && elCopy.dataset && elCopy.dataset.labelKey) {
	        elCopy.textContent = t(elCopy.dataset.labelKey);
	      }

		      const elGatewayIssueMsg = document.getElementById('gatewayIssueMessage');
		      if (elGatewayIssueMsg && elGatewayIssueMsg.dataset && elGatewayIssueMsg.dataset.labelKey) {
		        elGatewayIssueMsg.textContent = t(elGatewayIssueMsg.dataset.labelKey);
		      }

			      const elGatewayIssueCta = document.getElementById('gatewayIssueCta');
			      if (elGatewayIssueCta && elGatewayIssueCta.dataset && elGatewayIssueCta.dataset.labelKey) {
			        elGatewayIssueCta.textContent = t(elGatewayIssueCta.dataset.labelKey);
			      }

			      const elWizardFinalTestCta = document.getElementById('wizardFinalTestCta');
			      if (elWizardFinalTestCta && elWizardFinalTestCta.dataset && elWizardFinalTestCta.dataset.labelKey) {
			        elWizardFinalTestCta.textContent = t(elWizardFinalTestCta.dataset.labelKey);
			      }

			      const elWizardGatewayCta = document.getElementById('wizardGatewayCta');
			      if (elWizardGatewayCta && elWizardGatewayCta.dataset && elWizardGatewayCta.dataset.labelKey) {
			        elWizardGatewayCta.textContent = t(elWizardGatewayCta.dataset.labelKey);
			      }

			      const elDiagnosticsCta = document.getElementById('diagnosticsCta');
			      if (elDiagnosticsCta && elDiagnosticsCta.dataset && elDiagnosticsCta.dataset.labelKey) {
			        elDiagnosticsCta.textContent = t(elDiagnosticsCta.dataset.labelKey);
			      }

				      const elEnvIssueMsg = document.getElementById('envIssueMessage');
				      if (elEnvIssueMsg && elEnvIssueMsg.dataset && elEnvIssueMsg.dataset.labelKey) {
				        elEnvIssueMsg.textContent = t(elEnvIssueMsg.dataset.labelKey);
				      }

				      const elUpstreamIssueMsg = document.getElementById('upstreamIssueMessage');
				      if (elUpstreamIssueMsg && elUpstreamIssueMsg.dataset && elUpstreamIssueMsg.dataset.labelKey) {
				        const labelKey = elUpstreamIssueMsg.dataset.labelKey;
				        const suffix = elUpstreamIssueMsg.dataset.suffix || "";
				        const hintKey = elUpstreamIssueMsg.dataset.hintKey || "";
				        elUpstreamIssueMsg.textContent = t(labelKey) + suffix + (hintKey ? ` ${t(hintKey)}` : "");
				      }

				      const elUpstreamIssueCta = document.getElementById('upstreamIssueCta');
				      if (elUpstreamIssueCta && elUpstreamIssueCta.dataset && elUpstreamIssueCta.dataset.labelKey) {
				        elUpstreamIssueCta.textContent = t(elUpstreamIssueCta.dataset.labelKey);
				      }

			      const elPolicyIssueMsg = document.getElementById('policyIssueMessage');
			      if (elPolicyIssueMsg && elPolicyIssueMsg.dataset && elPolicyIssueMsg.dataset.labelKey) {
			        elPolicyIssueMsg.textContent = t(elPolicyIssueMsg.dataset.labelKey);
			      }

		      const elPolicyIssueCta = document.getElementById('policyIssueCta');
		      if (elPolicyIssueCta && elPolicyIssueCta.dataset && elPolicyIssueCta.dataset.labelKey) {
		        elPolicyIssueCta.textContent = t(elPolicyIssueCta.dataset.labelKey);
		      }

		      const elAdminSessionStatus = document.getElementById('adminSessionStatus');
		      if (elAdminSessionStatus && elAdminSessionStatus.dataset && elAdminSessionStatus.dataset.labelKey) {
		        const key = elAdminSessionStatus.dataset.labelKey;
		        const suffix = key === "adminSessionEstablished" ? (elAdminSessionStatus.dataset.suffix || "") : "";
		        elAdminSessionStatus.textContent = t(key) + suffix;
		      }

		      const elDangerStatus = document.getElementById('dangerStatus');
		      if (elDangerStatus && elDangerStatus.dataset && elDangerStatus.dataset.labelKey) {
		        elDangerStatus.textContent = t(elDangerStatus.dataset.labelKey);
		      }

		      const elAdminBanner = document.getElementById('adminSessionBannerMessage');
		      if (elAdminBanner && elAdminBanner.dataset && elAdminBanner.dataset.labelKey) {
		        elAdminBanner.textContent = t(elAdminBanner.dataset.labelKey);
		      }

		      const elAdminBannerCta = document.getElementById('adminSessionBannerCta');
		      if (elAdminBannerCta && elAdminBannerCta.dataset && elAdminBannerCta.dataset.labelKey) {
		        elAdminBannerCta.textContent = t(elAdminBannerCta.dataset.labelKey);
		      }

		      translateFallbacks();
		    }

    const langJa = document.getElementById('langJa');
    const langEn = document.getElementById('langEn');
    if (langJa) langJa.addEventListener('click', () => { setPageLanguage('ja'); applyTranslations('ja'); });
    if (langEn) langEn.addEventListener('click', () => { setPageLanguage('en'); applyTranslations('en'); });

    // Initialize language state on page load
    const currentLang = getPageLanguage();
    setPageLanguage(currentLang);
    applyTranslations(currentLang);

    // Setup intro guide toggle/reset actions (once only)
    (function () {
      const toggleBtn = document.getElementById('introGuideToggleBtn');
      const resetBtn = document.getElementById('introGuideResetBtn');
      const introBody = document.getElementById('introGuideBody');

      if (!toggleBtn || !introBody) {
        console.warn('introGuideToggleBtn or introGuideBody not found');
        return;
      }

      function getIntroCollapsed() {
        try { return window.localStorage.getItem('introGuideCollapsed') === '1'; } catch (e) { return false; }
      }
      function setIntroCollapsed(val) {
        try { window.localStorage.setItem('introGuideCollapsed', val ? '1' : '0'); } catch (e) { }
      }
      function updateToggleLabel() {
        const collapsed = introBody.classList.contains('collapsed');
        const dict = I18N[getPageLanguage()] || I18N.ja;
        toggleBtn.textContent = collapsed ? dict.introGuideToggleShow : dict.introGuideToggleHide;
      }

      // Initialize: apply collapsed state from localStorage on page load
      const shouldCollapse = getIntroCollapsed();
      if (shouldCollapse) {
        introBody.classList.add('collapsed');
      }
      updateToggleLabel();

      // Setup toggle click handler
      toggleBtn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('toggleBtn clicked, current collapsed:', introBody.classList.contains('collapsed'));
        introBody.classList.toggle('collapsed');
        const isNowCollapsed = introBody.classList.contains('collapsed');
        setIntroCollapsed(isNowCollapsed);
        updateToggleLabel();
      });

      if (resetBtn) {
        resetBtn.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          // Â±ïÈñã„Åó„Å¶„Ç¶„Ç£„Ç∂„Éº„Éâ„Å∏„Çπ„ÇØ„É≠„Éº„É´
          introBody.classList.remove('collapsed');
          setIntroCollapsed(false);
          updateToggleLabel();

          setTimeout(function () {
            const wizardHeader = document.querySelector('.collapsible-header[data-section="wizard"]');
            if (wizardHeader) {
              // „Ç¶„Ç£„Ç∂„Éº„Éâ„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ body „ÇíÂ±ïÈñã
              const card = wizardHeader.closest('.card.form-card');
              if (card) {
                const body = card.querySelector('.collapsible-body');
                if (body && body.classList.contains('collapsed')) {
                  body.classList.remove('collapsed');
                  card.classList.remove('collapsed');
                }
              }
              wizardHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }, 100);
        });
      }
    })();

    // Collapsible Sections with persisted state (default collapsed)
    (function () {
      function store() { try { return window.localStorage; } catch (e) { return null; } }
      document.querySelectorAll('.collapsible-header').forEach(header => {
        const card = header.closest('.card.form-card');
        const body = card ? card.querySelector('.collapsible-body') : null;
        if (!card || !body) return;
        const key = 'collapse_' + (header.getAttribute('data-section') || '');
        let collapsed = true;
        const s = store();
        const v = s ? s.getItem(key) : null;
        if (v !== null) collapsed = v === '1';
        if (collapsed) { body.classList.add('collapsed'); card.classList.add('collapsed'); }
        header.addEventListener('click', function () {
          const nowCollapsed = !body.classList.contains('collapsed');
          body.classList.toggle('collapsed');
          card.classList.toggle('collapsed');
          const ss = store(); if (ss) ss.setItem(key, nowCollapsed ? '1' : '0');
        });
      });
    })();

    // Initialize language (redundant safeguard)
    setPageLanguage(getPageLanguage());
  </script>
  <script>
    // Original script content continues...
    const rows = document.getElementById("envRows");
	    const form = document.getElementById("envForm");
	    const nameInput = document.getElementById("envName");
	    const endpointInput = document.getElementById("envEndpoint");
	    const noteInput = document.getElementById("envNote");
	    const envIssueResult = document.getElementById("envIssueResult");
	    const envIssueMessage = document.getElementById("envIssueMessage");
	    const upstreamForm = document.getElementById("upstreamForm");
	    const upstreamBaseUrl = document.getElementById("upstreamBaseUrl");
	    const upstreamApiKey = document.getElementById("upstreamApiKey");
	    const upstreamModels = document.getElementById("upstreamModels");
	    const upstreamProvider = document.getElementById("upstreamProvider");
	    const upstreamProviderCustom = document.getElementById("upstreamProviderCustom");
	    const upstreamProviderCustomWrap = document.getElementById("upstreamProviderCustomWrap");
	    const upstreamProviderHintBody = document.getElementById("upstreamProviderHintBody");
	    const upstreamProviderHintSummary = document.getElementById("upstreamProviderHintSummary");
	    const upstreamStatus = document.getElementById("upstreamStatus");
	    const upstreamIssueResult = document.getElementById("upstreamIssueResult");
	    const upstreamIssueMessage = document.getElementById("upstreamIssueMessage");
	    const upstreamIssueCta = document.getElementById("upstreamIssueCta");
    const upstreamSummaryStatus = document.getElementById("upstreamSummaryStatus");
    const upstreamSummaryBaseUrl = document.getElementById("upstreamSummaryBaseUrl");
    const upstreamSummaryProvider = document.getElementById("upstreamSummaryProvider");
    const upstreamSummaryModels = document.getElementById("upstreamSummaryModels");
    const upstreamSummaryTested = document.getElementById("upstreamSummaryTested");
    const policyForm = document.getElementById("policyProfileForm");
    const policyProfileSelect = document.getElementById("policyProfileSelect");
    const policyRestrictedSinks = document.getElementById("policyRestrictedSinks");
    const policyAllowUntrusted = document.getElementById("policyAllowUntrusted");
    const policyChangeReason = document.getElementById("policyChangeReason");
	    const policyStatus = document.getElementById("policyStatus");
	    const policySummarySinks = document.getElementById("policySummarySinks");
	    const policySummaryApprovals = document.getElementById("policySummaryApprovals");
		    const policySummaryUpdated = document.getElementById("policySummaryUpdated");
		    const policyIssueResult = document.getElementById("policyIssueResult");
		    const policyIssueMessage = document.getElementById("policyIssueMessage");
		    const policyIssueCta = document.getElementById("policyIssueCta");
		    const gatewayEnvironment = document.getElementById("gatewayEnvironment");
		    const gatewayToken = document.getElementById("gatewayToken");
	    const gatewayGenerate = document.getElementById("gatewayGenerate");
    const gatewayExpiry = document.getElementById("gatewayExpiry");
    const gatewayNote = document.getElementById("gatewayNote");
    const gatewayPreset = document.getElementById("gatewayPreset");
    const gatewayConfig = document.getElementById("gatewayConfig");
    const gatewayCopy = document.getElementById("gatewayCopy");
    const gatewayCopyStatus = document.getElementById("gatewayCopyStatus");
	    const gatewayTargetUrl = document.getElementById("gatewayTargetUrl");
	    const gatewaySummaryExpiry = document.getElementById("gatewaySummaryExpiry");
	    const gatewaySummaryNote = document.getElementById("gatewaySummaryNote");
		    const gatewayIssuedAt = document.getElementById("gatewayIssuedAt");
		    const gatewayIssueResult = document.getElementById("gatewayIssueResult");
		    const gatewayIssueMessage = document.getElementById("gatewayIssueMessage");
		    const gatewayIssueCta = document.getElementById("gatewayIssueCta");
		    const gatewayHistoryRows = document.getElementById("gatewayHistoryRows");
	    const apiClient = window.apiClient || {};
	    const getApiClient = () => window.apiClient || apiClient;
	    const adminTokenInput = document.getElementById("adminToken");
	    const adminSessionStartBtn = document.getElementById("adminSessionStartBtn");
		    const adminSessionStatus = document.getElementById("adminSessionStatus");
		    const adminSessionBanner = document.getElementById("adminSessionBanner");
		    const adminSessionBannerMessage = document.getElementById("adminSessionBannerMessage");
		    const adminSessionBannerCta = document.getElementById("adminSessionBannerCta");
		    const dangerEnableToggle = document.getElementById("dangerEnableToggle");
	    const dangerZoneOptions = document.getElementById("dangerZoneOptions");
    const dangerDuration = document.getElementById("dangerDuration");
    const dangerPersistentToggle = document.getElementById("dangerPersistentToggle");
    const dangerConsentWrap = document.getElementById("dangerConsentWrap");
	    const dangerConsentToggle = document.getElementById("dangerConsentToggle");
	    const dangerApplyBtn = document.getElementById("dangerApplyBtn");
	    const dangerDisableBtn = document.getElementById("dangerDisableBtn");
	    const dangerStatus = document.getElementById("dangerStatus");
	    const diagnosticsRunBtn = document.getElementById("diagnosticsRunBtn");
	    const diagnosticsCopyBtn = document.getElementById("diagnosticsCopyBtn");
	    const diagnosticsDownloadBtn = document.getElementById("diagnosticsDownloadBtn");
	    const diagnosticsResult = document.getElementById("diagnosticsResult");
	    const diagnosticsCta = document.getElementById("diagnosticsCta");
	    const getWizardAdminToken = () => document.getElementById("wizardAdminToken");
	    let upstreamHasKey = false;
	    let gatewayTokensAuthRequired = false;
	    const UPSTREAM_DRAFT_KEY = "suite_upstream_draft";
	    window.SUITE_DIAGNOSTICS_STATE = window.SUITE_DIAGNOSTICS_STATE || { mode: "idle", data: null, errorKey: "" };

		    function storage() {
		      try { return window.localStorage; } catch (e) { return null; }
		    }

    // SaaS mode: hide admin token UI elements
    function applySaasModeRestrictions() {
      const client = getApiClient();
      if (!client.isSaasMode || !client.isSaasMode()) return;
      // Hide Admin Session section (adminToken input, danger zone)
      const adminSessionGroup = document.getElementById("adminSessionGroup");
      if (adminSessionGroup) adminSessionGroup.style.display = "none";
      // Hide wizard token guide (admin token input in wizard)
      const wizardTokenGuide = document.getElementById("wizardTokenGuide");
      if (wizardTokenGuide) wizardTokenGuide.style.display = "none";
      // Hide admin session banner (CTA to enter admin token)
      const adminSessionBannerEl = document.getElementById("adminSessionBanner");
      if (adminSessionBannerEl) adminSessionBannerEl.style.display = "none";
    }
    applySaasModeRestrictions();

    function isSaasMode() {
      const client = getApiClient();
      return client.isSaasMode && client.isSaasMode();
    }

			    function hideAdminSessionBanner() {
			      if (!adminSessionBanner || !adminSessionBannerMessage) return;
			      adminSessionBanner.style.display = "none";
			      adminSessionBannerMessage.textContent = "";
			      delete adminSessionBannerMessage.dataset.labelKey;
			      configureWizardCta(adminSessionBannerCta, "", "");
			    }

			    function showAdminSessionBanner(labelKey) {
			      if (!adminSessionBanner || !adminSessionBannerMessage) return;
			      // Do not show admin session banner in SaaS mode
			      if (isSaasMode()) return;
			      const key = labelKey || "adminSessionBannerDetail";
			      adminSessionBanner.style.display = "block";
			      adminSessionBannerMessage.textContent = t(key);
			      adminSessionBannerMessage.dataset.labelKey = key;
			      configureWizardCta(adminSessionBannerCta, "adminSession", "ctaGoToAdminSession");
			    }

			    function ensureExpanded(section) {
			      const header = document.querySelector(`.collapsible-header[data-section="${section}"]`);
			      const card = header ? header.closest(".card.form-card") : null;
			      const body = card ? card.querySelector(".collapsible-body") : null;
			      if (!card || !body) return;
			      if (body.classList.contains("collapsed")) {
			        body.classList.remove("collapsed");
			        card.classList.remove("collapsed");
			        try { window.localStorage.setItem(`collapse_${section}`, "0"); } catch (e) { }
			      }
			    }

			    function focusAdminSession() {
			      ensureExpanded("upstream");
			      if (adminTokenInput && typeof adminTokenInput.scrollIntoView === "function") {
			        try { adminTokenInput.scrollIntoView({ behavior: "smooth", block: "center" }); } catch (e) { }
			        try { adminTokenInput.focus(); } catch (e) { }
			      }
			    }

			    function focusEnvironments() {
			      ensureExpanded("env");
			      if (nameInput && typeof nameInput.scrollIntoView === "function") {
			        try { nameInput.scrollIntoView({ behavior: "smooth", block: "center" }); } catch (e) { }
			        try { nameInput.focus(); } catch (e) { }
			      }
			    }

			    function focusDiagnostics() {
			      ensureExpanded("diagnostics");
			      if (diagnosticsRunBtn && typeof diagnosticsRunBtn.scrollIntoView === "function") {
			        try { diagnosticsRunBtn.scrollIntoView({ behavior: "smooth", block: "center" }); } catch (e) { }
			        try { diagnosticsRunBtn.focus(); } catch (e) { }
			      }
			    }

      const wizardAutostartGuide = document.getElementById('wizardAutostartGuide');
      const wizardTokenInput = document.getElementById('wizardTokenInput');
      const wizardTokenCopyBtn = document.getElementById('wizardTokenCopyBtn');
      const wizardTokenCommand = document.getElementById('wizardTokenCommand');
      const wizardTokenStartBtn = document.getElementById('wizardTokenStartBtn');

      function showWizardAutostartGuide() {
        if (!wizardAutostartGuide) return;
        wizardAutostartGuide.style.display = "block";
        if (typeof wizardAutostartGuide.scrollIntoView === "function") {
          try { wizardAutostartGuide.scrollIntoView({ behavior: "smooth", block: "center" }); } catch (e) { }
        }
      }

      function updateWizardTokenCommand() {
        if (!wizardTokenCommand) return;
        const token = wizardTokenInput ? wizardTokenInput.value.trim() : "";
        const displayToken = token || '<token>';
        wizardTokenCommand.textContent = `export MCP_GATEWAY_ADMIN_TOKEN="${displayToken}"`;
      }

      if (wizardTokenInput) {
        wizardTokenInput.addEventListener('input', () => {
          updateWizardTokenCommand();
        });
      }
      if (wizardTokenCopyBtn) {
        wizardTokenCopyBtn.addEventListener('click', async () => {
          try {
            const text = wizardTokenCommand ? wizardTokenCommand.textContent : '';
            if (text && navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
            }
          } catch (e) {}
        });
      }
      if (wizardTokenStartBtn) {
        wizardTokenStartBtn.addEventListener('click', () => {
          if (typeof startAdminSession === 'function') {
            startAdminSession();
          }
        });
      }
      updateWizardTokenCommand();

			    function runWizardCtaAction(action) {
			      if (action === "adminSession") focusAdminSession();
			      else if (action === "env") focusEnvironments();
			      else if (action === "diagnostics") focusDiagnostics();
			      else if (action === "wizard") {
			        if (typeof window.openWizard === "function") {
			          window.openWizard(1);
			        }
			      }
			      else if (action === "autostart") showWizardAutostartGuide();
			    }

			    function configureWizardCta(btn, action, labelKey) {
			      if (!btn) return;
			      if (!action || !labelKey) {
			        btn.style.display = "none";
			        btn.textContent = "";
			        btn.onclick = null;
			        delete btn.dataset.action;
			        delete btn.dataset.labelKey;
			        return;
			      }
			      btn.style.display = "inline-flex";
			      btn.dataset.action = action;
			      btn.dataset.labelKey = labelKey;
			      btn.textContent = t(labelKey);
			      btn.onclick = (e) => {
			        e.preventDefault();
			        runWizardCtaAction(action);
			      };
			    }

			    function updatePolicyIssueCta(labelKey) {
			      if (!policyIssueCta) return;
			      if (labelKey === "policyIssueAdminDetail") {
			        configureWizardCta(policyIssueCta, "adminSession", "ctaGoToAdminSession");
			        return;
			      }
			      if (["policyIssueGatewayOffline", "policyIssueApiMissing", "policyIssueServerError"].includes(labelKey || "")) {
			        configureWizardCta(policyIssueCta, "diagnostics", "ctaRunDiagnostics");
			        return;
			      }
			      configureWizardCta(policyIssueCta, "", "");
			    }

			    function updateGatewayIssueCta(labelKey) {
			      if (!gatewayIssueCta) return;
			      if (labelKey === "gatewayIssueAdminDetail") {
			        configureWizardCta(gatewayIssueCta, "adminSession", "ctaGoToAdminSession");
			        return;
			      }
			      if (["gatewayIssueEnvMissing", "copyStatusSelectEnv"].includes(labelKey || "")) {
			        configureWizardCta(gatewayIssueCta, "env", "ctaGoToEnvironments");
			        return;
			      }
			      if (["gatewayIssueGatewayOffline", "gatewayIssueApiMissing", "gatewayIssueServerError"].includes(labelKey || "")) {
			        configureWizardCta(gatewayIssueCta, "diagnostics", "ctaRunDiagnostics");
			        return;
			      }
			      configureWizardCta(gatewayIssueCta, "", "");
			    }

			    function escapeHtml(text) {
			      return String(text || "")
		        .replaceAll("&", "&amp;")
		        .replaceAll("<", "&lt;")
	        .replaceAll(">", "&gt;")
	        .replaceAll('"', "&quot;")
	        .replaceAll("'", "&#39;");
	    }

	    function setDiagnosticsState(next) {
	      window.SUITE_DIAGNOSTICS_STATE = next;
	    }

	    function formatDiagnosticsTimestamp(iso) {
	      if (!iso) return "";
	      try {
	        const d = new Date(String(iso));
	        if (Number.isNaN(d.getTime())) return String(iso);
	        return d.toLocaleString();
	      } catch (e) {
	        return String(iso);
	      }
	    }

	    function diagnosticsPill(kind, label, title) {
	      const safeKind = ["ok", "warn", "bad", "na"].includes(kind) ? kind : "na";
	      const titleAttr = title ? ` title="${escapeHtml(title)}"` : "";
	      return `<span class="diagnostics-pill ${safeKind}"${titleAttr}>${escapeHtml(label)}</span>`;
	    }

	    function normalizeSignatureKind(raw) {
	      const value = String(raw || "").trim();
	      if (!value) return { kind: "na", label: t("diagnosticsNA"), raw: "" };
	      if (value === "verified") return { kind: "ok", label: t("diagnosticsVerified"), raw: value };
	      const prefix = value.split(":")[0];
	      if (prefix === "skip") return { kind: "warn", label: t("diagnosticsNotVerified"), raw: value };
	      if (prefix === "failed" || prefix === "error") return { kind: "bad", label: t("diagnosticsInvalid"), raw: value };
	      return { kind: "na", label: t("diagnosticsNA"), raw: value };
	    }

	    function normalizePresentValue(status) {
	      if (!status) return null;
	      if (typeof status.policy_bundle_present_ok === "boolean") return status.policy_bundle_present_ok;
	      if (!Object.prototype.hasOwnProperty.call(status, "policy_bundle_present_ok") &&
	        typeof status.policy_bundle_hash_ok === "boolean") {
	        return status.policy_bundle_hash_ok;
	      }
	      return null;
	    }

	    function computeDiagnosticsSummary(data) {
	      const upstream = (data && data.upstream) || {};
	      const tokens = (data && data.tokens) || {};
	      const allowlistStatus = (data && data.allowlist_status) || {};
	      const upstreamOk = upstream.configured && upstream.status === "ok";
	      const upstreamWarn = !upstreamOk;
	      const active = (tokens.by_status && Number(tokens.by_status.active)) || 0;
	      const tokensOk = active > 0;
	      const present = normalizePresentValue(allowlistStatus);
	      const sig = normalizeSignatureKind(allowlistStatus.policy_bundle_signature_status);
	      const shadowOk = allowlistStatus.shadow_audit_chain_ok;

	      const hasBad =
	        (upstream.configured && upstream.status === "error") ||
	        present === false ||
	        sig.kind === "bad";
	      const hasWarn =
	        upstreamWarn ||
	        !tokensOk ||
	        shadowOk === false ||
	        (present === true && sig.kind === "warn") ||
	        present === null;

	      if (hasBad) return { kind: "bad", label: t("diagnosticsSummaryBad") };
	      if (hasWarn) return { kind: "warn", label: t("diagnosticsSummaryWarn") };
	      return { kind: "ok", label: t("diagnosticsSummaryOk") };
	    }

	    function renderDiagnostics() {
	      if (!diagnosticsResult) return;
	      const state = window.SUITE_DIAGNOSTICS_STATE || { mode: "idle", data: null, errorKey: "" };

	      if (state.mode === "idle") {
	        diagnosticsResult.style.display = "none";
	        if (diagnosticsCopyBtn) diagnosticsCopyBtn.style.display = "none";
	        if (diagnosticsDownloadBtn) diagnosticsDownloadBtn.style.display = "none";
	        if (diagnosticsCta) configureWizardCta(diagnosticsCta, "", "");
	        return;
	      }

	      diagnosticsResult.style.display = "grid";
	      if (state.mode === "error") {
	        const msg = t(state.errorKey || "diagnosticsErrorUnavailable");
	        diagnosticsResult.innerHTML = `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsResultLabel"))}</div><div class="diagnostics-value">${diagnosticsPill("bad", t("diagnosticsSummaryBad"))}<span class="note-text">${escapeHtml(msg)}</span></div></div>`;
	        if (diagnosticsCopyBtn) diagnosticsCopyBtn.style.display = "none";
	        if (diagnosticsDownloadBtn) diagnosticsDownloadBtn.style.display = "none";
	        if (diagnosticsCta) {
	          let action = "";
	          let labelKey = "";
	          if (state.errorKey === "diagnosticsErrorAuth") {
	            action = "adminSession";
	            labelKey = "ctaGoToAdminSession";
	          } else if (state.errorKey === "diagnosticsErrorGateway") {
	            action = "wizard";
	            labelKey = "ctaOpenWizard";
	          } else if (state.errorKey === "diagnosticsErrorUnavailable") {
	            action = "wizard";
	            labelKey = "ctaOpenWizard";
	          }
	          configureWizardCta(diagnosticsCta, action, labelKey);
	        }
	        return;
	      }

	      const data = state.data || {};
	      const summary = computeDiagnosticsSummary(data);
	      const upstream = data.upstream || {};
	      const tokens = data.tokens || {};
	      const allowlistStatus = data.allowlist_status || {};

	      const upstreamPill =
	        upstream.status === "ok"
	          ? diagnosticsPill("ok", t("statusActive"))
	          : upstream.status === "error"
	            ? diagnosticsPill("bad", t("statusError"))
	            : diagnosticsPill("warn", t("statusNotTested"));

	      const active = (tokens.by_status && Number(tokens.by_status.active)) || 0;
	      const total = Number(tokens.total) || 0;
	      const tokenLabel = `${t("statusActive")}: ${active}/${total}`;
	      const tokensPill = active > 0 ? diagnosticsPill("ok", tokenLabel) : diagnosticsPill("warn", tokenLabel);

	      const present = normalizePresentValue(allowlistStatus);
	      const presentPill =
	        present === true
	          ? diagnosticsPill("ok", t("diagnosticsPresent"))
	          : present === false
	            ? diagnosticsPill("bad", t("diagnosticsMissing"))
	            : diagnosticsPill("na", t("diagnosticsNA"));

	      const sigRaw = String(allowlistStatus.policy_bundle_signature_status || "");
	      const sigNorm = normalizeSignatureKind(sigRaw);
	      let signaturePill = diagnosticsPill("na", t("diagnosticsNA"), sigRaw);
	      if (present === false) {
	        signaturePill = diagnosticsPill("na", t("diagnosticsNA"), sigRaw);
	      } else if (present === null && sigRaw.startsWith("skip:bundle_missing")) {
	        signaturePill = diagnosticsPill("na", t("diagnosticsNA"), sigRaw);
	      } else if (present === true) {
	        signaturePill = diagnosticsPill(sigNorm.kind, sigNorm.label, sigNorm.raw);
	      }

	      const shadowOk = allowlistStatus.shadow_audit_chain_ok;
	      const shadowPill =
	        shadowOk === true
	          ? diagnosticsPill("ok", t("statusActive"))
	          : shadowOk === false
	            ? diagnosticsPill("warn", t("statusError"))
	            : diagnosticsPill("na", t("diagnosticsNA"));

	      const updated = formatDiagnosticsTimestamp(data.ts);
	      const upstreamMeta = upstream.base_url ? `<code>${escapeHtml(upstream.base_url)}</code>` : `<span>${escapeHtml(t("notSet"))}</span>`;

	      diagnosticsResult.innerHTML = [
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsResultLabel"))}</div><div class="diagnostics-value">${diagnosticsPill(summary.kind, summary.label)}</div></div>`,
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsUpdatedLabel"))}</div><div class="diagnostics-value"><span class="summary-mono">${escapeHtml(updated || t("notSet"))}</span></div></div>`,
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsUpstream"))}</div><div class="diagnostics-value">${upstreamPill}${upstreamMeta}</div></div>`,
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsTokens"))}</div><div class="diagnostics-value">${tokensPill}</div></div>`,
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsPolicyBundle"))}</div><div class="diagnostics-value">${presentPill}${signaturePill}</div></div>`,
	        `<div class="diagnostics-row"><div class="diagnostics-key">${escapeHtml(t("diagnosticsShadowAudit"))}</div><div class="diagnostics-value">${shadowPill}</div></div>`
	      ].join("");

	      if (diagnosticsCopyBtn) diagnosticsCopyBtn.style.display = "";
	      if (diagnosticsDownloadBtn) diagnosticsDownloadBtn.style.display = "";
	      if (diagnosticsCta) configureWizardCta(diagnosticsCta, "", "");
	    }

	    async function copyDiagnosticsJson() {
	      const state = window.SUITE_DIAGNOSTICS_STATE || { mode: "idle", data: null };
	      if (!diagnosticsCopyBtn || state.mode !== "data" || !state.data) return;
	      const text = JSON.stringify(state.data, null, 2);
	      const original = diagnosticsCopyBtn.textContent;
	      try {
	        if (navigator.clipboard && navigator.clipboard.writeText) {
	          await navigator.clipboard.writeText(text);
	        } else if (document.execCommand) {
	          const ta = document.createElement("textarea");
	          ta.value = text;
	          ta.setAttribute("readonly", "readonly");
	          ta.style.position = "absolute";
	          ta.style.left = "-9999px";
	          document.body.appendChild(ta);
	          ta.select();
	          document.execCommand("copy");
	          document.body.removeChild(ta);
	        }
	        diagnosticsCopyBtn.textContent = t("diagnosticsCopyDone");
	        setTimeout(() => { diagnosticsCopyBtn.textContent = original || t("diagnosticsCopyBtn"); }, 1200);
	      } catch (e) { }
	    }

	    function downloadDiagnosticsJson() {
	      const state = window.SUITE_DIAGNOSTICS_STATE || { mode: "idle", data: null };
	      if (!diagnosticsDownloadBtn || state.mode !== "data" || !state.data) return;
	      const json = JSON.stringify(state.data, null, 2);
	      const ts = String((state.data && state.data.ts) || "").replaceAll(":", "").replaceAll(".", "");
	      const name = ts ? `mcp_gateway_diagnostics_${ts}.json` : "mcp_gateway_diagnostics.json";
	      try {
	        const blob = new Blob([json], { type: "application/json" });
	        const url = URL.createObjectURL(blob);
	        const a = document.createElement("a");
	        a.href = url;
	        a.download = name;
	        document.body.appendChild(a);
	        a.click();
	        a.remove();
	        setTimeout(() => URL.revokeObjectURL(url), 5000);
	        const original = diagnosticsDownloadBtn.textContent;
	        diagnosticsDownloadBtn.textContent = t("diagnosticsDownloadDone");
	        setTimeout(() => { diagnosticsDownloadBtn.textContent = original || t("diagnosticsDownloadBtn"); }, 1200);
	      } catch (e) { }
	    }

	    async function runDiagnostics() {
	      if (!diagnosticsRunBtn) return;
	      const client = getApiClient();
	      const buildFallbackDiagnostics = async () => {
	        const ts = new Date().toISOString();
	        const [upstreamRes, tokensRes, allowlistStatus] = await Promise.all([
	          client.fetchControlUpstream
	            ? client.fetchControlUpstream()
	            : Promise.resolve({ ok: false, status: 0, data: null, errorType: "other" }),
	          client.listControlTokens
	            ? client.listControlTokens()
	            : Promise.resolve({ ok: false, status: 0, data: null, errorType: "other" }),
	          client.fetchAllowlistStatus ? client.fetchAllowlistStatus() : Promise.resolve(null),
	        ]);

	        const failures = [upstreamRes, tokensRes].filter((res) => res && !res.ok);
	        if (failures.some((res) => res.errorType === "auth")) {
	          return { ok: false, errorKey: "diagnosticsErrorAuth" };
	        }
	        if (failures.some((res) => res.errorType === "timeout" || res.errorType === "network" || res.errorType === "server")) {
	          return { ok: false, errorKey: "diagnosticsErrorGateway" };
	        }
	        if (failures.length > 0) {
	          return { ok: false, errorKey: "diagnosticsErrorUnavailable" };
	        }

	        const upstreamData = (upstreamRes && upstreamRes.data) || {};
	        const baseUrl = String(upstreamData.base_url || "").trim();
	        const lastTested = String(upstreamData.last_tested || "");
	        const statusRaw = String(upstreamData.status || "");
	        const isFresh = (() => {
	          if (!lastTested) return false;
	          const parsed = Date.parse(lastTested);
	          if (!Number.isFinite(parsed)) return false;
	          return Date.now() - parsed <= 3600 * 1000;
	        })();
	        let upstreamStatus = "unknown";
	        if (baseUrl) {
	          if (statusRaw === "ok") {
	            upstreamStatus = isFresh ? "ok" : "unknown";
	          } else if (statusRaw) {
	            upstreamStatus = statusRaw;
	          }
	        }

	        const tokens = Array.isArray(tokensRes && tokensRes.data) ? tokensRes.data : [];
	        const byStatus = { active: 0, expired: 0, revoked: 0 };
	        tokens.forEach((row) => {
	          const s = row && row.status;
	          if (s === "active" || s === "expired" || s === "revoked") {
	            byStatus[s] += 1;
	          }
	        });

	        return {
	          ok: true,
	          data: {
	            ts,
	            upstream: {
	              configured: Boolean(baseUrl),
	              status: upstreamStatus,
	              base_url: baseUrl,
	              last_tested: lastTested,
	            },
	            tokens: {
	              total: tokens.length,
	              by_status: byStatus,
	            },
	            allowlist_status: allowlistStatus || {},
	          },
	        };
	      };

	      const original = diagnosticsRunBtn.textContent;
	      diagnosticsRunBtn.disabled = true;
	      diagnosticsRunBtn.textContent = t("diagnosticsRunning");
	      try {
	        const res = client.fetchControlDiagnostics ? await client.fetchControlDiagnostics() : null;
	        if (res && res.ok) {
	          setDiagnosticsState({ mode: "data", data: res.data, errorKey: "" });
	          hideAdminSessionBanner();
	          renderDiagnostics();
	          return;
	        }
	        if (res && res.errorType === "auth") {
	          setDiagnosticsState({ mode: "error", data: null, errorKey: "diagnosticsErrorAuth" });
	          showAdminSessionBanner("adminSessionBannerDetail");
	          renderDiagnostics();
	          return;
	        }

	        const fallback = await buildFallbackDiagnostics();
	        if (fallback && fallback.ok) {
	          setDiagnosticsState({ mode: "data", data: fallback.data, errorKey: "" });
	          hideAdminSessionBanner();
	          renderDiagnostics();
	          return;
	        }
	        const key = (fallback && fallback.errorKey) || "diagnosticsErrorUnavailable";
	        setDiagnosticsState({ mode: "error", data: null, errorKey: key });
	        if (key === "diagnosticsErrorAuth") {
	          showAdminSessionBanner("adminSessionBannerDetail");
	        }
	        renderDiagnostics();
	      } catch (e) {
	        setDiagnosticsState({ mode: "error", data: null, errorKey: "diagnosticsErrorGateway" });
	        renderDiagnostics();
	      } finally {
	        diagnosticsRunBtn.disabled = false;
	        diagnosticsRunBtn.textContent = original || t("diagnosticsRunBtn");
	      }
	    }

	    if (diagnosticsRunBtn) diagnosticsRunBtn.addEventListener("click", runDiagnostics);
	    if (diagnosticsCopyBtn) diagnosticsCopyBtn.addEventListener("click", copyDiagnosticsJson);
	    if (diagnosticsDownloadBtn) diagnosticsDownloadBtn.addEventListener("click", downloadDiagnosticsJson);

    function normalizeDraftValue(value) {
      return String(value || "").trim();
    }

    function getUpstreamDraft() {
      const s = storage();
      if (!s) return null;
      try {
        const raw = s.getItem(UPSTREAM_DRAFT_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        return {
          base_url: normalizeDraftValue(parsed.base_url),
          provider: normalizeDraftValue(parsed.provider),
          models: normalizeDraftValue(parsed.models),
        };
      } catch (e) {
        return null;
      }
    }

    function setUpstreamDraft(draft) {
      const s = storage();
      if (!s) return;
      const baseUrl = normalizeDraftValue(draft && draft.base_url);
      const provider = normalizeDraftValue(draft && draft.provider);
      const models = normalizeDraftValue(draft && draft.models);
      if (!baseUrl && !provider && !models) {
        s.removeItem(UPSTREAM_DRAFT_KEY);
        return;
      }
      s.setItem(UPSTREAM_DRAFT_KEY, JSON.stringify({
        base_url: baseUrl,
        provider,
        models,
      }));
    }

	    function mergeUpstreamDraft(update) {
	      const current = getUpstreamDraft() || {};
	      const merged = {
	        base_url: current.base_url || "",
	        provider: current.provider || "",
	        models: current.models || "",
	      };
      const nextBase = normalizeDraftValue(update && update.base_url);
      const nextProvider = normalizeDraftValue(update && update.provider);
      const nextModels = normalizeDraftValue(update && update.models);
      if (nextBase) merged.base_url = nextBase;
      if (nextProvider) merged.provider = nextProvider;
      if (nextModels) merged.models = nextModels;
	      setUpstreamDraft(merged);
	    }

	    const UPSTREAM_PRESETS = {
	      openai_compatible: {
	        base_url: "",
	        models: "",
	      },
	      openai: {
	        base_url: "https://api.openai.com/v1",
	        models: "gpt-4o-mini,gpt-4o",
	      },
	      gemini_openai: {
	        base_url: "https://generativelanguage.googleapis.com/v1beta/openai",
	        models: "models/gemini-flash-latest,models/gemini-pro-latest",
	      },
	      vertex: {
	        base_url: "https://generativelanguage.googleapis.com/v1beta/openai",
	        models: "models/gemini-flash-latest,models/gemini-pro-latest",
	      },
	      anthropic_openai: {
	        base_url: "http://127.0.0.1:4000",
	        models: "claude-3-5-sonnet-latest",
	      },
	      ollama: {
	        base_url: "http://127.0.0.1:11434/v1",
	        models: "qwen2:0.5b",
	      },
	    };

	    function normalizeProviderForUi(value) {
	      const trimmed = normalizeDraftValue(value);
	      if (!trimmed) return "";
	      if (trimmed === "gemini") return "gemini_openai";
	      return trimmed;
	    }

	    function isKnownProviderOption(value) {
	      if (!upstreamProvider) return false;
	      return Array.from(upstreamProvider.options).some((opt) => opt.value === value);
	    }

	    function syncUpstreamProviderCustomVisibility() {
	      if (!upstreamProviderCustomWrap || !upstreamProvider) return;
	      const isCustom = upstreamProvider.value === "custom";
	      upstreamProviderCustomWrap.style.display = isCustom ? "block" : "none";
	    }

	    function getSelectedUpstreamProvider() {
	      if (!upstreamProvider) return "";
	      const selected = upstreamProvider.value;
	      if (selected === "custom") {
	        return normalizeDraftValue(upstreamProviderCustom ? upstreamProviderCustom.value : "");
	      }
	      return selected;
	    }

	    function setUpstreamProviderUi(providerValue, options) {
	      if (!upstreamProvider) return;
	      const preferExisting = options && options.preferExisting;
	      const current = upstreamProvider.value;
	      if (preferExisting && current) {
	        syncUpstreamProviderCustomVisibility();
	        return;
	      }
	      const normalized = normalizeProviderForUi(providerValue);
	      if (normalized && isKnownProviderOption(normalized) && normalized !== "custom") {
	        upstreamProvider.value = normalized;
	        if (upstreamProviderCustom) upstreamProviderCustom.value = "";
	        syncUpstreamProviderCustomVisibility();
	        return;
	      }
	      if (normalized) {
	        upstreamProvider.value = "custom";
	        if (upstreamProviderCustom) upstreamProviderCustom.value = normalized;
	      } else {
	        upstreamProvider.value = "openai_compatible";
	        if (upstreamProviderCustom) upstreamProviderCustom.value = "";
	      }
	      syncUpstreamProviderCustomVisibility();
	    }

		    function guessPresetProviderByBaseUrl(value) {
		      const current = String(value || "").trim();
		      if (!current) return "";
		      for (const key of Object.keys(UPSTREAM_PRESETS)) {
		        const preset = UPSTREAM_PRESETS[key];
		        if (preset && preset.base_url && preset.base_url === current) return key;
		      }
		      return "";
		    }

		    function guessPresetProviderByModels(value) {
		      const current = String(value || "").trim();
		      if (!current) return "";
		      for (const key of Object.keys(UPSTREAM_PRESETS)) {
		        const preset = UPSTREAM_PRESETS[key];
		        if (preset && preset.models && preset.models === current) return key;
		      }
		      return "";
		    }

		    function maybeApplyUpstreamPreset(providerKey, options) {
		      const force = options && options.force;
		      const preset = UPSTREAM_PRESETS[providerKey];
		      if (!preset) return;
		      if (upstreamBaseUrl && preset.base_url) {
		        const current = upstreamBaseUrl.value.trim();
		        const isPresetValue =
		          (upstreamBaseUrl.dataset && upstreamBaseUrl.dataset.presetProvider) ||
		          guessPresetProviderByBaseUrl(current);
		        if (!current || (force && isPresetValue)) {
		          upstreamBaseUrl.value = preset.base_url;
		          if (upstreamBaseUrl.dataset) upstreamBaseUrl.dataset.presetProvider = providerKey;
		        }
		      }
		      if (upstreamModels && preset.models) {
		        const current = upstreamModels.value.trim();
		        const isPresetValue =
		          (upstreamModels.dataset && upstreamModels.dataset.presetProvider) ||
		          guessPresetProviderByModels(current);
		        if (!current || (force && isPresetValue)) {
		          upstreamModels.value = preset.models;
		          if (upstreamModels.dataset) upstreamModels.dataset.presetProvider = providerKey;
		        }
		      }
		    }

		    function escapeHtml(value) {
		      return String(value || "")
		        .replace(/&/g, "&amp;")
		        .replace(/</g, "&lt;")
		        .replace(/>/g, "&gt;")
		        .replace(/"/g, "&quot;")
		        .replace(/'/g, "&#39;");
		    }

		    function getUpstreamProviderHintBodyKey(providerKey) {
		      if (providerKey === "openai") return "upstreamProviderHintBodyOpenAI";
		      if (providerKey === "gemini_openai") return "upstreamProviderHintBodyGemini";
		      if (providerKey === "vertex") return "upstreamProviderHintBodyVertex";
		      if (providerKey === "anthropic_openai") return "upstreamProviderHintBodyAnthropic";
		      if (providerKey === "ollama") return "upstreamProviderHintBodyOllama";
		      if (providerKey === "custom") return "upstreamProviderHintBodyCustom";
		      return "upstreamProviderHintBodyOpenAICompatible";
		    }

		    function renderUpstreamProviderHint() {
		      if (!upstreamProviderHintBody || !upstreamProviderHintSummary || !upstreamProvider) return;

		      const selected = upstreamProvider.value;
		      const isCustom = selected === "custom";
		      const providerKey = isCustom ? "custom" : selected;
		      const customProvider = isCustom ? normalizeDraftValue(upstreamProviderCustom ? upstreamProviderCustom.value : "") : "";
		      const presetKey = isCustom ? "openai_compatible" : providerKey;
		      const preset = UPSTREAM_PRESETS[presetKey] || { base_url: "", models: "" };

		      upstreamProviderHintSummary.textContent = t("upstreamProviderHintSummary");

		      const baseUrlValue = preset.base_url ? `<code>${escapeHtml(preset.base_url)}</code>` : `<span class="provider-hint-muted">${escapeHtml(t("notSet"))}</span>`;
		      const modelsValue = preset.models ? `<code>${escapeHtml(preset.models)}</code>` : `<span class="provider-hint-muted">${escapeHtml(t("notSet"))}</span>`;

		      const providerBodyKey = getUpstreamProviderHintBodyKey(providerKey);
		      const apiKeyLine = presetKey === "ollama" ? t("upstreamProviderHintApiKeyOptional") : t("upstreamProviderHintApiKeyRequired");

		      const customLine = customProvider
		        ? `<li>${escapeHtml(t("upstreamProviderCustomLabel"))}: <code>${escapeHtml(customProvider)}</code></li>`
		        : "";

		      upstreamProviderHintBody.innerHTML = [
		        `<div>${escapeHtml(t("upstreamProviderHintIntro"))}</div>`,
		        `<ul>`,
		        `<li>${escapeHtml(t(providerBodyKey))}</li>`,
		        `<li>${escapeHtml(apiKeyLine)}</li>`,
		        customLine,
		        `</ul>`,
		        `<div style="margin-top:6px;"><strong>${escapeHtml(t("upstreamProviderHintDefaults"))}</strong></div>`,
		        `<div>${escapeHtml(t("upstreamBaseUrlLabel"))}: ${baseUrlValue}</div>`,
		        `<div>${escapeHtml(t("upstreamModelsLabel"))}: ${modelsValue}</div>`,
		      ].filter(Boolean).join("");
		    }

		    function handleUpstreamProviderChanged() {
		      syncUpstreamProviderCustomVisibility();
		      if (!upstreamProvider) return;
		      const selected = upstreamProvider.value;
		      // Force defaults on provider change (but keep user edits: preset values are cleared on input)
		      if (selected !== "custom" && selected !== "openai_compatible") {
		        maybeApplyUpstreamPreset(selected, { force: true });
		      } else if (selected !== "custom") {
		        maybeApplyUpstreamPreset(selected, { force: false });
		      }
		      renderUpstreamProviderHint();
		      saveUpstreamDraftFromInputs();
		    }

	    function applyUpstreamDraftToInputs(draft, options) {
	      if (!draft) return;
	      const preferExisting = options && options.preferExisting;
	      const currentBase = upstreamBaseUrl ? upstreamBaseUrl.value.trim() : "";
	      const currentProvider = upstreamProvider ? upstreamProvider.value : "";
	      const currentModels = upstreamModels ? upstreamModels.value.trim() : "";
	      if (upstreamBaseUrl && (!preferExisting || !currentBase)) {
	        upstreamBaseUrl.value = draft.base_url || "";
	      }
	      if (upstreamProvider && (!preferExisting || !currentProvider)) {
	        setUpstreamProviderUi(draft.provider || "openai_compatible", { preferExisting: false });
	      }
	      if (upstreamModels && (!preferExisting || !currentModels)) {
	        upstreamModels.value = draft.models || "";
	      }
	    }

	    function saveUpstreamDraftFromInputs() {
	      setUpstreamDraft({
	        base_url: upstreamBaseUrl ? upstreamBaseUrl.value : "",
	        provider: getSelectedUpstreamProvider(),
	        models: upstreamModels ? upstreamModels.value : "",
	      });
	    }

		    function bindUpstreamDraftListeners() {
		      if (upstreamBaseUrl) upstreamBaseUrl.addEventListener("input", () => {
		        if (upstreamBaseUrl.dataset) delete upstreamBaseUrl.dataset.presetProvider;
		        saveUpstreamDraftFromInputs();
		      });
		      if (upstreamModels) upstreamModels.addEventListener("input", () => {
		        if (upstreamModels.dataset) delete upstreamModels.dataset.presetProvider;
		        saveUpstreamDraftFromInputs();
		      });
		      if (upstreamProvider) upstreamProvider.addEventListener("change", handleUpstreamProviderChanged);
		      if (upstreamProviderCustom) upstreamProviderCustom.addEventListener("input", () => {
		        saveUpstreamDraftFromInputs();
		        renderUpstreamProviderHint();
		      });
		      syncUpstreamProviderCustomVisibility();
		    }

    function statusClass(status) {
      if (status === "active") return "active";
      if (status === "error") return "error";
      if (status === "testing") return "testing";
      if (status === "expired") return "error";
      if (status === "revoked") return "error";
      return "inactive";
    }

    function statusLabel(status) {
      if (status === "active") return t("statusActive");
      if (status === "error") return t("statusError");
      if (status === "testing") return t("statusTesting");
      if (status === "expired") return t("statusExpired");
      if (status === "revoked") return t("statusRevoked");
      return t("statusInactive");
    }

    function statusLabelKey(status) {
      if (status === "active") return "statusActive";
      if (status === "error") return "statusError";
      if (status === "testing") return "statusTesting";
      if (status === "expired") return "statusExpired";
      if (status === "revoked") return "statusRevoked";
      if (status === "not_tested") return "statusNotTested";
      return "statusInactive";
    }

    function updateUpstreamApiKeyDisplay(hasKey) {
      if (!upstreamApiKey) return;
      const hint = document.getElementById("upstreamApiKeyHint");
      if (hasKey) {
        upstreamApiKey.placeholder = t("upstreamApiKeyPlaceholderSaved");
        upstreamApiKey.dataset.saved = "true";
        if (hint) hint.textContent = t("upstreamApiKeyHintSaved");
      } else {
        upstreamApiKey.placeholder = t("upstreamApiKeyPlaceholder");
        delete upstreamApiKey.dataset.saved;
        if (hint) hint.textContent = t("upstreamApiKeyHint");
      }
    }

	    function providerLabel(value) {
	      const raw = String(value || "").trim();
	      const lowered = raw.toLowerCase();
	      if (!lowered) return t("notSet");
	      if (lowered === "openai_compatible") return t("providerOpenAICompatible");
	      if (lowered === "openai") return t("providerOpenAI");
	      if (lowered === "gemini_openai" || lowered === "gemini") return t("providerGemini");
	      if (lowered === "vertex") return t("providerVertex");
	      if (lowered === "anthropic_openai") return t("providerAnthropic");
	      if (lowered === "ollama") return t("providerOllama");
	      return raw;
	    }

    function toLocalDatetime(value) {
      if (!value) return "";
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const pad = (num) => String(num).padStart(2, "0");
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
    }

    function toUtcIsoString(value) {
      if (!value) return "";
      const trimmed = String(value).trim();
      if (!trimmed) return "";
      if (/[zZ]$/.test(trimmed) || /[+-]\d{2}:?\d{2}$/.test(trimmed)) {
        const date = new Date(trimmed);
        return Number.isNaN(date.getTime()) ? "" : date.toISOString();
      }
      // Support both "YYYY-MM-DD HH:MM" (text input) and "YYYY-MM-DDTHH:MM" (datetime-local)
      const normalized = trimmed.replace(/\s+/, "T");
      const [datePart, timePart] = normalized.split("T");
      if (!datePart || !timePart) return "";
      const [year, month, day] = datePart.split("-").map((item) => Number(item));
      const [hour, minute] = timePart.split(":").map((item) => Number(item));
      if (
        [year, month, day, hour, minute].some((item) => Number.isNaN(item))
      ) {
        return "";
      }
      const date = new Date(Date.UTC(year, month - 1, day, hour, minute));
      return Number.isNaN(date.getTime()) ? "" : date.toISOString();
    }

    function toUtcDatetime(value) {
      if (!value) return "";
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const pad = (num) => String(num).padStart(2, "0");
      return `${date.getUTCFullYear()}-${pad(date.getUTCMonth() + 1)}-${pad(date.getUTCDate())} ${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}`;
    }

    function setAdminToken(value) {
      const client = getApiClient();
      const trimmed = String(value || "").trim();
      if (client.setAdminToken) {
        client.setAdminToken(trimmed);
        return;
      }
      window.SUITE_ADMIN_TOKEN = trimmed;
    }

    function getAdminTokenValue() {
      const client = getApiClient();
      if (client.getAdminToken) {
        return String(client.getAdminToken() || "").trim();
      }
      const cached = String(window.SUITE_ADMIN_TOKEN || "").trim();
      if (cached) return cached;
      return "";
    }

	    function setInlineStatus(el, message, tone, labelKey, suffix) {
	      if (!el) return;
	      el.textContent = message || "";
	      if (labelKey) {
	        el.dataset.labelKey = labelKey;
	      } else if (el.dataset) {
	        delete el.dataset.labelKey;
	      }
		      if (suffix !== undefined) {
		        if (suffix) {
		          el.dataset.suffix = suffix;
		        } else if (el.dataset) {
		          delete el.dataset.suffix;
		        }
		      } else if (el.dataset) {
		        delete el.dataset.suffix;
		      }
		      if (tone === "success") {
		        el.style.color = "#065f46";
		      } else if (tone === "error") {
	        el.style.color = "#b91c1c";
      } else {
        el.style.color = "";
      }
    }

    function getAdminTokenCandidate() {
      const top = adminTokenInput ? adminTokenInput.value.trim() : "";
      const wizard = getWizardAdminToken();
      const fromWizard = wizard ? wizard.value.trim() : "";
      return top || fromWizard;
    }

    if (adminTokenInput) {
      const syncAdminToken = () => {
        const token = adminTokenInput.value.trim();
        setAdminToken(token);
        const wizardAdminToken = getWizardAdminToken();
        if (wizardAdminToken) {
          wizardAdminToken.value = token;
        }
      };
      adminTokenInput.addEventListener("change", syncAdminToken);
      adminTokenInput.addEventListener("input", syncAdminToken);
    }

    let wizardTokenBound = false;
    function bindWizardTokenSync() {
      if (wizardTokenBound) return true;
      const wizardAdminToken = getWizardAdminToken();
      if (!wizardAdminToken) return false;
      const syncWizardToken = () => {
        const token = wizardAdminToken.value;
        if (adminTokenInput) adminTokenInput.value = token;
        setAdminToken(token.trim());
      };
      wizardAdminToken.addEventListener("change", syncWizardToken);
      wizardAdminToken.addEventListener("input", syncWizardToken);
      wizardTokenBound = true;
      return true;
    }

    if (!bindWizardTokenSync()) {
      window.addEventListener("DOMContentLoaded", bindWizardTokenSync, { once: true });
    }

    async function startAdminSession() {
	      const client = getApiClient();
	      if (!client.createControlSession) {
	        setInlineStatus(adminSessionStatus, t("adminSessionUnavailable"), "error", "adminSessionUnavailable");
	        return;
	      }
      const dangerState = client.getDangerModeState ? client.getDangerModeState() : null;
	      const candidate = getAdminTokenCandidate() || (dangerState ? dangerState.token : "");
	      if (!candidate) {
	        setInlineStatus(adminSessionStatus, t("adminSessionTokenRequired"), "error", "adminSessionTokenRequired");
	        return;
	      }
	      if (adminSessionStartBtn) adminSessionStartBtn.disabled = true;
	      setInlineStatus(adminSessionStatus, t("adminSessionStarting"), "muted", "adminSessionStarting");
	      const res = await client.createControlSession(candidate);
	      if (adminSessionStartBtn) adminSessionStartBtn.disabled = false;
		      if (!res || !res.ok) {
		        const errorKey = res && res.errorType === "auth" ? "adminSessionInvalidToken" : "adminSessionFailed";
		        setInlineStatus(adminSessionStatus, t(errorKey), "error", errorKey);
		        showAdminSessionBanner("adminSessionBannerDetail");
		        return;
		      }
      if (adminTokenInput) adminTokenInput.value = "";
      const wizardAdminToken = getWizardAdminToken();
      if (wizardAdminToken) wizardAdminToken.value = "";
	      setAdminToken("");
		      const expiresAt = res.data && res.data.expires_at ? res.data.expires_at : "";
		      const suffix = expiresAt ? ` (${expiresAt})` : "";
		      setInlineStatus(adminSessionStatus, t("adminSessionEstablished") + suffix, "success", "adminSessionEstablished", suffix);
		      hideAdminSessionBanner();
		      await refreshUpstream();
		      await refreshPolicyProfile();
		      await refreshGatewayTokens();
		    }

    if (adminSessionStartBtn) {
      adminSessionStartBtn.addEventListener("click", startAdminSession);
    }

    function updateDangerZoneVisibility() {
      if (!dangerZoneOptions || !dangerEnableToggle) return;
      dangerZoneOptions.style.display = dangerEnableToggle.checked ? "grid" : "none";
      if (!dangerEnableToggle.checked) {
        if (dangerPersistentToggle) dangerPersistentToggle.checked = false;
        if (dangerConsentToggle) dangerConsentToggle.checked = false;
        if (dangerConsentWrap) dangerConsentWrap.style.display = "none";
      }
    }

    function updateDangerConsentVisibility() {
      if (!dangerConsentWrap || !dangerPersistentToggle) return;
      dangerConsentWrap.style.display = dangerPersistentToggle.checked ? "inline-flex" : "none";
      if (!dangerPersistentToggle.checked && dangerConsentToggle) dangerConsentToggle.checked = false;
    }

    async function applyDangerMode() {
      const client = getApiClient();
      if (!client.enableDangerMode) return;
      if (!dangerDuration) return;
	      const token = getAdminTokenCandidate();
	      if (!token) {
	        setInlineStatus(dangerStatus, t("adminSessionTokenRequired"), "error", "adminSessionTokenRequired");
	        return;
	      }
      const durationValue = dangerDuration.value;
      const durationMs = durationValue === "session" ? null : Number(durationValue) * 1000;
	      const wantsPersistent = Boolean(dangerPersistentToggle && dangerPersistentToggle.checked);
	      if (wantsPersistent && !(dangerConsentToggle && dangerConsentToggle.checked)) {
	        setInlineStatus(dangerStatus, t("dangerConsentRequired"), "error", "dangerConsentRequired");
	        return;
	      }
	      if (dangerApplyBtn) dangerApplyBtn.disabled = true;
	      setInlineStatus(dangerStatus, t("dangerEnabling"), "muted", "dangerEnabling");
      const res = await client.enableDangerMode(token, {
        durationMs,
        storageType: wantsPersistent ? "local" : "session",
      });
	      if (dangerApplyBtn) dangerApplyBtn.disabled = false;
	      if (!res || !res.ok) {
	        setInlineStatus(dangerStatus, t("dangerEnableFailed"), "error", "dangerEnableFailed");
	        return;
	      }
      if (adminTokenInput) adminTokenInput.value = "";
	      const wizardAdminToken = getWizardAdminToken();
	      if (wizardAdminToken) wizardAdminToken.value = "";
	      setAdminToken("");
	      setInlineStatus(dangerStatus, t("dangerEnabled"), "success", "dangerEnabled");
	      await refreshUpstream();
	      await refreshPolicyProfile();
	      await refreshGatewayTokens();
	    }

    function disableDangerModeUi() {
      const client = getApiClient();
      if (client.disableDangerMode) client.disableDangerMode();
	      if (dangerEnableToggle) dangerEnableToggle.checked = false;
	      updateDangerZoneVisibility();
	      updateDangerConsentVisibility();
	      setInlineStatus(dangerStatus, t("dangerDisabled"), "muted", "dangerDisabled");
	    }

    if (dangerEnableToggle) {
      dangerEnableToggle.addEventListener("change", updateDangerZoneVisibility);
      updateDangerZoneVisibility();
    }
    if (dangerPersistentToggle) {
      dangerPersistentToggle.addEventListener("change", updateDangerConsentVisibility);
      updateDangerConsentVisibility();
    }
    if (dangerApplyBtn) dangerApplyBtn.addEventListener("click", applyDangerMode);
    if (dangerDisableBtn) dangerDisableBtn.addEventListener("click", disableDangerModeUi);

    (function initDangerZoneFromState() {
      const client = getApiClient();
	      const state = client.getDangerModeState ? client.getDangerModeState() : null;
	      if (!state || !dangerEnableToggle) return;
      dangerEnableToggle.checked = true;
      updateDangerZoneVisibility();
      if (dangerPersistentToggle) dangerPersistentToggle.checked = state.storageType === "local";
      updateDangerConsentVisibility();
	      setInlineStatus(dangerStatus, t("dangerEnabled"), "success", "dangerEnabled");
	    })();

    function renderUpstreamSummary() {
      const config = window.SUITE_SETTINGS_UPSTREAM || {};
      const status = config.status || "inactive";
      upstreamSummaryStatus.className = `status-indicator ${statusClass(status)}`;
      upstreamSummaryStatus.textContent = statusLabel(status);
      upstreamSummaryStatus.dataset.state = status;
      upstreamSummaryStatus.dataset.labelKey = statusLabelKey(status);
      const providerValue = config.provider ? providerLabel(config.provider) : "";
      setFallbackText(upstreamSummaryBaseUrl, config.base_url, "notSet");
      setFallbackText(upstreamSummaryProvider, providerValue, "notSet");
      const rawModels = config.models || "";
      const models = (Array.isArray(rawModels) ? rawModels : String(rawModels).split(","))
        .map((item) => item.trim())
        .filter(Boolean);
      upstreamSummaryModels.innerHTML = "";
      if (models.length === 0) {
        setFallbackText(upstreamSummaryModels, "", "notSet");
      } else {
        delete upstreamSummaryModels.dataset.fallbackKey;
        for (const model of models) {
          const chip = document.createElement("span");
          chip.className = "summary-chip";
          chip.textContent = model;
          upstreamSummaryModels.appendChild(chip);
        }
      }
      const tested = config.last_tested ? toLocalDatetime(config.last_tested) : "";
      setFallbackText(upstreamSummaryTested, tested, "statusNotTested");
    }

    function setPolicyStatus(state, label, labelKey) {
      if (!policyStatus) return;
      policyStatus.className = `status-indicator ${statusClass(state)}`;
      policyStatus.textContent = label;
      policyStatus.dataset.state = state;
      if (labelKey) {
        policyStatus.dataset.labelKey = labelKey;
      }
    }

    function normalizeSinksInput(value) {
      return String(value || "")
        .split(",")
        .map((item) => item.trim().toLowerCase())
        .filter(Boolean);
    }

    function renderPolicySummary() {
      const config = window.SUITE_SETTINGS_POLICY_PROFILE || {};
      const sinks = Array.isArray(config.restricted_sinks_effective)
        ? config.restricted_sinks_effective
        : [];
      if (policySummarySinks) {
        policySummarySinks.innerHTML = "";
        if (!sinks.length) {
          setFallbackText(policySummarySinks, "", "notSet");
        } else {
          delete policySummarySinks.dataset.fallbackKey;
          for (const sink of sinks) {
            const chip = document.createElement("span");
            chip.className = "summary-chip";
            chip.textContent = sink;
            policySummarySinks.appendChild(chip);
          }
        }
      }
      if (policySummaryApprovals) {
        policySummaryApprovals.textContent = config.allow_untrusted_with_approvals ? t("policySummaryApprovalsEnabled") : t("policySummaryApprovalsDisabled");
      }
      if (policySummaryUpdated) {
        const updated = config.updated_at ? toLocalDatetime(config.updated_at) : "";
        setFallbackText(policySummaryUpdated, updated, "notSet");
      }
    }

    function normalizeUpstreamStatus(value) {
      if (value === "ok") return "active";
      if (value === "error") return "error";
      if (value === "testing") return "testing";
      return "inactive";
    }

    async function refreshUpstream() {
      if (!apiClient.fetchControlUpstream) return;
      const res = await apiClient.fetchControlUpstream();
      if (!res || !res.ok) {
        upstreamHasKey = false;
        updateUpstreamApiKeyDisplay(false);
	        if (res && res.errorType === "auth") {
	          window.SUITE_SETTINGS_UPSTREAM = { status: "inactive" };
	          setUpstreamStatus("inactive", t("adminSessionRequired"), "adminSessionRequired");
	          showAdminSessionBanner("adminSessionBannerDetail");
	        } else {
	          window.SUITE_SETTINGS_UPSTREAM = { status: "error" };
	          setUpstreamStatus("error", t("loadFailed"), "loadFailed");
	        }
        applyUpstreamDraftToInputs(getUpstreamDraft(), { preferExisting: true });
        renderUpstreamSummary();
        if (window.applyNavOrder) window.applyNavOrder();
        return;
      }
      const data = res.data;
      const models = Array.isArray(data.models_allowlist)
        ? data.models_allowlist
        : [];
      const serverBaseUrl = data.base_url || "";
      const serverProvider = data.provider || "";
      const serverModels = models.join(",");
      upstreamHasKey = data.api_key === "{REDACTED}";
      const status = normalizeUpstreamStatus(String(data.status || ""));
      window.SUITE_SETTINGS_UPSTREAM = {
        base_url: serverBaseUrl,
        provider: serverProvider,
        models: serverModels,
        status,
        last_tested: data.last_tested || "",
      };
	      if (serverBaseUrl || !upstreamBaseUrl.value.trim()) {
	        upstreamBaseUrl.value = serverBaseUrl;
	      }
	      if (serverProvider || !upstreamProvider.value) {
	        setUpstreamProviderUi(serverProvider || "openai_compatible", { preferExisting: false });
	      }
	      if (serverModels || !upstreamModels.value.trim()) {
	        upstreamModels.value = serverModels;
	      }
	      mergeUpstreamDraft({
	        base_url: serverBaseUrl,
	        provider: normalizeProviderForUi(serverProvider),
	        models: serverModels,
	      });
	      upstreamApiKey.value = "";
	      updateUpstreamApiKeyDisplay(upstreamHasKey);
	      setUpstreamStatus(status, statusLabel(status), statusLabelKey(status));
	      hideAdminSessionBanner();
	      renderUpstreamSummary();
	      if (window.applyNavOrder) window.applyNavOrder();
	    }

    async function refreshPolicyProfile() {
      if (!apiClient.fetchControlPolicyProfile) return;
      const res = await apiClient.fetchControlPolicyProfile();
      if (!res || !res.ok) {
	        window.SUITE_SETTINGS_POLICY_PROFILE = {};
	        if (res && res.errorType === "auth") {
	          setPolicyStatus("inactive", t("adminSessionRequired"), "adminSessionRequired");
	          showAdminSessionBanner("adminSessionBannerDetail");
	        } else {
	          setPolicyStatus("error", t("loadFailed"), "loadFailed");
	        }
	        renderPolicySummary();
	        return;
      }
      const data = res.data;
      window.SUITE_SETTINGS_POLICY_PROFILE = data;
      if (policyProfileSelect) {
        policyProfileSelect.value = data.profile_name || "standard";
      }
      if (policyRestrictedSinks) {
        const additions = Array.isArray(data.restricted_sinks_additions)
          ? data.restricted_sinks_additions
          : [];
        policyRestrictedSinks.value = additions.join(", ");
      }
      if (policyAllowUntrusted) {
        policyAllowUntrusted.checked = Boolean(data.allow_untrusted_with_approvals);
      }
      if (policyChangeReason) {
        policyChangeReason.value = data.change_reason || "";
	      }
	      setPolicyStatus("active", t("loaded"), "loaded");
	      hideAdminSessionBanner();
	      renderPolicySummary();
	    }

    async function refreshEnvironments() {
      if (!apiClient.fetchSettingsEnvironments) return;
      const data = await apiClient.fetchSettingsEnvironments();
      const items = Array.isArray(data) ? data : [];
      window.SUITE_SETTINGS_ENVIRONMENTS = items.map((env) => ({
        id: env.id,
        name: env.name,
        endpoint: env.endpoint_url || "",
        status: env.status || "inactive",
        note: env.memo || "",
      }));
      render();
      renderGatewayWizard();
    }

    async function refreshGatewayTokens() {
      if (!apiClient.listControlTokens) return;
      const res = await apiClient.listControlTokens();
	      if (!res || !res.ok) {
	        window.SUITE_SETTINGS_GATEWAY_TOKENS = [];
	        gatewayTokensAuthRequired = Boolean(res && res.errorType === "auth");
	        renderGatewayHistory();
	        if (gatewayTokensAuthRequired) {
	          showAdminSessionBanner("adminSessionBannerDetail");
	        }
	        if (window.applyNavOrder) window.applyNavOrder();
	        return;
	      }
	      gatewayTokensAuthRequired = false;
	      hideAdminSessionBanner();
	      const data = res.data;
      const envs = window.SUITE_SETTINGS_ENVIRONMENTS || [];
      const envMap = new Map(envs.map((env) => [String(env.id ?? env.name), env.name]));
      const items = Array.isArray(data) ? data : [];
      window.SUITE_SETTINGS_GATEWAY_TOKENS = items.map((entry) => ({
        id: entry.id,
        env_id: entry.env_id,
        env_name: envMap.get(String(entry.env_id)) || "",
        token_masked: entry.token_masked || "",
        issued_at: entry.issued_at || "",
        expiry: entry.expires_at || "",
        note: entry.note || "",
        status: entry.status || "",
      }));
      renderGatewayHistory();
      if (window.applyNavOrder) window.applyNavOrder();
    }

    function normalizeBaseUrl(value) {
      if (!value) return "";
      return value.endsWith("/") ? value.slice(0, -1) : value;
    }

    function maskToken(token) {
      if (!token) return t("hiddenToken");
      if (token.length <= 8) return `${token[0]}***`;
      return `${token.slice(0, 4)}...${token.slice(-4)}`;
    }

    function tokenStatus(entry) {
      if (!entry) return "inactive";
      if (entry.status) return entry.status;
      if (entry.expiry) {
        const expiryMs = Date.parse(entry.expiry);
        if (!Number.isNaN(expiryMs) && expiryMs < Date.now()) {
          return "expired";
        }
      }
      return "active";
    }

    function selectedEnvironment() {
      const envs = window.SUITE_SETTINGS_ENVIRONMENTS || [];
      const value = gatewayEnvironment.value;
      return envs.find((env) => String(env.id ?? env.name) === value) || null;
    }

    function renderGatewayConfig() {
      const env = selectedEnvironment();
      const baseUrlRaw = env ? env.endpoint : "";
      const baseUrl = normalizeBaseUrl(baseUrlRaw) || "https://gateway.example.com";
      const token = gatewayToken.value || "<gateway_token>";
      const preset = gatewayPreset.value || "openai-env";
      let lines = [];
      if (preset === "curl") {
        lines = [
          "# cURL smoke",
          "curl -sS \\",
          `  -H "Authorization: Bearer ${token}" \\`,
          `  "${baseUrl}/v1/models"`
        ];
      } else if (preset === "python") {
        lines = [
          "# Python SDK example",
          "from openai import OpenAI",
          "",
          `client = OpenAI(base_url="${baseUrl}", api_key="${token}")`,
          "models = client.models.list()",
          "print(models.data[0].id if models.data else \"no models\")"
        ];
      } else if (preset === "javascript") {
        lines = [
          "// JavaScript SDK example",
          "import OpenAI from \"openai\";",
          "",
          `const client = new OpenAI({ baseURL: "${baseUrl}", apiKey: "${token}" });`,
          "const models = await client.models.list();",
          "console.log(models.data?.[0]?.id ?? \"no models\");"
        ];
      } else if (preset === "json") {
        lines = [
          "{",
          `  "openai_base_url": "${baseUrl}",`,
          `  "openai_api_key": "${token}"`,
          "}"
        ];
      } else {
        lines = [
          "# OpenAI-compatible client",
          `export OPENAI_BASE_URL="${baseUrl}"`,
          `export OPENAI_API_KEY="${token}"`,
          "",
          "# Optional smoke",
          "curl -sS \\",
          `  -H "Authorization: Bearer ${token}" \\`,
          `  "${baseUrl}/v1/models"`
        ];
      }
      gatewayConfig.value = lines.join("\n");
      setFallbackText(gatewayTargetUrl, baseUrlRaw ? normalizeBaseUrl(baseUrlRaw) : "", "notSet");
      const state = window.SUITE_SETTINGS_GATEWAY || {};
      const issuedAt = state.issued_at ? toLocalDatetime(state.issued_at) : "";
      setFallbackText(gatewayIssuedAt, issuedAt, "notIssued");
      const expiryLabel = state.expiry ? toUtcDatetime(state.expiry) : "";
      setFallbackText(gatewaySummaryExpiry, expiryLabel, "notSet");
      setFallbackText(gatewaySummaryNote, state.note, "notSet");
    }

    function renderGatewayHistory() {
      if (!gatewayHistoryRows) return;
      if (gatewayTokensAuthRequired) {
        gatewayHistoryRows.innerHTML = `<tr><td colspan="6" class="note-text">${t("gatewayHistoryAdminRequired")}</td></tr>`;
        return;
      }
      const envValue = gatewayEnvironment.value;
      const history = window.SUITE_SETTINGS_GATEWAY_TOKENS || [];
      const items = history.filter((item) => {
        if (!envValue) return true;
        return String(item.env_id ?? item.env_name) === envValue;
      });
      if (!items.length) {
        gatewayHistoryRows.innerHTML = `<tr><td colspan="6" class="note-text">${t("gatewayHistoryNone")}</td></tr>`;
        return;
      }
      gatewayHistoryRows.innerHTML = items
        .map((entry) => {
          const status = tokenStatus(entry);
          const label = statusLabel(status);
          const issuedAt = entry.issued_at ? toLocalDatetime(entry.issued_at) : "";
          const expiry = entry.expiry ? toUtcDatetime(entry.expiry) : "";
          const canRevoke = status === "active" && entry.id !== undefined && entry.id !== null;
          const revokeBtn = canRevoke
            ? `<button type="button" class="btn btn-danger btn-sm" data-revoke-token-id="${entry.id}" data-testid="revoke-token-btn">${t("tokenRevokeBtn")}</button>`
            : `<span class="note-text">-</span>`;
          return `<tr data-testid="gateway-history-row" data-token-id="${entry.id || ''}">
            <td><code data-testid="gateway-history-token">${entry.token_masked || t("hiddenToken")}</code></td>
            <td class="summary-mono">${issuedAt || "-"}</td>
            <td class="summary-mono">${expiry || "-"}</td>
            <td>${entry.note || "-"}</td>
            <td><span class="status-indicator ${statusClass(status)}">${label}</span></td>
            <td>${revokeBtn}</td>
          </tr>`;
        })
        .join("");
      // Attach revoke handlers
      gatewayHistoryRows.querySelectorAll("[data-revoke-token-id]").forEach((btn) => {
        btn.addEventListener("click", handleRevokeToken);
      });
    }

    async function handleRevokeToken(e) {
      const btn = e.currentTarget;
      const tokenId = btn.getAttribute("data-revoke-token-id");
      if (!tokenId) return;
      if (!confirm(t("tokenRevokeConfirm"))) return;
      btn.disabled = true;
      btn.textContent = t("tokenRevoking");
      try {
        const result = await apiClient.revokeControlToken(tokenId);
        if (result && result.ok) {
          await refreshGatewayTokens();
        } else {
          alert(t("tokenRevokeFailed"));
          btn.disabled = false;
          btn.textContent = t("tokenRevokeBtn");
        }
      } catch (err) {
        alert(t("tokenRevokeFailed"));
        btn.disabled = false;
        btn.textContent = t("tokenRevokeBtn");
      }
    }

    function renderGatewayWizard() {
      const envs = window.SUITE_SETTINGS_ENVIRONMENTS || [];
      if (envs.length === 0) {
        gatewayEnvironment.innerHTML = `<option value="">${t("noEnvironments")}</option>`;
      } else {
        gatewayEnvironment.innerHTML = envs
          .map((env) => {
            const value = String(env.id ?? env.name);
            return `<option value="${value}">${env.name}</option>`;
          })
          .join("");
      }
      const state = window.SUITE_SETTINGS_GATEWAY || {};
      if (state.env_id !== undefined && envs.some((env) => String(env.id) === String(state.env_id))) {
        gatewayEnvironment.value = String(state.env_id);
      } else if (state.env_name && envs.some((env) => env.name === state.env_name)) {
        const match = envs.find((env) => env.name === state.env_name);
        gatewayEnvironment.value = String(match.id ?? match.name);
      } else if (envs.length) {
        gatewayEnvironment.value = String(envs[0].id ?? envs[0].name);
      }
      gatewayToken.value = state.token || "";
      gatewayExpiry.value = state.expiry ? toUtcDatetime(state.expiry) : "";
      gatewayNote.value = state.note || "";
      gatewayPreset.value = state.preset || "openai-env";
      renderGatewayConfig();
      renderGatewayHistory();
    }

	    function setGatewayCopyStatus(label, labelKey) {
	      gatewayCopyStatus.textContent = label;
	      if (labelKey) {
	        gatewayCopyStatus.dataset.labelKey = labelKey;
	      }
	    }

		    function hideGatewayIssueResult() {
		      if (!gatewayIssueResult || !gatewayIssueMessage) return;
		      gatewayIssueResult.style.display = "none";
		      gatewayIssueResult.className = "wizard-test-result";
		      gatewayIssueMessage.textContent = "";
		      delete gatewayIssueMessage.dataset.labelKey;
		      configureWizardCta(gatewayIssueCta, "", "");
		    }

				    function showGatewayIssueResult(type, label, labelKey) {
				      if (!gatewayIssueResult || !gatewayIssueMessage) return;
				      const klass =
				        type === "success" ? "success" : type === "error" ? "error" : type === "warn" ? "warn" : "";
				      gatewayIssueResult.style.display = "block";
				      gatewayIssueResult.className = `wizard-test-result ${klass}`.trim();
				      gatewayIssueMessage.textContent = label || "";
				      if (labelKey) {
				        gatewayIssueMessage.dataset.labelKey = labelKey;
				      } else {
				        delete gatewayIssueMessage.dataset.labelKey;
				      }
				      updateGatewayIssueCta(labelKey);
				    }

			    function dismissWizardResult(resultEl) {
			      if (!resultEl) return;
			      resultEl.style.display = "none";
			      try {
			        const keyed = resultEl.querySelectorAll("[data-label-key]");
				      keyed.forEach((el) => {
				        delete el.dataset.labelKey;
				        delete el.dataset.suffix;
				        delete el.dataset.hintKey;
				      });
				    } catch (e) { }
				  }

			    (function initDismissButtons() {
			      const buttons = document.querySelectorAll(".wizard-test-result .dismiss-btn");
			      buttons.forEach((btn) => {
			        btn.addEventListener("click", (e) => {
			          e.preventDefault();
			          dismissWizardResult(btn.closest(".wizard-test-result"));
			        });
			      });
			    })();

			    function hideEnvIssueResult() {
			      if (!envIssueResult || !envIssueMessage) return;
			      envIssueResult.style.display = "none";
			      envIssueResult.className = "wizard-test-result";
		      envIssueMessage.textContent = "";
		      delete envIssueMessage.dataset.labelKey;
		    }

		    function showEnvIssueResult(type, label, labelKey) {
		      if (!envIssueResult || !envIssueMessage) return;
		      const klass =
		        type === "success" ? "success" : type === "error" ? "error" : type === "warn" ? "warn" : "";
		      envIssueResult.style.display = "block";
		      envIssueResult.className = `wizard-test-result ${klass}`.trim();
		      envIssueMessage.textContent = label || "";
		      if (labelKey) {
		        envIssueMessage.dataset.labelKey = labelKey;
		      } else {
		        delete envIssueMessage.dataset.labelKey;
		      }
		    }

			    function hidePolicyIssueResult() {
			      if (!policyIssueResult || !policyIssueMessage) return;
			      policyIssueResult.style.display = "none";
			      policyIssueResult.className = "wizard-test-result";
			      policyIssueMessage.textContent = "";
			      delete policyIssueMessage.dataset.labelKey;
			      configureWizardCta(policyIssueCta, "", "");
			    }

			    function showPolicyIssueResult(type, label, labelKey) {
			      if (!policyIssueResult || !policyIssueMessage) return;
			      const klass =
			        type === "success" ? "success" : type === "error" ? "error" : type === "warn" ? "warn" : "";
			      policyIssueResult.style.display = "block";
			      policyIssueResult.className = `wizard-test-result ${klass}`.trim();
			      policyIssueMessage.textContent = label || "";
			      if (labelKey) {
			        policyIssueMessage.dataset.labelKey = labelKey;
			      } else {
			        delete policyIssueMessage.dataset.labelKey;
			      }
			      updatePolicyIssueCta(labelKey);
			    }

		    function render() {
		      const items = window.SUITE_SETTINGS_ENVIRONMENTS || [];
		      rows.innerHTML = items
	        .map((env) => `<tr>
	          <td><strong>${env.name}</strong></td>
          <td><code class="endpoint-text">${env.endpoint}</code></td>
          <td><span class="status-indicator ${statusClass(env.status)}">${statusLabel(env.status)}</span></td>
          <td><span class="note-text">${env.note || "-"}</span></td>
        </tr>`)
        .join("");
    }

	    form.addEventListener("submit", async (e) => {
	      e.preventDefault();
	      hideEnvIssueResult();
	      const payload = {
	        name: nameInput.value.trim(),
	        endpoint_url: endpointInput.value.trim(),
	        memo: noteInput.value.trim(),
	        status: "active"
	      };
	      if (!payload.name) {
	        showEnvIssueResult("error", t("envIssueNameRequired"), "envIssueNameRequired");
	        nameInput.focus();
	        return;
	      }
	      if (!payload.endpoint_url) {
	        showEnvIssueResult("error", t("envIssueEndpointRequired"), "envIssueEndpointRequired");
	        endpointInput.focus();
	        return;
	      }
	      showEnvIssueResult("warn", t("envIssueSaving"), "envIssueSaving");
	      const saved = apiClient.saveSettingsEnvironment
	        ? await apiClient.saveSettingsEnvironment(payload)
	        : null;
	      if (!saved) {
	        showEnvIssueResult("error", t("envIssueSaveFailed"), "envIssueSaveFailed");
	        return;
	      }
	      await refreshEnvironments();
	      form.reset();
	      showEnvIssueResult("success", t("envIssueSaved"), "envIssueSaved");
	    });

	    function setUpstreamStatus(state, label, labelKey) {
	      upstreamStatus.className = `status-indicator ${statusClass(state)}`;
	      upstreamStatus.textContent = label;
	      upstreamStatus.dataset.state = state;
	      if (labelKey) {
	        upstreamStatus.dataset.labelKey = labelKey;
	      }
	    }

	    function formatHttpSuffix(httpStatus) {
	      const n = Number(httpStatus);
	      if (!Number.isFinite(n) || n <= 0) return "";
	      return ` (HTTP ${n})`;
	    }

	    function hideUpstreamIssueResult() {
	      if (!upstreamIssueResult || !upstreamIssueMessage) return;
	      upstreamIssueResult.style.display = "none";
	      upstreamIssueResult.className = "wizard-test-result";
	      upstreamIssueMessage.textContent = "";
	      delete upstreamIssueMessage.dataset.labelKey;
	      delete upstreamIssueMessage.dataset.suffix;
	      delete upstreamIssueMessage.dataset.hintKey;
	      configureWizardCta(upstreamIssueCta, "", "");
	    }

	    function isLikelyOllamaEndpoint(baseUrl) {
	      const value = String(baseUrl || "");
	      return /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\])(?::11434)?(\/|$)/i.test(value) ||
	        /:11434(\/|$)/.test(value);
	    }

	    function getUpstreamTestHintKey(httpStatus, provider, baseUrl) {
	      const n = Number(httpStatus);
	      if (!Number.isFinite(n) || n <= 0) return "upstreamTestHintOffline";
	      if (n === 401 || n === 403) return "upstreamTestHintAuth";
	      if (n === 404) {
	        if (provider === "ollama" || isLikelyOllamaEndpoint(baseUrl)) return "upstreamTestHintNotFoundOllama";
	        return "upstreamTestHintNotFound";
	      }
	      if (n === 429) return "upstreamTestHintRateLimit";
	      if (n >= 500) return "upstreamTestHintServer";
	      return "upstreamTestHintGeneric";
	    }

	    function showUpstreamIssueResult(type, labelKey, { httpStatus, hintKey, ctaAction, ctaLabelKey, evidenceId } = {}) {
	      if (!upstreamIssueResult || !upstreamIssueMessage) return;
	      const klass =
	        type === "success" ? "success" : type === "error" ? "error" : type === "warn" ? "warn" : "";
	      const suffix = formatHttpSuffix(httpStatus);
	      upstreamIssueResult.style.display = "block";
	      upstreamIssueResult.className = `wizard-test-result ${klass}`.trim();
	      upstreamIssueMessage.textContent = t(labelKey) + suffix + (hintKey ? ` ${t(hintKey)}` : "");
	      upstreamIssueMessage.dataset.labelKey = labelKey;
	      upstreamIssueMessage.dataset.suffix = suffix;
	      if (hintKey) {
	        upstreamIssueMessage.dataset.hintKey = hintKey;
	      } else {
	        delete upstreamIssueMessage.dataset.hintKey;
	      }
	      configureWizardCta(upstreamIssueCta, ctaAction || "", ctaLabelKey || "");
	      // P0-1b: Evidence Tracking UI
	      const evidenceInfo = document.getElementById("upstreamEvidenceInfo");
	      const evidenceIdEl = document.getElementById("upstreamEvidenceId");
	      const evidenceCopy = document.getElementById("upstreamEvidenceCopy");
	      const evidenceAuditLink = document.getElementById("upstreamEvidenceAuditLink");
	      if (evidenceInfo && evidenceIdEl) {
	        if (evidenceId) {
	          evidenceIdEl.textContent = evidenceId;
	          evidenceInfo.style.display = "block";
	          if (evidenceAuditLink) {
	            evidenceAuditLink.href = `audit_log.html?evidence_id=${encodeURIComponent(evidenceId)}`;
	          }
	          if (evidenceCopy) {
	            evidenceCopy.onclick = () => {
	              navigator.clipboard.writeText(evidenceId).then(() => {
	                evidenceCopy.textContent = "‚úÖ";
	                setTimeout(() => { evidenceCopy.textContent = "üìã"; }, 1500);
	              }).catch(() => {});
	            };
	          }
	        } else {
	          evidenceInfo.style.display = "none";
	        }
	      }
	      // P1-1 Phase 2: Show token issue CTA on success
	      const tokenIssueCta = document.getElementById("upstreamTokenIssueCta");
	      if (tokenIssueCta) {
	        if (type === "success") {
	          tokenIssueCta.style.display = "block";
	        } else {
	          tokenIssueCta.style.display = "none";
	        }
	      }
	    }

		    upstreamForm.addEventListener("submit", async (e) => {
		      e.preventDefault();
		      hideUpstreamIssueResult();
		      const baseUrl = upstreamBaseUrl.value.trim();
		      if (!baseUrl) {
		        setUpstreamStatus("error", t("baseUrlRequired"), "baseUrlRequired");
		        window.SUITE_SETTINGS_UPSTREAM = { status: "error" };
		        renderUpstreamSummary();
	        return;
	      }
	      const provider = getSelectedUpstreamProvider();
	      if (!provider) {
	        setUpstreamStatus("error", t("providerRequired"), "providerRequired");
	        window.SUITE_SETTINGS_UPSTREAM = {
	          base_url: baseUrl,
	          provider: upstreamProvider ? upstreamProvider.value : "",
	          models: upstreamModels ? upstreamModels.value.trim() : "",
	          status: "error"
	        };
	        renderUpstreamSummary();
	        if (upstreamProvider && upstreamProvider.value === "custom" && upstreamProviderCustom) {
	          upstreamProviderCustom.focus();
	        } else if (upstreamProvider) {
	          upstreamProvider.focus();
	        }
	        return;
	      }
		      const apiKey = upstreamApiKey.value.trim();
		      const allowEmptyKey =
		        provider === "ollama" ||
		        /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\])/i.test(baseUrl);
		      if (!apiKey && !upstreamHasKey && !allowEmptyKey) {
		        setUpstreamStatus("error", t("apiKeyRequired"), "apiKeyRequired");
		        window.SUITE_SETTINGS_UPSTREAM = {
		          base_url: baseUrl,
		          provider,
	          models: upstreamModels.value.trim(),
	          status: "error"
	        };
	        renderUpstreamSummary();
	        return;
	      }
	      const models = upstreamModels.value
	        .split(",")
	        .map((item) => item.trim())
	        .filter(Boolean);
	      setUpstreamStatus("testing", t("saving"), "saving");
	      const saved = apiClient.saveControlUpstream
	        ? await apiClient.saveControlUpstream({
	          base_url: baseUrl,
	          api_key: apiKey,
          provider,
          models_allowlist: models
        })
        : null;
	      if (!saved || !saved.ok || !saved.data || saved.data.status !== "success") {
	        if (saved && saved.errorType === "auth") {
	          setUpstreamStatus("inactive", t("adminSessionRequired"), "adminSessionRequired");
	          showAdminSessionBanner("adminSessionBannerDetail");
	        } else {
	          setUpstreamStatus("error", t("saveFailed"), "saveFailed");
	        }
	        return;
	      }
      if (apiKey) {
        upstreamHasKey = true;
      }
	      setUpstreamStatus("testing", t("testing"), "testing");
	      const tested = apiClient.testControlUpstream
	        ? await apiClient.testControlUpstream()
	        : null;
	      if (!tested || !tested.ok || !tested.data) {
	        if (tested && tested.errorType === "auth") {
	          setUpstreamStatus("inactive", t("adminSessionRequired"), "adminSessionRequired");
	          showAdminSessionBanner("adminSessionBannerDetail");
	          showUpstreamIssueResult("error", "adminSessionRequired", {
	            ctaAction: "adminSession",
	            ctaLabelKey: "ctaGoToAdminSession",
	          });
	        } else if (tested && (tested.errorType === "network" || tested.errorType === "timeout")) {
	          setUpstreamStatus("error", t("statusError"), "statusError");
	          showUpstreamIssueResult("error", "upstreamTestFailed", {
	            hintKey: "upstreamTestHintOffline",
	            ctaAction: "diagnostics",
	            ctaLabelKey: "ctaRunDiagnostics",
	          });
	        } else {
	          setUpstreamStatus("error", t("statusError"), "statusError");
	          showUpstreamIssueResult("error", "upstreamTestFailed", {
	            hintKey: "upstreamTestHintGeneric",
	            ctaAction: "diagnostics",
	            ctaLabelKey: "ctaRunDiagnostics",
	          });
	        }
	        upstreamApiKey.value = "";
	        await refreshUpstream();
	        return;
	      }
	      const raw = String(tested.data.status || "error");
	      const status = normalizeUpstreamStatus(raw);
	      const evidenceId = tested.data.evidence_id || null;
	      setUpstreamStatus(status, statusLabel(status), statusLabelKey(status));
	      if (raw !== "ok") {
	        const hintKey = getUpstreamTestHintKey(tested.data.http_status, provider, baseUrl);
	        showUpstreamIssueResult("error", "upstreamTestFailed", {
	          httpStatus: tested.data.http_status,
	          hintKey,
	          evidenceId,
	        });
	      } else {
	        // P0-1b: Show success with evidence_id
	        showUpstreamIssueResult("success", "upstreamTestSuccess", { evidenceId });
	      }
	      upstreamApiKey.value = "";
	      await refreshUpstream();
	    });

		    if (policyForm) {
		      if (policyProfileSelect) {
		        policyProfileSelect.addEventListener("change", () => {
		          hidePolicyIssueResult();
		          const profileName = policyProfileSelect.value || "standard";
		          if (policyRestrictedSinks) {
		            if (profileName === "strict" || profileName === "development") {
		              policyRestrictedSinks.value = "sampling";
		            } else {
		              policyRestrictedSinks.value = "";
		            }
		          }
		          if (policyAllowUntrusted) {
		            policyAllowUntrusted.checked = profileName === "development";
		          }
		          showPolicyIssueResult("warn", t("policyIssueProfilePreset"), "policyIssueProfilePreset");
		        });
		      }
		      policyForm.addEventListener("submit", async (e) => {
		        e.preventDefault();
		        hidePolicyIssueResult();
		        const profileName = policyProfileSelect ? policyProfileSelect.value : "standard";
	        const additions = policyRestrictedSinks
	          ? normalizeSinksInput(policyRestrictedSinks.value)
	          : [];
	        const allowWithApprovals = policyAllowUntrusted ? policyAllowUntrusted.checked : false;
	        const changeReason = policyChangeReason ? policyChangeReason.value.trim() : "";
	        setPolicyStatus("testing", t("saving"), "saving");
	        showPolicyIssueResult("warn", t("policyIssueSaving"), "policyIssueSaving");
	        const saved = apiClient.saveControlPolicyProfile
	          ? await apiClient.saveControlPolicyProfile({
	            profile_name: profileName,
	            restricted_sinks_additions: additions,
	            allow_untrusted_with_approvals: Boolean(allowWithApprovals),
	            change_reason: changeReason
	          })
	          : null;
			        if (!saved || !saved.ok) {
			          if (saved && saved.errorType === "auth") {
			            setPolicyStatus("inactive", t("adminSessionRequired"), "adminSessionRequired");
			            showPolicyIssueResult("error", t("policyIssueAdminDetail"), "policyIssueAdminDetail");
			            showAdminSessionBanner("adminSessionBannerDetail");
			            if (adminTokenInput) {
			              adminTokenInput.scrollIntoView({ behavior: "smooth", block: "center" });
			              adminTokenInput.focus();
			            }
		          } else {
		            let failKey = "policyIssueSaveFailed";
		            if (!saved) {
		              failKey = "policyIssueGatewayOffline";
		            } else if (saved.errorType === "network" || saved.errorType === "timeout") {
		              failKey = "policyIssueGatewayOffline";
		            } else if (saved.status === 404) {
		              failKey = "policyIssueApiMissing";
		            } else if (saved.status === 400 || saved.status === 422) {
		              failKey = "policyIssueInvalidInput";
		            } else if (saved.errorType === "server") {
		              failKey = "policyIssueServerError";
		            }
		            setPolicyStatus("error", t("saveFailed"), "saveFailed");
		            showPolicyIssueResult("error", t(failKey), failKey);
		            if (failKey === "policyIssueInvalidInput" && policyRestrictedSinks) {
		              try {
		                policyRestrictedSinks.scrollIntoView({ behavior: "smooth", block: "center" });
		                policyRestrictedSinks.focus();
		              } catch (e) { }
		            }
		          }
		          return;
			        }
		        setPolicyStatus("active", t("saved"), "saved");
		        showPolicyIssueResult("success", t("policyIssueSaved"), "policyIssueSaved");
		        hideAdminSessionBanner();
		        await refreshPolicyProfile();
		      });
		    }

    gatewayEnvironment.addEventListener("change", () => {
      const env = selectedEnvironment();
      window.SUITE_SETTINGS_GATEWAY = {
        ...(window.SUITE_SETTINGS_GATEWAY || {}),
        env_id: env ? env.id : null,
        env_name: env ? env.name : "",
        endpoint: env ? env.endpoint : ""
      };
      renderGatewayConfig();
      renderGatewayHistory();
    });

    gatewayExpiry.addEventListener("input", () => {
      const expiryIso = toUtcIsoString(gatewayExpiry.value);
      window.SUITE_SETTINGS_GATEWAY = {
        ...(window.SUITE_SETTINGS_GATEWAY || {}),
        expiry: expiryIso
      };
      renderGatewayConfig();
    });

    gatewayNote.addEventListener("input", () => {
      window.SUITE_SETTINGS_GATEWAY = {
        ...(window.SUITE_SETTINGS_GATEWAY || {}),
        note: gatewayNote.value.trim()
      };
      renderGatewayConfig();
    });

    gatewayPreset.addEventListener("change", () => {
      window.SUITE_SETTINGS_GATEWAY = {
        ...(window.SUITE_SETTINGS_GATEWAY || {}),
        preset: gatewayPreset.value
      };
      renderGatewayConfig();
    });

	    gatewayGenerate.addEventListener("click", async () => {
	      hideGatewayIssueResult();
	      const envs = window.SUITE_SETTINGS_ENVIRONMENTS || [];
	      const env = selectedEnvironment();
		      if (!envs.length) {
		        setGatewayCopyStatus(t("copyStatusSelectEnv"), "copyStatusSelectEnv");
		        showGatewayIssueResult("error", t("gatewayIssueEnvMissing"), "gatewayIssueEnvMissing");
		        try { gatewayEnvironment.scrollIntoView({ behavior: "smooth", block: "center" }); gatewayEnvironment.focus(); } catch (e) { }
		        return;
		      }
		      if (!env || env.id === undefined || env.id === null) {
		        setGatewayCopyStatus(t("copyStatusSelectEnv"), "copyStatusSelectEnv");
		        showGatewayIssueResult("error", t("copyStatusSelectEnv"), "copyStatusSelectEnv");
		        try { gatewayEnvironment.scrollIntoView({ behavior: "smooth", block: "center" }); gatewayEnvironment.focus(); } catch (e) { }
		        return;
		      }
	      const expiryIso = toUtcIsoString(gatewayExpiry.value);
	      const note = gatewayNote.value.trim();
	      gatewayGenerate.disabled = true;
	      setGatewayCopyStatus(t("copyStatusIssuing"), "copyStatusIssuing");
	      showGatewayIssueResult("warn", t("copyStatusIssuing"), "copyStatusIssuing");
	      let result = null;
	      try {
	        result = apiClient.issueControlToken
	          ? await apiClient.issueControlToken({
	            env_id: env.id,
            expires_at: expiryIso,
            note
          })
          : null;
      } catch (err) {
        result = null;
      }
		      gatewayGenerate.disabled = false;
			      if (!result || !result.ok || !result.data || !result.data.token) {
			        if (result && result.errorType === "auth") {
			          setGatewayCopyStatus(t("adminSessionRequired"), "adminSessionRequired");
			          showGatewayIssueResult("error", t("gatewayIssueAdminDetail"), "gatewayIssueAdminDetail");
			          showAdminSessionBanner("adminSessionBannerDetail");
			          if (adminTokenInput && typeof adminTokenInput.scrollIntoView === "function") {
			            adminTokenInput.scrollIntoView({ behavior: "smooth", block: "center" });
			            try {
			              adminTokenInput.focus();
		            } catch (e) { }
		          }
		        } else {
		          let failKey = "copyStatusIssueFailed";
		          if (!result) {
		            failKey = "gatewayIssueGatewayOffline";
		          } else if (result.errorType === "network" || result.errorType === "timeout") {
		            failKey = "gatewayIssueGatewayOffline";
		          } else if (result.status === 404) {
		            failKey = "gatewayIssueApiMissing";
		          } else if (result.status === 400 || result.status === 422) {
		            failKey = "gatewayIssueInvalidInput";
		          } else if (result.errorType === "server") {
		            failKey = "gatewayIssueServerError";
		          }
		          setGatewayCopyStatus(t("copyStatusIssueFailed"), "copyStatusIssueFailed");
		          showGatewayIssueResult("error", t(failKey), failKey);
		          if (failKey === "gatewayIssueInvalidInput" && gatewayExpiry) {
		            try {
		              gatewayExpiry.scrollIntoView({ behavior: "smooth", block: "center" });
		              gatewayExpiry.focus();
		            } catch (e) { }
		          }
		        }
		        return;
		      }
	      const issuedAt = new Date().toISOString();
      window.SUITE_SETTINGS_GATEWAY = {
        env_id: env.id,
        env_name: env.name,
        endpoint: env.endpoint,
        token: result.data.token,
        preset: gatewayPreset.value,
        expiry: result.data.expires_at || expiryIso,
        note,
        issued_at: issuedAt
	      };
		      gatewayToken.value = result.data.token;
		      setGatewayCopyStatus(t("copyStatusIssued"), "copyStatusIssued");
		      showGatewayIssueResult("success", t("copyStatusIssued"), "copyStatusIssued");
		      hideAdminSessionBanner();
		      renderGatewayConfig();
		      await refreshGatewayTokens();
		    });

    gatewayCopy.addEventListener("click", async () => {
      const text = gatewayConfig.value;
      if (!text) return;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else if (document.execCommand) {
          gatewayConfig.select();
          document.execCommand("copy");
        }
        setGatewayCopyStatus(t("copyStatusCopied"), "copyStatusCopied");
      } catch (err) {
        setGatewayCopyStatus(t("copyStatusCopyFailed"), "copyStatusCopyFailed");
      }
    });

	    bindUpstreamDraftListeners();
	    applyUpstreamDraftToInputs(getUpstreamDraft(), { preferExisting: false });
	    renderUpstreamProviderHint();
	    render();
	    renderUpstreamSummary();
	    renderPolicySummary();
	    renderGatewayWizard();
    renderGatewayHistory();
    refreshEnvironments();
    refreshUpstream().then(updateQuickStatus);
    refreshPolicyProfile().then(updateQuickStatus);
    refreshGatewayTokens().then(updateQuickStatus);

    function updateQuickStatus() {
      // Connection status
      var up = window.SUITE_SETTINGS_UPSTREAM || {};
      var connEl = document.getElementById('qsConnectionStatus');
      if (connEl) {
        var st = up.status || 'inactive';
        connEl.textContent = st === 'ok' ? 'Connected' : st === 'error' ? 'Error' : 'Inactive';
        connEl.className = 'status-indicator ' + (st === 'ok' ? 'active' : st === 'error' ? 'error' : 'inactive');
      }
      // Upstream URL
      var upUrlEl = document.getElementById('qsUpstreamValue');
      if (upUrlEl) {
        var url = up.base_url || '';
        upUrlEl.textContent = url ? url.replace(/^https?:\/\//, '').slice(0, 40) : 'Not configured';
      }
      // Policy profile
      var polEl = document.getElementById('qsPolicyValue');
      if (polEl) {
        var polSel = document.getElementById('policyProfileSelect');
        var profile = polSel ? (polSel.options[polSel.selectedIndex] || {}).textContent : '-';
        polEl.textContent = profile || '-';
      }
      // Active tokens
      var tokEl = document.getElementById('qsTokensValue');
      if (tokEl) {
        var tokens = window.SUITE_SETTINGS_GATEWAY_TOKENS || [];
        var active = tokens.filter(function(t) { return t.status === 'active'; }).length;
        tokEl.textContent = active;
      }
    }

    // Auto-populate admin token from server-injected value and start session
    (function autoAdminSession() {
      var injected = window.SUITE_ADMIN_TOKEN || "";
      if (!injected) return;
      // Fill all possible admin token inputs (adminToken, wizardAdminToken, wizardTokenInput)
      if (adminTokenInput) adminTokenInput.value = injected;
      var wizardEl = getWizardAdminToken();
      if (wizardEl) wizardEl.value = injected;
      var wizardTokenEl = document.getElementById("wizardTokenInput");
      if (wizardTokenEl) wizardTokenEl.value = injected;
      // Auto-start session after a short delay (let API client initialize)
      setTimeout(function () { startAdminSession(); }, 300);
    })();
  </script>
  <script>
    // Auto-detect active nav link
    (function () {
      if (!window.location || !window.location.pathname) return;
      const currentFile = window.location.pathname.split('/').pop() || 'index.html';
      document.querySelectorAll('.nav-link').forEach(link => {
        const href = link.getAttribute('href');
        if (href === currentFile) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });
    })();
  </script>
  <script>
    // Smooth page transitions - fade out before navigating
    document.querySelectorAll('.nav-link').forEach(link => {
      link.addEventListener('click', function (e) {
        const href = this.getAttribute('href');
        if (href && !href.startsWith('#') && !href.startsWith('javascript')) {
          e.preventDefault();
          document.body.style.opacity = '0';
          setTimeout(() => { window.location.href = href; }, 80);
        }
      });
    });
  </script>

  <!-- ===== Onboarding Wizard Modal ===== -->
  <div class="wizard-overlay" id="wizardOverlay">
    <div class="wizard-modal">
      <div class="wizard-header">
        <h2 id="wizardTitle">üöÄ MCP Gateway Setup Wizard</h2>
        <p id="wizardSubtitle">Complete setup in 5 easy steps</p>
        <div class="wizard-progress">
          <div class="wizard-progress-step active" data-step="1"></div>
          <div class="wizard-progress-step" data-step="2"></div>
          <div class="wizard-progress-step" data-step="3"></div>
          <div class="wizard-progress-step" data-step="4"></div>
          <div class="wizard-progress-step" data-step="5"></div>
        </div>
      </div>

      <div class="wizard-body">
        <!-- Step 1: Gateway prerequisites -->
        <div class="wizard-step active" data-step="1">
          <div class="wizard-step-title">
            <span class="step-number">1</span>
            <span id="wizardStep1Title">Gateway Ready</span>
          </div>
          <p class="wizard-step-desc" id="wizardStep1Desc">
            Admin session is auto-configured for this demo.
          </p>
          <div style="text-align:center;padding:24px 0;">
            <div style="width:64px;height:64px;border-radius:50%;background:#10b981;display:inline-flex;align-items:center;justify-content:center;margin-bottom:12px;">
              <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.5" style="width:32px;height:32px;">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            </div>
            <p style="font-size:16px;font-weight:600;color:var(--gray-900);margin-bottom:4px;">Admin Token: Auto-configured</p>
            <p style="font-size:14px;color:var(--gray-600);">No manual input required. Press <strong>Next</strong> to enter your Gemini API key.</p>
          </div>
          <!-- Hidden elements to prevent JS null errors -->
          <div style="display:none;">
            <input type="hidden" id="wizardTokenInput">
            <button type="button" id="wizardTokenCopyBtn"></button>
            <code id="wizardTokenCommand"></code>
            <button type="button" id="wizardTokenStartBtn"></button>
            <button type="button" id="wizardPrecheckBtn"></button>
            <span id="wizardPrecheckMessage"></span>
            <button type="button" id="wizardPrecheckCta"></button>
          </div>
        </div>

        <!-- Step 2: API Key -->
	        <div class="wizard-step" data-step="2">
	          <div class="wizard-step-title">
	            <span class="step-number">2</span>
	            <span id="wizardStep2Title">Enter Gemini API Key</span>
	          </div>
	          <p class="wizard-step-desc" id="wizardStep2Desc">
	            Paste your Gemini API key to enable AI-powered security features:<br>
	            AI Council, Semantic Scanner, RedTeam, and Causal Web Sandbox.
	          </p>
	          <div class="wizard-input-group">
	            <label for="wizardUpstreamProvider">Provider</label>
		            <select id="wizardUpstreamProvider" style="display:none;">
		              <option value="gemini_openai" selected>Gemini (AI Studio)</option>
		            </select>
		          </div>
	          <div class="wizard-input-group" id="wizardUpstreamProviderCustomWrap" style="display:none;">
	            <label for="wizardUpstreamProviderCustom">Custom provider</label>
	            <input type="text" id="wizardUpstreamProviderCustom" placeholder="e.g., my-proxy" autocomplete="off">
	          </div>
	          <input type="hidden" id="wizardUpstreamBaseUrl" value="https://generativelanguage.googleapis.com/v1beta/openai">
	          <div class="wizard-input-group">
	            <label for="wizardApiKey">Gemini API Key</label>
	            <input type="password" id="wizardApiKey" placeholder="Paste your Gemini API key (AIza...)" autocomplete="off">
	            <p class="input-hint">üîí Get your key from <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener">Google AI Studio</a>. Stored securely, never exposed externally.</p>
	          </div>
          <div class="wizard-test-result" id="wizardApiTestResult" style="display:none;">
            <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
            <span id="wizardApiTestMessage"></span>
          </div>
        </div>

        <!-- Step 3: Model Selection (Gemini-only) -->
	        <div class="wizard-step" data-step="3">
	          <div class="wizard-step-title">
	            <span class="step-number">3</span>
	            <span id="wizardStep3Title">Select Gemini Model</span>
	          </div>
	          <p class="wizard-step-desc" id="wizardStep3Desc">
	            Choose which Gemini model to use for AI-powered analysis.
	          </p>
	          <div class="wizard-input-group">
	            <label for="wizardModel">Gemini Model</label>
	            <select id="wizardModel" style="width:100%;padding:10px 12px;border:1px solid var(--gray-300);border-radius:8px;font-size:14px;background:#fff;">
	              <option value="models/gemini-3-flash-preview" selected>Gemini 3 Flash (Recommended)</option>
	              <option value="models/gemini-2.5-flash">Gemini 2.5 Flash (Fallback)</option>
	              <option value="models/gemini-2.0-flash">Gemini 2.0 Flash</option>
	            </select>
	            <p class="input-hint">Recommended: <code>models/gemini-3-flash-preview</code> for Gemini 3 Hackathon</p>
	          </div>
	        </div>

        <!-- Step 4: Connection Test -->
        <div class="wizard-step" data-step="4">
          <div class="wizard-step-title">
            <span class="step-number">4</span>
            <span id="wizardStep4Title">Connection Test (Optional)</span>
          </div>
          <p class="wizard-step-desc" id="wizardStep4Desc">
            Optionally test connectivity. You can also press <strong>Next</strong> to skip.
          </p>
          <div id="wizardConnectionTest">
            <button type="button" class="btn btn-primary" id="wizardTestBtn" style="width:100%;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              Run Connection Test
            </button>
          </div>
	          <div class="wizard-test-result" id="wizardFinalTestResult" style="display:none;margin-top:16px;">
	            <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
	            <span id="wizardFinalTestMessage"></span>
	            <div class="wizard-test-actions">
	              <button type="button" class="btn btn-secondary" id="wizardFinalTestCta" style="display:none;"></button>
	            </div>
	          </div>
	        </div>

        <!-- Step 5: Gateway URL + Token -->
        <div class="wizard-step" data-step="5">
          <div class="wizard-step-title">
            <span class="step-number">5</span>
            <span id="wizardStep5Title">Gateway URL & Token Issuance</span>
          </div>
          <p class="wizard-step-desc" id="wizardStep5Desc">
            Register Gateway URL and issue client tokens.
          </p>
          <div class="wizard-input-group">
            <label id="wizardGatewayModeLabel">Mode</label>
            <div class="form-row">
              <label class="form-toggle">
                <input type="radio" name="wizardGatewayMode" id="wizardGatewayModeAuto" value="auto" checked>
                <span id="wizardGatewayModeAutoLabel">Auto</span>
              </label>
              <label class="form-toggle">
                <input type="radio" name="wizardGatewayMode" id="wizardGatewayModeManual" value="manual">
                <span id="wizardGatewayModeManualLabel">Manual</span>
              </label>
            </div>
            <p class="input-hint" id="wizardGatewayAutoHint">Auto uses the current URL as the Gateway.</p>
          </div>
          <div class="wizard-input-group">
            <label for="wizardGatewayEnvName" id="wizardGatewayEnvNameLabel">Environment Name</label>
            <input type="text" id="wizardGatewayEnvName" placeholder="gateway-local" autocomplete="off">
            <p class="input-hint" id="wizardGatewayEnvNameHint">Used as identifier when issuing tokens.</p>
          </div>
          <div class="wizard-input-group">
            <label for="wizardGatewayBaseUrl" id="wizardGatewayBaseUrlLabel">Gateway Base URL</label>
            <input type="url" id="wizardGatewayBaseUrl" placeholder="https://gateway.example.com" autocomplete="off">
            <p class="input-hint" id="wizardGatewayBaseUrlHint">Enter the OpenAI-compatible Base URL.</p>
          </div>
          <div id="wizardGatewayIssue">
            <button type="button" class="btn btn-primary" id="wizardIssueTokenBtn" style="width:100%;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              <span id="wizardIssueTokenLabel">Create Environment & Issue Token</span>
            </button>
          </div>
	          <div class="wizard-test-result" id="wizardGatewayResult" style="display:none;margin-top:16px;">
	            <button type="button" class="dismiss-btn" aria-label="Close">√ó</button>
	            <span id="wizardGatewayMessage"></span>
	            <div class="wizard-test-actions">
	              <button type="button" class="btn btn-secondary" id="wizardGatewayCta" style="display:none;"></button>
	            </div>
	          </div>
	        </div>

        <!-- Step 6: Complete -->
        <div class="wizard-step" data-step="6">
          <div style="text-align:center;padding:20px 0;">
            <div class="wizard-success-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            </div>
            <h3 style="font-size:20px;font-weight:700;margin-bottom:8px;" id="wizardCompleteTitle">Setup Complete! üéâ</h3>
            <p style="color:var(--gray-600);font-size:14px;line-height:1.6;" id="wizardCompleteDesc">
              MCP Gateway initial setup is complete.<br>
              Check status on the Dashboard or run security scans from Scans.
            </p>
          </div>
        </div>
      </div>

      <div class="wizard-footer">
        <span class="wizard-skip" id="wizardSkip">Skip and configure later</span>
        <div style="display:flex;gap:8px;">
          <button type="button" class="btn btn-secondary" id="wizardPrevBtn" style="display:none;">Back</button>
          <button type="button" class="btn btn-primary" id="wizardNextBtn">Next</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Onboarding Wizard Logic =====
	    (function() {
      const WIZARD_COMPLETED_KEY = 'mcp_gateway_wizard_completed';
      const overlay = document.getElementById('wizardOverlay');
      const steps = document.querySelectorAll('.wizard-step');
      const progressSteps = document.querySelectorAll('.wizard-progress-step');
      const prevBtn = document.getElementById('wizardPrevBtn');
      const nextBtn = document.getElementById('wizardNextBtn');
      const skipBtn = document.getElementById('wizardSkip');
	      const testBtn = document.getElementById('wizardTestBtn');
	      const finalTestCta = document.getElementById('wizardFinalTestCta');
	      const wizardPrecheckBtn = document.getElementById('wizardPrecheckBtn');
	      const wizardPrecheckCta = document.getElementById('wizardPrecheckCta');
      const wizardAutostartGuide = document.getElementById('wizardAutostartGuide');
      const wizardTokenInput = document.getElementById('wizardTokenInput');
      const wizardTokenCopyBtn = document.getElementById('wizardTokenCopyBtn');
      const wizardTokenCommand = document.getElementById('wizardTokenCommand');
      const wizardTokenStartBtn = document.getElementById('wizardTokenStartBtn');
	      const apiKeyInput = document.getElementById('wizardApiKey');
	      const modelSelect = document.getElementById('wizardModel');
		      const wizardUpstreamProvider = document.getElementById('wizardUpstreamProvider');
		      const wizardUpstreamProviderCustomWrap = document.getElementById('wizardUpstreamProviderCustomWrap');
		      const wizardUpstreamProviderCustom = document.getElementById('wizardUpstreamProviderCustom');
		      const wizardUpstreamBaseUrl = document.getElementById('wizardUpstreamBaseUrl');
      const gatewayModeAuto = document.getElementById('wizardGatewayModeAuto');
      const gatewayModeManual = document.getElementById('wizardGatewayModeManual');
	      const gatewayEnvNameInput = document.getElementById('wizardGatewayEnvName');
	      const gatewayBaseUrlInput = document.getElementById('wizardGatewayBaseUrl');
	      const gatewayIssueBtn = document.getElementById('wizardIssueTokenBtn');
	      const gatewayIssueCta = document.getElementById('wizardGatewayCta');

      let currentStep = 1;
      const totalSteps = 6;

      // Check if wizard was already completed
      function shouldShowWizard() {
        // In demo mode (mock data), skip auto-wizard for cleaner presentation
        if (window.apiClient && typeof window.apiClient.isMockEnabled === 'function' && window.apiClient.isMockEnabled()) {
          return false;
        }
        if (localStorage.getItem(WIZARD_COMPLETED_KEY) === 'true') {
          return false;
        }
        // Also check if upstream is already configured
        const upstream = window.SUITE_SETTINGS_UPSTREAM;
        if (upstreamHasKey) {
          return false;
        }
        if (upstream && upstream.base_url && upstream.status && upstream.status !== 'inactive') {
          return false;
        }
        return true;
      }

      function showWizard() {
        overlay.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      function hideWizard() {
        overlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      function completeWizard() {
        localStorage.setItem(WIZARD_COMPLETED_KEY, 'true');
        hideWizard();
      }

      function goToStep(step) {
        currentStep = step;

        // Update step visibility
        steps.forEach(s => {
          s.classList.remove('active');
          if (parseInt(s.dataset.step) === step) {
            s.classList.add('active');
          }
        });

        // Update progress bar
        const progressMax = totalSteps - 1;
        progressSteps.forEach(p => {
          const pStep = parseInt(p.dataset.step);
          p.classList.remove('active', 'completed');
          if (step === totalSteps) {
            p.classList.add('completed');
            return;
          }
          if (pStep < step) {
            p.classList.add('completed');
          } else if (pStep === step && step <= progressMax) {
            p.classList.add('active');
          }
        });

        // Update buttons
        prevBtn.style.display = step > 1 && step < totalSteps ? 'inline-flex' : 'none';
        
        if (step === 4 || step === 5) {
          nextBtn.style.display = 'none';
        } else if (step === totalSteps) {
          nextBtn.textContent = 'Go to Dashboard';
          nextBtn.style.display = 'inline-flex';
          skipBtn.style.display = 'none';
        } else {
          nextBtn.textContent = 'Next';
          nextBtn.style.display = 'inline-flex';
          skipBtn.style.display = '';
        }
      }

	      function normalizeWizardValue(value) {
	        return String(value || "").trim();
	      }

	      function getSelectedWizardProvider() {
	        if (!wizardUpstreamProvider) return "";
	        const selected = wizardUpstreamProvider.value;
	        if (selected === "custom") {
	          return normalizeWizardValue(wizardUpstreamProviderCustom ? wizardUpstreamProviderCustom.value : "");
	        }
	        return selected;
	      }

	      function getWizardProviderKeyForRules() {
	        const selected = wizardUpstreamProvider ? wizardUpstreamProvider.value : "";
	        const provider = getSelectedWizardProvider();
	        return selected === "custom" ? provider : selected;
	      }

	      function isLikelyLocalBaseUrl(baseUrl) {
	        const url = normalizeWizardValue(baseUrl).toLowerCase();
	        if (!url) return false;
	        return (
	          url.startsWith("http://127.0.0.1") ||
	          url.startsWith("http://localhost") ||
	          url.startsWith("http://[::1]") ||
	          url.startsWith("http://0.0.0.0") ||
	          url.startsWith("https://127.0.0.1") ||
	          url.startsWith("https://localhost") ||
	          url.startsWith("https://[::1]") ||
	          url.startsWith("https://0.0.0.0")
	        );
	      }

	      function allowEmptyWizardApiKey(providerKey, baseUrl) {
	        return providerKey === "ollama";
	      }

	      function syncWizardProviderCustomVisibility() {
	        if (!wizardUpstreamProvider || !wizardUpstreamProviderCustomWrap) return;
	        const isCustom = wizardUpstreamProvider.value === "custom";
	        wizardUpstreamProviderCustomWrap.style.display = isCustom ? "block" : "none";
	      }

	      function maybeApplyWizardPreset(providerKey, options) {
	        const force = options && options.force;
	        if (!providerKey || providerKey === "custom") return;
	        if (typeof UPSTREAM_PRESETS === "undefined") return;
	        const preset = UPSTREAM_PRESETS[providerKey];
	        if (!preset) return;
	        if (wizardUpstreamBaseUrl && preset.base_url) {
	          const current = wizardUpstreamBaseUrl.value.trim();
	          const isPresetValue = wizardUpstreamBaseUrl.dataset && wizardUpstreamBaseUrl.dataset.presetProvider;
	          if (!current || (force && isPresetValue)) {
	            wizardUpstreamBaseUrl.value = preset.base_url;
	            if (wizardUpstreamBaseUrl.dataset) wizardUpstreamBaseUrl.dataset.presetProvider = providerKey;
	          }
	        }
	        if (modelSelect && preset.models) {
	          const current = modelSelect.value.trim();
	          const isPresetValue = modelSelect.dataset && modelSelect.dataset.presetProvider;
	          if (!current || (force && isPresetValue)) {
	            const first = String(preset.models).split(",")[0].trim();
	            if (first) {
	              modelSelect.value = first;
	              if (modelSelect.dataset) modelSelect.dataset.presetProvider = providerKey;
	            }
	          }
	        }
	      }

	      function renderWizardUpstreamProviderHint() {
	        const body = document.getElementById("wizardUpstreamProviderHintBody");
	        const summary = document.getElementById("wizardUpstreamProviderHintSummary");
	        if (!body || !summary || !wizardUpstreamProvider) return;

	        summary.textContent = t("upstreamProviderHintSummary");

	        const selected = wizardUpstreamProvider.value;
	        const isCustom = selected === "custom";
	        const providerKey = isCustom ? "custom" : selected;
	        const customProvider = isCustom ? normalizeWizardValue(wizardUpstreamProviderCustom ? wizardUpstreamProviderCustom.value : "") : "";
	        const presetKey = isCustom ? "openai_compatible" : providerKey;
	        const preset = (typeof UPSTREAM_PRESETS !== "undefined" && UPSTREAM_PRESETS[presetKey]) ? UPSTREAM_PRESETS[presetKey] : { base_url: "", models: "" };

	        const baseUrlValue = preset.base_url ? `<code>${escapeHtml(preset.base_url)}</code>` : `<span class="provider-hint-muted">${escapeHtml(t("notSet"))}</span>`;
	        const modelsValue = preset.models ? `<code>${escapeHtml(preset.models)}</code>` : `<span class="provider-hint-muted">${escapeHtml(t("notSet"))}</span>`;

	        const providerBodyKey = getUpstreamProviderHintBodyKey(providerKey);
	        const apiKeyLine = presetKey === "ollama" ? t("upstreamProviderHintApiKeyOptional") : t("upstreamProviderHintApiKeyRequired");

	        const customLine = customProvider
	          ? `<li>${escapeHtml(t("upstreamProviderCustomLabel"))}: <code>${escapeHtml(customProvider)}</code></li>`
	          : "";

	        body.innerHTML = [
	          `<div>${escapeHtml(t("upstreamProviderHintIntro"))}</div>`,
	          `<ul>`,
	          `<li>${escapeHtml(t(providerBodyKey))}</li>`,
	          `<li>${escapeHtml(apiKeyLine)}</li>`,
	          customLine,
	          `</ul>`,
	          `<div style="margin-top:6px;"><strong>${escapeHtml(t("upstreamProviderHintDefaults"))}</strong></div>`,
	          `<div>${escapeHtml(t("upstreamBaseUrlLabel"))}: ${baseUrlValue}</div>`,
	          `<div>${escapeHtml(t("upstreamModelsLabel"))}: ${modelsValue}</div>`,
	        ].filter(Boolean).join("");
	      }

	      window.renderWizardUpstreamProviderHint = renderWizardUpstreamProviderHint;

	      function validateStep(step) {
	        if (step === 2) {
	          const provider = getSelectedWizardProvider();
	          const providerKey = wizardUpstreamProvider ? wizardUpstreamProvider.value : provider;
	          const baseUrl = wizardUpstreamBaseUrl ? wizardUpstreamBaseUrl.value.trim() : "";
	          const apiKey = apiKeyInput ? apiKeyInput.value.trim() : "";
	          if (!providerKey) {
	            showApiTestResult("error", "‚ö†Ô∏è Please select a provider");
	            return false;
	          }
	          if (providerKey === "custom" && !provider) {
	            showApiTestResult("error", "‚ö†Ô∏è Please enter a custom provider name");
	            return false;
	          }
	          if (!baseUrl) {
	            showApiTestResult("error", "‚ö†Ô∏è Upstream Base URL is required");
	            return false;
	          }
	          const allowEmptyKey = allowEmptyWizardApiKey(getWizardProviderKeyForRules(), baseUrl);
	          if (!apiKey && !allowEmptyKey && !upstreamHasKey) {
	            showApiTestResult("error", "‚ö†Ô∏è Please enter your Gemini API key");
	            return false;
	          }
	          if (!apiKey && upstreamHasKey) {
	            showApiTestResult("success", "‚úÖ API key is saved");
	          } else {
	            showApiTestResult("success", "‚úÖ Input looks good");
	            // Eagerly set GOOGLE_API_KEY for Gemini features (best-effort)
	            if (apiKey) {
	              try {
	                const authToken = (typeof getAdminToken === 'function') ? getAdminToken() : (window.SUITE_ADMIN_TOKEN || '');
	                const hdrs = { 'Content-Type': 'application/json' };
	                if (authToken) hdrs['Authorization'] = 'Bearer ' + authToken;
	                fetch('/api/config/gemini-key', { method: 'POST', headers: hdrs, body: JSON.stringify({ api_key: apiKey }) }).catch(function() { /* best-effort: Gemini key sync may fail if gateway unreachable */ });
	              } catch (_) { /* fetch setup error */ }
	            }
	          }
	          return true;
	        }
	        if (step === 3) {
	          const raw = modelSelect ? modelSelect.value.trim() : "";
	          if (!raw) {
	            if (modelSelect && typeof modelSelect.setCustomValidity === "function") {
	              modelSelect.setCustomValidity("Please enter a model ID");
	              modelSelect.reportValidity();
	              modelSelect.setCustomValidity("");
	            }
	            return false;
	          }
	          return true;
	        }
	        return true;
	      }

      function showApiTestResult(type, message) {
        const result = document.getElementById('wizardApiTestResult');
        const msg = document.getElementById('wizardApiTestMessage');
        result.style.display = 'block';
        result.className = 'wizard-test-result ' + type;
        msg.textContent = message;
      }

	      function wizardResult(type, targetId, message) {
	        const resultDiv = document.getElementById(targetId);
	        const msgId = targetId === 'wizardGatewayResult'
	          ? 'wizardGatewayMessage'
	          : targetId === 'wizardPrecheckResult'
	            ? 'wizardPrecheckMessage'
	            : 'wizardFinalTestMessage';
	        const msgSpan = document.getElementById(msgId);
	        if (!resultDiv || !msgSpan) return;
	        resultDiv.style.display = 'block';
	        resultDiv.className = 'wizard-test-result ' + type;
	        msgSpan.innerHTML = message;
	      }

	      async function runWizardGatewayPrecheck() {
	        configureWizardOverlayCta(wizardPrecheckCta, "", "");
	        if (!wizardPrecheckBtn) return false;
	        wizardPrecheckBtn.disabled = true;
	        wizardPrecheckBtn.textContent = t("wizardPrecheckRunning");
	        try {
	          const client = getApiClient();
	          if (!client || !client.fetchControlDiagnostics) {
	            configureWizardOverlayCta(wizardPrecheckCta, "autostart", "ctaOpenAutostart");
	            wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("diagnosticsErrorUnavailable")}`);
	            return false;
	          }
	          const res = await client.fetchControlDiagnostics();
	          if (!res || !res.ok) {
	            if (res && res.errorType === "auth") {
	              configureWizardOverlayCta(wizardPrecheckCta, "adminSession", "ctaGoToAdminSession");
	              wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("wizardGatewayAdminRequired")}`);
	              return false;
	            }
	            if (res && (res.errorType === "network" || res.errorType === "timeout")) {
	              configureWizardOverlayCta(wizardPrecheckCta, "autostart", "ctaOpenAutostart");
	              wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("gatewayIssueGatewayOffline")}`);
	              return false;
	            }
	            if (res && res.status === 503) {
	              configureWizardOverlayCta(wizardPrecheckCta, "autostart", "ctaOpenAutostart");
	              wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("wizardGatewayAdminTokenNotConfigured")}`);
	              return false;
	            }
	            configureWizardOverlayCta(wizardPrecheckCta, "diagnostics", "ctaRunDiagnostics");
	            wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("diagnosticsErrorGateway")}`);
	            return false;
	          }
	          const allowlistStatus = (res.data && res.data.allowlist_status) || {};
	          const present = normalizePresentValue(allowlistStatus);
	          if (present === false) {
	            configureWizardOverlayCta(wizardPrecheckCta, "diagnostics", "ctaRunDiagnostics");
	            wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("wizardPrecheckPolicyMissing")}`);
	            return false;
	          }
	          if (present === null) {
	            configureWizardOverlayCta(wizardPrecheckCta, "diagnostics", "ctaRunDiagnostics");
	            wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("wizardPrecheckPolicyUnknown")}`);
	            return false;
	          }
	          wizardResult("success", "wizardPrecheckResult", `‚úÖ <strong>${t("wizardPrecheckOk")}</strong>`);
	          return true;
	        } catch (err) {
	          configureWizardOverlayCta(wizardPrecheckCta, "diagnostics", "ctaRunDiagnostics");
	          wizardResult("error", "wizardPrecheckResult", `‚ùå <strong>${t("wizardPrecheckFailed")}</strong> ${t("diagnosticsErrorGateway")}`);
	          return false;
	        } finally {
	          wizardPrecheckBtn.disabled = false;
	          wizardPrecheckBtn.textContent = t("wizardPrecheckBtn");
	        }
	      }

	      function configureWizardOverlayCta(btn, action, labelKey) {
	        if (!btn) return;
	        if (!action || !labelKey) {
	          btn.style.display = 'none';
	          btn.textContent = '';
	          btn.onclick = null;
	          delete btn.dataset.action;
	          delete btn.dataset.labelKey;
	          return;
	        }
	        btn.style.display = 'inline-flex';
	        btn.dataset.action = action;
	        btn.dataset.labelKey = labelKey;
	        btn.textContent = t(labelKey);
	        btn.onclick = (e) => {
	          e.preventDefault();
	          if (action !== "autostart") {
	            try { hideWizard(); } catch (err) { }
	          }
	          try {
	            if (typeof runWizardCtaAction === 'function') {
	              runWizardCtaAction(action);
	            }
	          } catch (err) { }
	        };
	      }

      function getDefaultGatewayBaseUrl() {
        const search = window.location && typeof window.location.search === 'string' ? window.location.search : '';
        const getParam = (key) => {
          if (!key) return '';
          if (typeof URLSearchParams !== 'undefined') {
            try {
              const params = new URLSearchParams(search || '');
              return params.get(key) || '';
            } catch (e) {
              return '';
            }
          }
          const query = String(search || '').replace(/^\?/, '');
          if (!query) return '';
          for (const part of query.split('&')) {
            if (!part) continue;
            const [rawK, rawV] = part.split('=');
            if (!rawK) continue;
            if (decodeURIComponent(rawK) !== key) continue;
            return rawV ? decodeURIComponent(rawV) : '';
          }
          return '';
        };
        const override = getParam('gateway_base') || getParam('gateway_url');
        if (override) return override;
        const origin = window.location && window.location.origin ? window.location.origin : '';
        if (origin && origin !== 'null') return origin;
        return '';
      }

      function getDefaultGatewayEnvName(baseUrl) {
        if (!baseUrl) return 'gateway-default';
        try {
          const url = new URL(baseUrl);
          const host = url.hostname || 'gateway';
          return `gateway-${host}`;
        } catch (e) {
          return 'gateway-default';
        }
      }

      function updateGatewayMode() {
        const autoMode = gatewayModeAuto && gatewayModeAuto.checked;
        const baseUrl = getDefaultGatewayBaseUrl();
        const envName = getDefaultGatewayEnvName(baseUrl);
        if (gatewayEnvNameInput) {
          if (autoMode) {
            gatewayEnvNameInput.value = envName;
          }
          gatewayEnvNameInput.readOnly = autoMode;
        }
        if (gatewayBaseUrlInput) {
          if (autoMode) {
            gatewayBaseUrlInput.value = baseUrl;
          }
          gatewayBaseUrlInput.readOnly = autoMode;
        }
        const autoHint = document.getElementById('wizardGatewayAutoHint');
        if (autoHint) {
          autoHint.style.display = autoMode ? 'block' : 'none';
        }
      }

		      function normalizeWizardModelIds(models, providerKey) {
		        const key = String(providerKey || "").trim();
		        if (key === "gemini_openai" || key === "vertex" || key === "gemini") {
		          return models
		            .map((m) => {
		              const trimmed = String(m || "").trim();
		              if (!trimmed) return "";
		              if (trimmed.startsWith("models/")) return trimmed;
		              if (trimmed.includes("/")) return trimmed;
		              return `models/${trimmed}`;
		            })
		            .filter(Boolean);
		        }
		        return models;
		      }

			      async function runConnectionTest() {
		        // NOTE: Admin Token is NOT required here if an admin session cookie is already established.
		        // Auth failures are handled by API responses (401/403) and shown as actionable errors below.
		        configureWizardOverlayCta(finalTestCta, "", "");
			        const provider = getSelectedWizardProvider();
			        const providerKeyForRules = getWizardProviderKeyForRules();
		        const baseUrl = wizardUpstreamBaseUrl ? wizardUpstreamBaseUrl.value.trim() : "";
		        const apiKey = apiKeyInput ? apiKeyInput.value.trim() : "";
		        const modelRaw = modelSelect ? modelSelect.value.trim() : "";
		        const rawModels = modelRaw
		          .split(",")
		          .map((item) => item.trim())
		          .filter(Boolean);
		        const modelsAllowlist = normalizeWizardModelIds(rawModels, providerKeyForRules);
	        const resultDiv = document.getElementById('wizardFinalTestResult');
	        const msgSpan = document.getElementById('wizardFinalTestMessage');
	        if (!provider) {
	          wizardResult('error', 'wizardFinalTestResult', `‚ùå <strong>${t('wizardConnectionFailed')}</strong> ${t('providerRequired')}`);
	          testBtn.disabled = false;
	          testBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Retry';
	          return;
	        }
	        if (!baseUrl) {
	          wizardResult('error', 'wizardFinalTestResult', `‚ùå <strong>${t('wizardConnectionFailed')}</strong> ${t('baseUrlRequired')}`);
	          testBtn.disabled = false;
	          testBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Retry';
	          return;
	        }
	        const allowEmptyKey = allowEmptyWizardApiKey(providerKeyForRules, baseUrl);
	        if (!apiKey && !allowEmptyKey && !upstreamHasKey) {
	          wizardResult('error', 'wizardFinalTestResult', `‚ùå <strong>${t('wizardConnectionFailed')}</strong> ${t('apiKeyRequired')}`);
	          testBtn.disabled = false;
	          testBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Retry';
	          return;
	        }
	        if (!modelsAllowlist.length) {
	          wizardResult('error', 'wizardFinalTestResult', `‚ùå <strong>${t('wizardConnectionFailed')}</strong> ${t('wizardModelRequired')}`);
	          testBtn.disabled = false;
	          testBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Retry';
	          return;
	        }
	        testBtn.disabled = true;
	        testBtn.innerHTML = '<span style="display:inline-flex;align-items:center;gap:8px;"><svg style="width:16px;height:16px;animation:spin 1s linear infinite;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 11-6-8.49"/></svg>Testing...</span>';
	        resultDiv.style.display = 'block';
	        resultDiv.className = 'wizard-test-result';
	        msgSpan.innerHTML = '';
	        const allowMock = typeof window.SUITE_DISABLE_MOCK === 'undefined' || window.SUITE_DISABLE_MOCK !== true;
	        const allowLocalFallback =
	          allowMock && window.location && window.location.protocol === 'file:';
	        try {
	          // Save & test via production API
	          const canCallApi = window.apiClient && window.apiClient.saveControlUpstream && window.apiClient.testControlUpstream;
	          if (!canCallApi && !allowMock) {
            throw new Error('API client unavailable');
          }
          // Save upstream config
          let saveRes = null;
		          if (canCallApi) {
		            saveRes = await window.apiClient.saveControlUpstream({
		              base_url: baseUrl,
		              api_key: apiKey,
		              provider,
		              models_allowlist: modelsAllowlist
		            });
		          }
		          // Also set GOOGLE_API_KEY for Gemini-powered features (Council, Scanner, RedTeam, Web Sandbox)
		          if (apiKey && (providerKeyForRules === 'gemini_openai' || providerKeyForRules === 'gemini' || providerKeyForRules === 'vertex')) {
		            try {
		              const authToken = (typeof getAdminToken === 'function') ? getAdminToken() : (window.SUITE_ADMIN_TOKEN || '');
		              const hdrs = { 'Content-Type': 'application/json' };
		              if (authToken) hdrs['Authorization'] = 'Bearer ' + authToken;
		              await fetch('/api/config/gemini-key', { method: 'POST', headers: hdrs, body: JSON.stringify({ api_key: apiKey }) });
		            } catch (_) { /* best-effort */ }
		          }
				          if (!saveRes || !saveRes.ok || !saveRes.data || saveRes.data.status !== 'success') {
				            if (saveRes && saveRes.errorType === 'auth') {
				              configureWizardOverlayCta(finalTestCta, "adminSession", "ctaGoToAdminSession");
				              throw new Error(t('wizardGatewayAdminRequired'));
				            }
				            if (saveRes && (saveRes.errorType === 'network' || saveRes.errorType === 'timeout')) {
				              configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
				              throw new Error(t('gatewayIssueGatewayOffline'));
				            }
				            const saveHttpStatus = saveRes ? saveRes.status : null;
				            if (saveRes && saveHttpStatus === 404) {
				              configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
				              throw new Error(t('wizardUpstreamSaveApiMissing'));
				            }
				            if (!allowLocalFallback) {
				              if (!saveRes) {
				                configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
				                throw new Error(t('gatewayIssueGatewayOffline'));
				              }
				              const suffix = formatHttpSuffix(saveHttpStatus);
				              if (saveHttpStatus === 400 || saveHttpStatus === 422) {
				                const ollamaHint =
				                  providerKeyForRules === "ollama" || isLikelyOllamaEndpoint(baseUrl)
				                    ? ` ${t("upstreamTestHintNotFoundOllama")}`
				                    : "";
				                throw new Error(t("wizardUpstreamSaveInvalidInput") + suffix + ollamaHint);
				              }
				              if (saveRes.errorType === "server" || (Number.isFinite(saveHttpStatus) && saveHttpStatus >= 500)) {
				                if (saveHttpStatus === 503) {
				                  configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
				                  throw new Error(t("wizardGatewayAdminTokenNotConfigured") + suffix);
				                }
				                configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
				                throw new Error(t("wizardUpstreamSaveServerError") + suffix);
				              }
				              throw new Error(t("wizardUpstreamSaveFailed") + suffix);
				            }
			            // Fallback: keep going with local config for static/offline (file:// only)
			            console.warn('[wizard] upstream save failed, using local config', saveRes);
				            if (apiKey) upstreamHasKey = true;
				            window.SUITE_SETTINGS_UPSTREAM = {
	              base_url: baseUrl,
	              provider,
	              models: modelsAllowlist.join(","),
	              status: 'active',
	              last_tested: new Date().toISOString()
	            };
	            setUpstreamStatus('active', statusLabel('active'), statusLabelKey('active'));
	            renderUpstreamSummary();
	            resultDiv.className = 'wizard-test-result success';
		            msgSpan.innerHTML = '‚úÖ <strong>Connected (local config)</strong> Backend save failed; settings stored locally.';
		            saveWizardSettings({ base_url: baseUrl, provider, api_key: apiKey, models: modelsAllowlist.join(",") });
		            setTimeout(() => goToStep(5), 1000);
		            return;
		          }
          // Test connection
          let testRes = null;
	          if (canCallApi) {
	            testRes = await window.apiClient.testControlUpstream();
	          }
			          if (!testRes || !testRes.ok || !testRes.data || testRes.data.status !== 'ok') {
			            if (testRes && testRes.errorType === 'auth') {
			              configureWizardOverlayCta(finalTestCta, "adminSession", "ctaGoToAdminSession");
			              throw new Error(t('wizardGatewayAdminRequired'));
			            }
			            if (testRes && (testRes.errorType === 'network' || testRes.errorType === 'timeout')) {
			              configureWizardOverlayCta(finalTestCta, "diagnostics", "ctaRunDiagnostics");
			              throw new Error(t('gatewayIssueGatewayOffline'));
			            }
			            if (!allowLocalFallback) {
			              const httpStatus = testRes && testRes.data ? testRes.data.http_status : (testRes ? testRes.status : null);
			              const hintKey = getUpstreamTestHintKey(httpStatus, providerKeyForRules, baseUrl);
			              throw new Error(t("upstreamTestFailed") + formatHttpSuffix(httpStatus) + " " + t(hintKey));
			            }
			            console.warn('[wizard] upstream test failed, using local result', testRes);
		            resultDiv.className = 'wizard-test-result success';
			            msgSpan.innerHTML = '‚úÖ <strong>Connected (local)</strong> Backend test failed; using local result.';
	            saveWizardSettings({ base_url: baseUrl, provider, api_key: apiKey, models: modelsAllowlist.join(",") });
	            setTimeout(() => goToStep(5), 1000);
	            return;
	          }
	          resultDiv.className = 'wizard-test-result success';
	          msgSpan.innerHTML = `‚úÖ <strong>Connected!</strong> Successfully verified ${typeof providerLabel === 'function' ? providerLabel(provider) : 'upstream'} connection.`;
	          saveWizardSettings({ base_url: baseUrl, provider, api_key: apiKey, models: modelsAllowlist.join(",") });
	          setTimeout(() => goToStep(5), 1000);
	        } catch (err) {
	          resultDiv.className = 'wizard-test-result error';
	          msgSpan.innerHTML = `‚ùå <strong>${t('wizardConnectionFailed')}</strong> ` + (err && err.message ? err.message : t('upstreamTestHintGeneric'));
	        } finally {
	          testBtn.disabled = false;
	          testBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Retry';
	        }
	      }

		      async function runGatewayIssue() {
		        configureWizardOverlayCta(gatewayIssueCta, "", "");
		        const envName = gatewayEnvNameInput ? gatewayEnvNameInput.value.trim() : '';
		        const baseUrl = gatewayBaseUrlInput ? gatewayBaseUrlInput.value.trim() : '';
		        if (!envName) {
		          wizardResult('error', 'wizardGatewayResult', `‚ùå <strong>${t('wizardGatewayEnvRequired')}</strong>`);
          if (gatewayEnvNameInput) gatewayEnvNameInput.focus();
          return;
        }
        if (!baseUrl) {
          wizardResult('error', 'wizardGatewayResult', `‚ùå <strong>${t('wizardGatewayBaseRequired')}</strong>`);
          if (gatewayBaseUrlInput) gatewayBaseUrlInput.focus();
          return;
        }
        const canCallApi = window.apiClient && window.apiClient.saveSettingsEnvironment && window.apiClient.issueControlToken;
        if (!canCallApi) {
          wizardResult('error', 'wizardGatewayResult', `‚ùå <strong>${t('wizardGatewayApiUnavailable')}</strong>`);
          return;
        }
        if (gatewayIssueBtn) {
          gatewayIssueBtn.disabled = true;
          gatewayIssueBtn.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px;"><svg style="width:16px;height:16px;animation:spin 1s linear infinite;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 11-6-8.49"/></svg>${t('wizardGatewayIssueInProgress')}</span>`;
        }
        try {
          const saved = await window.apiClient.saveSettingsEnvironment({
            name: envName,
            endpoint_url: baseUrl,
            status: 'active',
            memo: 'wizard'
          });
          if (!saved || saved.id === undefined || saved.id === null) {
            throw new Error(t('wizardGatewayEnvSaveFailed'));
          }
          await refreshEnvironments();
	          const expiryIso = '';
	          const note = '';
		          const tokenResult = await window.apiClient.issueControlToken({
		            env_id: saved.id,
		            expires_at: expiryIso,
		            note
		          });
		          if (!tokenResult || !tokenResult.ok || !tokenResult.data || !tokenResult.data.token) {
		            let failKey = 'wizardGatewayIssueFailed';
		            let ctaAction = '';
		            let ctaLabelKey = '';
		            if (!tokenResult || tokenResult.errorType === 'network' || tokenResult.errorType === 'timeout') {
		              failKey = 'gatewayIssueGatewayOffline';
		              ctaAction = 'diagnostics';
		              ctaLabelKey = 'ctaRunDiagnostics';
		            } else if (tokenResult.errorType === 'auth') {
		              failKey = 'wizardGatewayAdminRequired';
		              ctaAction = 'adminSession';
		              ctaLabelKey = 'ctaGoToAdminSession';
			            } else if (tokenResult.status === 404) {
			              failKey = 'gatewayIssueApiMissing';
			              ctaAction = 'diagnostics';
			              ctaLabelKey = 'ctaRunDiagnostics';
			            } else if (tokenResult.status === 503) {
			              failKey = 'wizardGatewayAdminTokenNotConfigured';
			              ctaAction = 'diagnostics';
			              ctaLabelKey = 'ctaRunDiagnostics';
			            } else if (tokenResult.status === 400 || tokenResult.status === 422) {
			              failKey = 'gatewayIssueInvalidInput';
			            } else if (tokenResult.errorType === 'server') {
			              failKey = 'gatewayIssueServerError';
			              ctaAction = 'diagnostics';
		              ctaLabelKey = 'ctaRunDiagnostics';
		            }
		            const statusHint =
		              tokenResult && tokenResult.status
		                ? ` <span style="color:var(--gray-600);font-size:12px;">(HTTP ${tokenResult.status})</span>`
		                : '';
		            configureWizardOverlayCta(gatewayIssueCta, ctaAction, ctaLabelKey);
		            wizardResult(
		              'error',
		              'wizardGatewayResult',
		              `‚ùå <strong>${t('wizardGatewayIssueFailed')}</strong> ${t(failKey)}${statusHint}`
		            );
		            return;
		          }
		          const issuedAt = new Date().toISOString();
		          window.SUITE_SETTINGS_GATEWAY = {
	            env_id: saved.id,
	            env_name: envName,
	            endpoint: baseUrl,
	            token: tokenResult.data.token,
	            preset: gatewayPreset ? gatewayPreset.value : 'openai-env',
	            expiry: tokenResult.data.expires_at || expiryIso,
	            note,
	            issued_at: issuedAt
	          };
          if (gatewayEnvironment) {
            gatewayEnvironment.value = String(saved.id);
          }
	          if (gatewayToken) gatewayToken.value = tokenResult.data.token;
	          if (gatewayExpiry) gatewayExpiry.value = tokenResult.data.expires_at ? toUtcDatetime(tokenResult.data.expires_at) : '';
	          if (gatewayNote) gatewayNote.value = '';
	          renderGatewayConfig();
		          await refreshGatewayTokens();
		          wizardResult('success', 'wizardGatewayResult', `‚úÖ <strong>${t('wizardGatewayIssueSuccess')}</strong>`);
	          setTimeout(() => goToStep(6), 800);
	        } catch (err) {
	          const msg = err && err.message ? err.message : t('wizardGatewayIssueFailed');
	          wizardResult('error', 'wizardGatewayResult', `‚ùå <strong>${t('wizardGatewayIssueFailed')}</strong> ${msg}`);
	        } finally {
	          if (gatewayIssueBtn) {
	            gatewayIssueBtn.disabled = false;
	            gatewayIssueBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg><span id="wizardIssueTokenLabel">${t('wizardGatewayIssueBtn')}</span>`;
          }
        }
      }

	      function saveWizardSettings(upstream) {
	        const payload = upstream && typeof upstream === "object" ? upstream : {};
	        const baseUrl = normalizeWizardValue(payload.base_url);
	        const provider = normalizeWizardValue(payload.provider);
	        const models = normalizeWizardValue(payload.models);
	        const apiKey = normalizeWizardValue(payload.api_key);

	        // Save to localStorage or sync with main settings
	        window.SUITE_SETTINGS_UPSTREAM = {
	          base_url: baseUrl,
	          provider,
	          api_key: apiKey,
	          models,
	        };

	        // Update main form if it exists
	        const baseUrlInput = document.getElementById('upstreamBaseUrl');
	        const apiKeyMainInput = document.getElementById('upstreamApiKey');
	        const modelsInput = document.getElementById('upstreamModels');
	        const providerInput = document.getElementById('upstreamProvider');
	        
	        if (baseUrlInput) baseUrlInput.value = baseUrl;
	        if (providerInput && typeof setUpstreamProviderUi === "function") {
	          setUpstreamProviderUi(provider || providerInput.value || "openai_compatible", { preferExisting: false });
	        }
	        if (apiKeyMainInput && apiKey) apiKeyMainInput.value = apiKey;
	        if (modelsInput) modelsInput.value = models;
	        if (typeof mergeUpstreamDraft === 'function') {
	          mergeUpstreamDraft({
	            base_url: baseUrl,
	            provider,
	            models
	          });
	        }

        // Trigger upstream save if function exists
        if (typeof renderUpstreamSummary === 'function') {
          renderUpstreamSummary();
        }
      }

      // Event listeners
      nextBtn.addEventListener('click', async () => {
        if (currentStep === 1) {
          // Step 1 is informational only ‚Äî always allow proceeding to Step 2.
          goToStep(2);
          return;
        }
        if (currentStep === 4) {
          // Step 4 (Connection Test) is optional ‚Äî save config without testing.
          try {
            const provider = getSelectedWizardProvider();
            const providerKeyForRules = getWizardProviderKeyForRules();
            const baseUrl = wizardUpstreamBaseUrl ? wizardUpstreamBaseUrl.value.trim() : "";
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : "";
            const modelRaw = modelSelect ? modelSelect.value.trim() : "";
            const rawModels = modelRaw.split(",").map(s => s.trim()).filter(Boolean);
            const modelsAllowlist = normalizeWizardModelIds(rawModels, providerKeyForRules);
            // Save upstream config (best-effort)
            if (window.apiClient && window.apiClient.saveControlUpstream) {
              await window.apiClient.saveControlUpstream({
                base_url: baseUrl, api_key: apiKey, provider, models_allowlist: modelsAllowlist
              });
            }
            // Set GOOGLE_API_KEY for Gemini features (Council, Scanner, RedTeam, Web Sandbox)
            if (apiKey) {
              const authToken = (typeof getAdminToken === 'function') ? getAdminToken() : (window.SUITE_ADMIN_TOKEN || '');
              const hdrs = { 'Content-Type': 'application/json' };
              if (authToken) hdrs['Authorization'] = 'Bearer ' + authToken;
              await fetch('/api/config/gemini-key', { method: 'POST', headers: hdrs, body: JSON.stringify({ api_key: apiKey }) });
            }
            if (apiKey) upstreamHasKey = true;
            saveWizardSettings({ base_url: baseUrl, provider, api_key: apiKey, models: modelsAllowlist.join(",") });
          } catch (e) {
            console.warn('[wizard] config save on skip failed', e);
          }
          goToStep(5);
          return;
        }
        if (currentStep === 6) {
          completeWizard();
          window.location.href = 'dashboard.html';
          return;
        }

        if (validateStep(currentStep)) {
          goToStep(currentStep + 1);
        }
      });

      prevBtn.addEventListener('click', () => {
        if (currentStep > 1) {
          goToStep(currentStep - 1);
        }
      });

      skipBtn.addEventListener('click', () => {
        completeWizard();
      });

      testBtn.addEventListener('click', runConnectionTest);
      if (wizardPrecheckBtn) {
        wizardPrecheckBtn.addEventListener('click', async () => {
          // Run diagnostics is informational ‚Äî always proceed to Step 2
          goToStep(2);
        });
      }
      if (gatewayIssueBtn) {
        gatewayIssueBtn.addEventListener('click', runGatewayIssue);
      }
      if (gatewayModeAuto) {
        gatewayModeAuto.addEventListener('change', updateGatewayMode);
      }
      if (gatewayModeManual) {
        gatewayModeManual.addEventListener('change', updateGatewayMode);
      }
      updateGatewayMode();

      // Start button in intro guide
      const introResetBtn = document.getElementById('introGuideResetBtn');
      if (introResetBtn) {
        introResetBtn.addEventListener('click', () => {
          localStorage.removeItem(WIZARD_COMPLETED_KEY);
          goToStep(1);
          showWizard();
        });
      }

      // Add spin animation
      const style = document.createElement('style');
      style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
      document.head.appendChild(style);

      window.openWizard = (step = 1) => {
        showWizard();
        goToStep(step);
      };

	      // Initialize: show wizard for first-time users (only in browser)
	      if (typeof window !== 'undefined' && typeof setTimeout !== 'undefined') {
	        setTimeout(() => {
	          if (shouldShowWizard()) {
	            showWizard();
	            // Always start at Step 2 (Configure Upstream LLM) ‚Äî Step 1 is optional
	            goToStep(2);
	          }
	        }, 500);
	      }

	      // Provider preset helpers
	      if (wizardUpstreamProvider) {
	        if (wizardUpstreamBaseUrl) {
	          wizardUpstreamBaseUrl.addEventListener("input", () => {
	            if (wizardUpstreamBaseUrl.dataset) delete wizardUpstreamBaseUrl.dataset.presetProvider;
	          });
	        }
	        if (modelSelect) {
	          modelSelect.addEventListener("input", () => {
	            if (modelSelect.dataset) delete modelSelect.dataset.presetProvider;
	          });
	        }
	        if (wizardUpstreamProviderCustom) {
	          wizardUpstreamProviderCustom.addEventListener("input", () => {
	            renderWizardUpstreamProviderHint();
	          });
	        }
	        wizardUpstreamProvider.addEventListener("change", () => {
	          syncWizardProviderCustomVisibility();
	          const selected = wizardUpstreamProvider.value;
	          if (selected !== "custom" && selected !== "openai_compatible") {
	            maybeApplyWizardPreset(selected, { force: true });
	          } else if (selected !== "custom") {
	            maybeApplyWizardPreset(selected, { force: false });
	          }
	          renderWizardUpstreamProviderHint();
	        });
	        syncWizardProviderCustomVisibility();
	        if (wizardUpstreamProvider.value !== "custom" && wizardUpstreamProvider.value !== "openai_compatible") {
	          maybeApplyWizardPreset(wizardUpstreamProvider.value, { force: false });
	        }
	        renderWizardUpstreamProviderHint();
	      }
	    })();
	  </script>
</body>

</html>
